import TrainingData.Frontend
import Mathlib.Control.Basic
import Mathlib.Lean.Expr.Basic
import Mathlib.Tactic.Common
import Mathlib.Tactic.ToExpr
import Aesop
import Lean.Util.Trace
import Duper
import QuerySMT
import Hammer
import Cli

open Lean Core Elab IO Meta Term Tactic -- All the monads!

set_option autoImplicit true

def useAesop : TacticM Unit := do evalTactic (← `(tactic| aesop))
def useExact? : TacticM Unit := do evalTactic (← `(tactic| exact?))
def useRfl : TacticM Unit := do evalTactic (← `(tactic| intros; rfl))
def useSimpAll : TacticM Unit := do evalTactic (← `(tactic| intros; simp_all))
def useOmega : TacticM Unit := do evalTactic (← `(tactic| intros; omega))
def useDuper : TacticM Unit := do evalTactic (← `(tactic| duper [*]))
def useQuerySMT : TacticM Unit := do evalTactic (← `(tactic| querySMT))
def useHammer (hammerRecommendation : Array String) : TacticM Unit := do
  dbg_trace "About to convert hammerRecommendation to names"
  let hammerRecommendation : Array Name := hammerRecommendation.map String.toName
  dbg_trace "About to convert hammerRecommendation to constants"
  let hammerRecommendation : Array Expr ← hammerRecommendation.mapM (fun n => mkConstWithLevelParams n)
  dbg_trace "About to convert hammerRecommendation to terms"
  let hammerRecommendation : Array Term ← hammerRecommendation.mapM (fun e => withOptions Auto.ppOptionsSetting $ PrettyPrinter.delab e)
  dbg_trace "hammerRecommendation after transforming to terms: {hammerRecommendation}"
  evalTactic (← `(tactic| hammer [$(hammerRecommendation),*])) -- **TODO** Add `*` so that local hypotheses will be available

/--
Compile the designated module, and run a monadic function with each new `ConstantInfo`,
with the `Environment` as it was *before* the command which created that declaration.

(Internal declarations according to `Name.isBlackListed` are skipped.)

If `withImportsDir` is provided, then `runAtDecls` uses the version of the file contained in the `WithImports` directory
-/
def runAtDecls (mod : Name) (withImportsDir : Option String := none) (tac : ConstantInfo → MetaM (Option α)) : MLList IO (ConstantInfo × α) := do
  let fileName ←
    match withImportsDir with
    | none => pure (← findLean mod).toString
    | some withImportsDir => pure (← findLeanWithImports mod "mathlib" withImportsDir).toString
  let steps :=
    match withImportsDir with
    | none => compileModule' mod
    | some withImportsDir => compileModuleWithImports' mod "mathlib" withImportsDir
  let targets := steps.bind fun c => (MLList.ofList c.diff).map fun i => (c, i)

  targets.filterMapM fun (cmd, ci) => do
    for m in cmd.msgs do IO.eprintln (bombEmoji ++ (← m.data.toString))
    unless cmd.msgs.isEmpty do
      throw <| IO.userError s!"Unexpected messages in: {mod} during elaboration of {cmd.stx}"

    let options := ({} : KVMap).insert `maxHeartbeats (.ofNat 20000)
    let ctx := { fileName, options, fileMap := default }
    let state := { env := cmd.before }
    -- From `IO` to `CoreM`:
    Prod.fst <$> (CoreM.toIO · ctx state) do
      if ← ci.name.isBlackListed then
        pure none
      else
        -- From `CoreM` to `MetaM`:
        MetaM.run' (ctx := {}) (s := {}) do
          match ← tac ci with
          | some r => pure (ci, r)
          | none => pure none

inductive ResultType
| failure
| subgoals
| notDefEq
| success
| notApplicable -- Used when attempting to evaluate the hammer on a declaration that doesn't enter tactic mode
deriving Repr, BEq

instance : ToString ResultType where
  toString := fun
  | .failure => "failure"
  | .subgoals => "subgoals"
  | .notDefEq => "notDefEq"
  | .success => "success"
  | .notApplicable => "notApplicable"

structure Result where
  type : ResultType
  seconds : Float
  heartbeats : Nat

def withSeconds [Monad m] [MonadLiftT BaseIO m] (act : m α) : m (α × Float) := do
  let start ← IO.monoNanosNow
  let a ← act
  let stop ← IO.monoNanosNow
  return (a, (stop - start).toFloat / 1000000000)

/--
Compile the designated module, select declarations satisfying a predicate,
and run a tactic on the type of each declaration.
-/
def runTacticAtDecls (mod : Name) (decls : ConstantInfo → CoreM Bool) (tac : TacticM Unit) :
  MLList IO (ConstantInfo × Result) := do
  runAtDecls mod none fun ci => do
    if ! (← decls ci) then return none
    let g ← mkFreshExprMVar ci.type
    let ((gs, heartbeats), seconds) ← withSeconds <| withHeartbeats <|
      try? <| TermElabM.run' do
        Tactic.run g.mvarId! tac
    let type : ResultType ← match gs with
    | none => pure .failure
    | some (_ :: _) => pure .subgoals
    | some [] =>
      match ci.value? with
      | none => pure .success
      | some v =>
        if ← isProp ci.type then
          pure .success
        else
        match ← try? (isDefEq g v) with
        | none
          -- In this case we should perhaps return an "uncertain" value.
          -- The problem is that `v` may contain constants generated by the simplifier
          -- during elaboration of the original proof,
          -- and which aren't in the current environment, so we can't really compare `g` and `v`
        | some false => pure .notDefEq
        | some true => pure .success
    return some ⟨type, seconds, heartbeats⟩

def runHammerAtDecls (mod : Name) (decls : ConstantInfo → CoreM Bool) (withImportsPath : String) (jsonDir : String) :
  MLList IO (ConstantInfo × Result) := do
  runAtDecls mod (some withImportsPath) fun ci => do
    if ! (← decls ci) then return none
    let g ← mkFreshExprMVar ci.type
    -- Find JSON file corresponding to current `mod`
    let fileName := (← findJSONFile mod "mathlib" jsonDir).toString
    let jsonObjects ← IO.FS.lines fileName
    let json ← IO.ofExcept $ jsonObjects.mapM Json.parse
    -- Find `declHammerRecommendation` corresponding to current `ci`
    /- We take just the string suffix rather than the whole name because whole name may include the namespace
       which might not appear in `decl`. This approach is a hack though and should be replaced before attempting
       anything beyond testing individual files -/
    let ciNameSuffix ←
      match ci.name with
      | .str _ s => pure s
      | _ => throwError "runHammerAtDecls :: Error processing constant name {ci.name}"
    let mut ciEntry := Json.null
    for jsonEntry in json do
      let jsonDecl ← IO.ofExcept $ jsonEntry.getObjVal? "decl"
      let curDecl ← IO.ofExcept $ jsonDecl.getStr?
      /- **TODO** This approach is not reliable for a variety of reasons. The biggest issue is that comments
         referring to other theorems can appear in the declaration. -/
      if curDecl.containsSubstr ciNameSuffix then
        ciEntry := jsonEntry
        break
    if ciEntry.isNull then
      return some ⟨.notApplicable, 0.0, 0⟩
    let hammerRecommendation ← IO.ofExcept $ ciEntry.getObjVal? "declHammerRecommendation"
    let hammerRecommendation ← IO.ofExcept $ hammerRecommendation.getArr?
    let hammerRecommendation ← IO.ofExcept $ hammerRecommendation.mapM Json.getStr?
    let ((gs, heartbeats), seconds) ← withSeconds <| withHeartbeats <|
      try? <| TermElabM.run' do
        dbg_trace "About to use hammer for {ci.name} (recommendation: {hammerRecommendation})"
        Tactic.run g.mvarId! $ useHammer hammerRecommendation
    let type : ResultType ← match gs with
    | none => pure .failure
    | some (_ :: _) => pure .subgoals
    | some [] =>
      match ci.value? with
      | none => pure .success
      | some v =>
        if ← isProp ci.type then
          pure .success
        else
        match ← try? (isDefEq g v) with
        | none
          -- In this case we should perhaps return an "uncertain" value.
          -- The problem is that `v` may contain constants generated by the simplifier
          -- during elaboration of the original proof,
          -- and which aren't in the current environment, so we can't really compare `g` and `v`
        | some false => pure .notDefEq
        | some true => pure .success
    return some ⟨type, seconds, heartbeats⟩

open Cli System

def tacticBenchmarkFromModule (module : ModuleName) (tac : TacticM Unit) : IO UInt32 := do
  searchPathRef.set compile_time_search_path%
  let result := runTacticAtDecls module (fun _ => pure true) tac
  IO.println s!"{module}"
  for (ci, ⟨type, seconds, heartbeats⟩) in result do
    IO.println <| (if type == .success then checkEmoji else crossEmoji) ++ " " ++ ci.name.toString ++
      s!" ({seconds}s) ({heartbeats} heartbeats)"
  return 0

def hammerBenchmarkFromModule (module : ModuleName) (withImportsDir : String) (jsonDir : String) : IO UInt32 := do
  searchPathRef.set compile_time_search_path%
  let result := runHammerAtDecls module (fun _ => pure true) withImportsDir jsonDir
  IO.println s!"{module}"
  for (ci, ⟨type, seconds, heartbeats⟩) in result do
    IO.println <| (if type == .success then checkEmoji else crossEmoji) ++ " " ++ ci.name.toString ++
      s!" ({seconds}s) ({heartbeats} heartbeats)"
  return 0

def tacticBenchmarkMain (args : Cli.Parsed) : IO UInt32 := do
  let module := args.positionalArg! "module" |>.as! ModuleName
  let tac ←
    if args.hasFlag "duper" then pure useDuper else
    if args.hasFlag "querySMT" then pure useQuerySMT else
    if args.hasFlag "aesop" then pure useAesop else
    if args.hasFlag "exact" then pure useExact? else
    if args.hasFlag "rfl" then pure useRfl else
    if args.hasFlag "simp_all" then pure useSimpAll else
    if args.hasFlag "omega" then pure useOmega else
    throw <| IO.userError "Specify a tactic, e.g. `--aesop`"
  tacticBenchmarkFromModule module tac

/-- Setting up command line options and help text for `lake exe tactic_benchmark`. -/
def tactic_benchmark : Cmd := `[Cli|
  tactic_benchmark VIA tacticBenchmarkMain; ["0.0.1"]
  "Run a customisable tactic at all declarations in a file."

  FLAGS:
    "aesop";       "Use `aesop`."
    "exact";       "Use `exact?`."
    "rfl";         "Use `intros; rfl`."
    "simp_all";    "Use `intros; simp_all`."
    "omega";       "Use `intros; omega`."
    "duper";       "Use `duper [*]`."
    "querySMT";    "Use `querySMT`."

  ARGS:
    module : ModuleName; "Lean module to compile and export InfoTrees."
]

/-- `lake exe tactic_benchmark` -/
def main (args : List String) : IO UInt32 :=
  tactic_benchmark.validate args

-- See `scripts/tactic_benchmark.sh` for a script to run this on all of Mathlib.

-- #eval tacticBenchmarkFromModule `temp useDuper
-- #eval tacticBenchmarkFromModule `temp useQuerySMT

-- Note: `tacticBenchmarkFromModule` requires that the tactic we want be imported in the module
/- **TODO** Figure out heartbeat issue (querySMT can solve list_eq_self and zero_eq_zero) plenty quickly,
   but `tacticBenchmarkFromModule` says it doesn't solve the former and takes significantly longer to
   solve the latter -/
/- Interestingly, `useDuper` doesn't seem to (obviously) run into the same issue as `useQuerySMT`.
   I think this is because Duper has precompiledModules enabled whereas QuerySMT doesn't, but that's
   something to investigate further -/
