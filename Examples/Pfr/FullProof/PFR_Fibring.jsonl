{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n","proof":":= by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf","declId":"PFR.Fibring.30_0.yPsb0LSqh9ovyrz","decl":"/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\n","proof":":= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)","declId":"PFR.Fibring.62_0.yPsb0LSqh9ovyrz","decl":"lemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']"}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\nlemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']:= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)\n\n","proof":":= by\n  apply le_trans _ (rdist_le_sum_fibre π h1 h2 (μ := μ) (μ' := μ'))\n  rw [le_add_iff_nonneg_right]\n  exact condRuzsaDist_nonneg h1 ((measurable_of_countable π).comp h1) h2\n    ((measurable_of_countable π).comp h2)","declId":"PFR.Fibring.75_0.yPsb0LSqh9ovyrz","decl":"/-- \\[d[X;Y]\\geq d[\\pi(X);\\pi(Y)].\\] -/\nlemma rdist_of_hom_le {Z_1 : Ω → H} {Z_2 : Ω' → H}\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n    d[π ∘ Z_1; μ # π ∘ Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ'] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\nlemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']:= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)\n\n/-- \\[d[X;Y]\\geq d[\\pi(X);\\pi(Y)].\\] -/\nlemma rdist_of_hom_le {Z_1 : Ω → H} {Z_2 : Ω' → H}\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n    d[π ∘ Z_1; μ # π ∘ Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ'] := by\n  apply le_trans _ (rdist_le_sum_fibre π h1 h2 (μ := μ) (μ' := μ'))\n  rw [le_add_iff_nonneg_right]\n  exact condRuzsaDist_nonneg h1 ((measurable_of_countable π).comp h1) h2\n    ((measurable_of_countable π).comp h2)\n\nend GeneralFibring\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G]\nvariable {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ : Measure Ω} [IsProbabilityMeasure μ]\n\n","proof":":= by\n  let Y' : Fin 4 → Ω → G\n    | 0 => Y 0\n    | 1 => Y 1\n    | 2 => Y 0 - Y 2\n    | 3 => Y 1 - Y 3\n  let f : (G × G) → (G × G) := fun (g, h) ↦ (g, g - h)\n  have hf : Measurable f := measurable_of_countable _\n  have h_indep' : IndepFun (⟨Y' 0, Y' 2⟩) (⟨Y' 1, Y' 3⟩) μ :=\n    (h_indep.indepFun_prod_mk_prod_mk h_meas 0 2 1 3\n      (by decide) (by decide) (by decide) (by decide)).comp hf hf\n  have h_meas' : ∀ i, Measurable (Y' i)\n    | 0 => h_meas 0\n    | 1 => h_meas 1\n    | 2 => (h_meas 0).sub (h_meas 2)\n    | 3 => (h_meas 1).sub (h_meas 3)\n  have h' (i j : Fin 4) : ⟨Y i, Y j⟩ = ⟨Y i, Y i - (Y i - Y j)⟩ := by simp only [sub_sub_cancel]\n  rw [h' 0 2, h' 1 3]\n  exact condRuzsaDist_of_inj_map Y' h_indep' h_meas'\n    ((AddMonoidHom.fst G G).prod ((AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)))\n    (fun _ _ _ h ↦ (Prod.ext_iff.1 h).1)","declId":"PFR.Fibring.90_0.yPsb0LSqh9ovyrz","decl":"/-- The conditional Ruzsa Distance step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condRuzsaDist {Y : Fin 4 → Ω → G} (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[⟨Y 0, Y 2⟩ | Y 0 - Y 2 ; μ # ⟨Y 1, Y 3⟩ | Y 1 - Y 3 ; μ] = d[Y 0 | Y 0 - Y 2 ; μ # Y 1 | Y 1 - Y 3 ; μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\nlemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']:= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)\n\n/-- \\[d[X;Y]\\geq d[\\pi(X);\\pi(Y)].\\] -/\nlemma rdist_of_hom_le {Z_1 : Ω → H} {Z_2 : Ω' → H}\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n    d[π ∘ Z_1; μ # π ∘ Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ'] := by\n  apply le_trans _ (rdist_le_sum_fibre π h1 h2 (μ := μ) (μ' := μ'))\n  rw [le_add_iff_nonneg_right]\n  exact condRuzsaDist_nonneg h1 ((measurable_of_countable π).comp h1) h2\n    ((measurable_of_countable π).comp h2)\n\nend GeneralFibring\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G]\nvariable {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ : Measure Ω} [IsProbabilityMeasure μ]\n\n/-- The conditional Ruzsa Distance step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condRuzsaDist {Y : Fin 4 → Ω → G} (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[⟨Y 0, Y 2⟩ | Y 0 - Y 2 ; μ # ⟨Y 1, Y 3⟩ | Y 1 - Y 3 ; μ] = d[Y 0 | Y 0 - Y 2 ; μ # Y 1 | Y 1 - Y 3 ; μ] := by\n  let Y' : Fin 4 → Ω → G\n    | 0 => Y 0\n    | 1 => Y 1\n    | 2 => Y 0 - Y 2\n    | 3 => Y 1 - Y 3\n  let f : (G × G) → (G × G) := fun (g, h) ↦ (g, g - h)\n  have hf : Measurable f := measurable_of_countable _\n  have h_indep' : IndepFun (⟨Y' 0, Y' 2⟩) (⟨Y' 1, Y' 3⟩) μ :=\n    (h_indep.indepFun_prod_mk_prod_mk h_meas 0 2 1 3\n      (by decide) (by decide) (by decide) (by decide)).comp hf hf\n  have h_meas' : ∀ i, Measurable (Y' i)\n    | 0 => h_meas 0\n    | 1 => h_meas 1\n    | 2 => (h_meas 0).sub (h_meas 2)\n    | 3 => (h_meas 1).sub (h_meas 3)\n  have h' (i j : Fin 4) : ⟨Y i, Y j⟩ = ⟨Y i, Y i - (Y i - Y j)⟩ := by simp only [sub_sub_cancel]\n  rw [h' 0 2, h' 1 3]\n  exact condRuzsaDist_of_inj_map Y' h_indep' h_meas'\n    ((AddMonoidHom.fst G G).prod ((AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)))\n    (fun _ _ _ h ↦ (Prod.ext_iff.1 h).1)\n\n","proof":":= by\n  suffices : I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - (Y 2 - Y 3) ;μ]\n  . convert this using 2\n    abel\n  symm\n  have hm (f : G → G → G × G) {a b i j k l : Fin 4} :\n    Measurable (Function.uncurry f ∘ ⟨Y i - Y j - (Y k - Y l), Y a - Y b⟩) :=\n    (measurable_of_countable (Function.uncurry f)).comp\n    ((((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))).prod_mk\n    ((h_meas _).sub (h_meas _)))\n  have hmf : Measurable fun ω ↦ ((Y 0 - Y 1) ω, (Y 0 - Y 1) ω - (Y 0 - Y 1 - (Y 2 - Y 3)) ω) :=\n    hm (fun z x ↦ (x, x - z))\n  have hmg : Measurable fun ω ↦ ((Y 1 - Y 3) ω + (Y 0 - Y 1 - (Y 2 - Y 3)) ω, (Y 1 - Y 3) ω) :=\n    hm (fun z x ↦ (x + z, x))\n  have hmij {i j : Fin 4} : Measurable (Y i - Y j) := (h_meas _).sub (h_meas _)\n  have hm0123 {i j k l : Fin 4} : Measurable (Y i - Y j - (Y k - Y l)) :=\n    ((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))\n  rw [← condMutualInfo_of_inj_map hmij hmij hm0123 (fun z x ↦ (x, x - z)),\n    condMutualInfo_comm hmf hmij,\n    ← condMutualInfo_of_inj_map hmij hmf hm0123 (fun z x ↦ (x + z, x)),\n    condMutualInfo_comm hmg hmf]\n  . congr 1\n    { ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n    { rw [sub_sub, add_sub_left_comm, ← sub_sub]\n      ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, add_sub_cancel'_right] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n  . exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).2\n  exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).1","declId":"PFR.Fibring.115_0.yPsb0LSqh9ovyrz","decl":"/-- The conditional mutual information step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condMutualInfo {Y : Fin 4 → Ω → G}\n  (h_meas : ∀ i, Measurable (Y i)) :\n    I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - Y 2 + Y 3;μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\nlemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']:= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)\n\n/-- \\[d[X;Y]\\geq d[\\pi(X);\\pi(Y)].\\] -/\nlemma rdist_of_hom_le {Z_1 : Ω → H} {Z_2 : Ω' → H}\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n    d[π ∘ Z_1; μ # π ∘ Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ'] := by\n  apply le_trans _ (rdist_le_sum_fibre π h1 h2 (μ := μ) (μ' := μ'))\n  rw [le_add_iff_nonneg_right]\n  exact condRuzsaDist_nonneg h1 ((measurable_of_countable π).comp h1) h2\n    ((measurable_of_countable π).comp h2)\n\nend GeneralFibring\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G]\nvariable {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ : Measure Ω} [IsProbabilityMeasure μ]\n\n/-- The conditional Ruzsa Distance step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condRuzsaDist {Y : Fin 4 → Ω → G} (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[⟨Y 0, Y 2⟩ | Y 0 - Y 2 ; μ # ⟨Y 1, Y 3⟩ | Y 1 - Y 3 ; μ] = d[Y 0 | Y 0 - Y 2 ; μ # Y 1 | Y 1 - Y 3 ; μ] := by\n  let Y' : Fin 4 → Ω → G\n    | 0 => Y 0\n    | 1 => Y 1\n    | 2 => Y 0 - Y 2\n    | 3 => Y 1 - Y 3\n  let f : (G × G) → (G × G) := fun (g, h) ↦ (g, g - h)\n  have hf : Measurable f := measurable_of_countable _\n  have h_indep' : IndepFun (⟨Y' 0, Y' 2⟩) (⟨Y' 1, Y' 3⟩) μ :=\n    (h_indep.indepFun_prod_mk_prod_mk h_meas 0 2 1 3\n      (by decide) (by decide) (by decide) (by decide)).comp hf hf\n  have h_meas' : ∀ i, Measurable (Y' i)\n    | 0 => h_meas 0\n    | 1 => h_meas 1\n    | 2 => (h_meas 0).sub (h_meas 2)\n    | 3 => (h_meas 1).sub (h_meas 3)\n  have h' (i j : Fin 4) : ⟨Y i, Y j⟩ = ⟨Y i, Y i - (Y i - Y j)⟩ := by simp only [sub_sub_cancel]\n  rw [h' 0 2, h' 1 3]\n  exact condRuzsaDist_of_inj_map Y' h_indep' h_meas'\n    ((AddMonoidHom.fst G G).prod ((AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)))\n    (fun _ _ _ h ↦ (Prod.ext_iff.1 h).1)\n\n/-- The conditional mutual information step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condMutualInfo {Y : Fin 4 → Ω → G}\n  (h_meas : ∀ i, Measurable (Y i)) :\n    I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - Y 2 + Y 3;μ] := by\n  suffices : I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - (Y 2 - Y 3) ;μ]\n  . convert this using 2\n    abel\n  symm\n  have hm (f : G → G → G × G) {a b i j k l : Fin 4} :\n    Measurable (Function.uncurry f ∘ ⟨Y i - Y j - (Y k - Y l), Y a - Y b⟩) :=\n    (measurable_of_countable (Function.uncurry f)).comp\n    ((((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))).prod_mk\n    ((h_meas _).sub (h_meas _)))\n  have hmf : Measurable fun ω ↦ ((Y 0 - Y 1) ω, (Y 0 - Y 1) ω - (Y 0 - Y 1 - (Y 2 - Y 3)) ω) :=\n    hm (fun z x ↦ (x, x - z))\n  have hmg : Measurable fun ω ↦ ((Y 1 - Y 3) ω + (Y 0 - Y 1 - (Y 2 - Y 3)) ω, (Y 1 - Y 3) ω) :=\n    hm (fun z x ↦ (x + z, x))\n  have hmij {i j : Fin 4} : Measurable (Y i - Y j) := (h_meas _).sub (h_meas _)\n  have hm0123 {i j k l : Fin 4} : Measurable (Y i - Y j - (Y k - Y l)) :=\n    ((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))\n  rw [← condMutualInfo_of_inj_map hmij hmij hm0123 (fun z x ↦ (x, x - z)),\n    condMutualInfo_comm hmf hmij,\n    ← condMutualInfo_of_inj_map hmij hmf hm0123 (fun z x ↦ (x + z, x)),\n    condMutualInfo_comm hmg hmf]\n  . congr 1\n    { ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n    { rw [sub_sub, add_sub_left_comm, ← sub_sub]\n      ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, add_sub_cancel'_right] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n  . exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).2\n  exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).1\n\n\n","proof":":= by\n  let π : G × G →+ G := (AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)\n  have hπ {W_1 W_2 : Ω → G} : π ∘ ⟨W_1, W_2⟩ = W_1 - W_2 := rfl\n  let Z_1 : Ω → G × G := ⟨Y 0, Y 2⟩\n  let Z_2 : Ω → G × G := ⟨Y 1, Y 3⟩\n  have hZ : Z_1 - Z_2 = ⟨Y 0 - Y 1, Y 2 - Y 3⟩ := rfl\n  have m1 : Measurable Z_1 := (h_meas 0).prod_mk (h_meas 2)\n  have m2 : Measurable Z_2 := (h_meas 1).prod_mk (h_meas 3)\n  have h_indep_0 : IndepFun (Y 0) (Y 1) μ := h_indep.indepFun (by decide)\n  have h_indep_2 : IndepFun (Y 2) (Y 3) μ := h_indep.indepFun (by decide)\n  have h_indep_Z : IndepFun Z_1 Z_2 μ := h_indep.indepFun_prod_mk_prod_mk h_meas\n    0 2 1 3 (by decide) (by decide) (by decide) (by decide)\n  have h_indep_sub : IndepFun (Y 0 - Y 1) (Y 2 - Y 3) μ :=\n    h_indep.indepFun_sub_sub h_meas 0 1 2 3 (by decide) (by decide) (by decide) (by decide)\n  have msub (i j : Fin 4) : Measurable (Y i - Y j) := (h_meas i).sub (h_meas j)\n  have h_add : d[Z_1; μ # Z_2; μ] = d[Y 0; μ # Y 1; μ] + d[Y 2; μ # Y 3; μ] := by\n    rw [h_indep_0.rdist_eq (h_meas 0) (h_meas 1), h_indep_2.rdist_eq (h_meas 2) (h_meas 3),\n      h_indep_Z.rdist_eq m1 m2, hZ,\n      (entropy_pair_eq_add (h_meas 0) (h_meas 2)).2 (h_indep.indepFun (by decide)),\n      (entropy_pair_eq_add (h_meas 1) (h_meas 3)).2 (h_indep.indepFun (by decide)),\n      (entropy_pair_eq_add (msub 0 1) (msub 2 3)).2 h_indep_sub]\n    ring_nf\n  rw [← h_add, rdist_of_indep_eq_sum_fibre π h_indep_Z m1 m2]\n  simp only [hπ, hZ]\n  rw [sum_of_rdist_eq_step_condRuzsaDist h_indep h_meas,\n    sum_of_rdist_eq_step_condMutualInfo h_meas]","declId":"PFR.Fibring.153_0.yPsb0LSqh9ovyrz","decl":"/-- Let $Y_1,Y_2,Y_3$ and $Y_4$ be independent $G$-valued random variables.\n  Then\n$$d[Y_1-Y_3; Y_2-Y_4] + d[Y_1|Y_1-Y_3; Y_2|Y_2-Y_4] $$\n$$ + I[Y_1-Y_2 : Y_2 - Y_4 | Y_1-Y_2-Y_3+Y_4] = d[Y_1; Y_2] + d[Y_3; Y_4].$$\n-/\nlemma sum_of_rdist_eq (Y : Fin 4 → Ω → G) (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[Y 0; μ # Y 1; μ] + d[Y 2; μ # Y 3; μ]\n      = d[(Y 0) - (Y 2); μ # (Y 1) - (Y 3); μ]\n        + d[Y 0 | (Y 0) - (Y 2); μ # Y 1 | (Y 1) - (Y 3); μ]\n        + I[(Y 0) - (Y 1) : (Y 1) - (Y 3) | (Y 0) - (Y 1) - (Y 2) + (Y 3); μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The fibring identity\n\nThe proof of the fibring identity, which is a key component of the proof of PFR.\n\n## Main statement\n\n* `sum_of_rdist_eq`: If $Y_1,Y_2,Y_3,Y_4$ are independent, then $d[Y_1; Y_2] + d[Y_3; Y_4]$ is equal to the sum of\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\nand\n$$ I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4].$$\n\n-/\n\nopen MeasureTheory ProbabilityTheory\n\nsection GeneralFibring\n\n-- $\\pi : H \\to H'$ is a homomorphism between additive groups.\nvariable {H : Type*} [AddCommGroup H] [Countable H] [hH : MeasurableSpace H]\n  [MeasurableSingletonClass H]\n  {H' : Type*} [AddCommGroup H'] [Countable H'] [hH' : MeasurableSpace H']\n  [MeasurableSingletonClass H']\n  (π : H →+ H')\nvariable {Ω Ω' : Type*} [mΩ : MeasurableSpace Ω] [mΩ' : MeasurableSpace Ω']\n  {μ : Measure Ω} {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $Z_1, Z_2$ are independent, then $d[Z_1; Z_2]$ is equal to\n$$ d[\\pi(Z_1);\\pi(Z_2)] + d[Z_1|\\pi(Z_1); Z_2 |\\pi(Z_2)]$$\nplus\n$$I( Z_1 - Z_2 : (\\pi(Z_1), \\pi(Z_2)) | \\pi(Z_1 - Z_2) ).$$\n-/\nlemma rdist_of_indep_eq_sum_fibre {Z_1 Z_2: Ω → H} (h : IndepFun Z_1 Z_2 μ)\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2]:\n    d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ] + I[Z_1-Z_2 : ⟨π∘Z_1, π∘Z_2⟩ | π∘(Z_1 - Z_2); μ] := by\n  have hπ : Measurable π := measurable_of_countable _\n  have step1 : d[Z_1; μ # Z_2; μ] = d[π ∘ Z_1; μ # π ∘ Z_2; μ] +\n      H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] - H[Z_1 | π ∘ Z_1; μ] / 2 - H[Z_2 | π ∘ Z_2; μ] / 2 := by\n    have hsub : H[(Z_1 - Z_2)| π ∘ (Z_1 - Z_2); μ] = H[(Z_1 - Z_2); μ] - H[π ∘ (Z_1 - Z_2); μ] := condEntropy_comp_self (by measurability) hπ\n\n    rw [h.rdist_eq h1 h2, (h.comp hπ hπ).rdist_eq (hπ.comp h1) (hπ.comp h2),\n      condEntropy_comp_self h1 hπ, condEntropy_comp_self h2 hπ, hsub, π.comp_sub]\n    ring_nf\n  have m0 : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have h' : IndepFun (⟨Z_1, π ∘ Z_1⟩) (⟨Z_2, π ∘ Z_2⟩) μ := h.comp m0 m0\n  have m1 : Measurable (Z_1 - Z_2) := h1.sub h2\n  have m2 : Measurable (⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩) := (hπ.comp h1).prod_mk (hπ.comp h2)\n  have m3 : Measurable (↑π ∘ (Z_1 - Z_2)) := hπ.comp m1\n  have entroplem : H[Z_1 - Z_2|⟨⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩, ↑π ∘ (Z_1 - Z_2)⟩; μ]\n      = H[Z_1 - Z_2|⟨↑π ∘ Z_1, ↑π ∘ Z_2⟩; μ] := by\n    rw [π.comp_sub]\n    let f : H' × H' → (H' × H') × H' := fun (x,y) ↦ ((x,y), x - y)\n    have hf : Function.Injective f := fun _ _ h ↦ (Prod.ext_iff.1 h).1\n    have mf : Measurable f := measurable_id.prod_mk measurable_sub\n    refine condEntropy_of_injective' μ m1 m2 f hf (mf.comp m2)\n  rw [step1, condMutualInfo_eq' m1 m2 m3, entroplem,\n    condRuzsaDist_of_indep h1 (hπ.comp h1) h2 (hπ.comp h2) μ h']\n  ring_nf\n\nlemma rdist_le_sum_fibre {Z_1: Ω → H} {Z_2: Ω' → H}\n  (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n  d[π ∘ Z_1; μ # π ∘ Z_2; μ'] + d[Z_1|π∘Z_1; μ # Z_2|π∘Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ']:= by\n  obtain ⟨ν, W_1, W_2, hν, m1, m2, hi, hi1, hi2, _, _⟩ := ProbabilityTheory.independent_copies_finiteRange h1 h2 μ μ'\n  have hπ : Measurable π := measurable_of_countable _\n  have hφ : Measurable (fun x ↦ (x, π x)) := measurable_of_countable _\n  have hπ1 : IdentDistrib (⟨Z_1, π ∘ Z_1⟩) (⟨W_1, π ∘ W_1⟩) μ ν := hi1.symm.comp hφ\n  have hπ2 : IdentDistrib (⟨Z_2, π ∘ Z_2⟩) (⟨W_2, π ∘ W_2⟩) μ' ν := hi2.symm.comp hφ\n  rw [← hi1.rdist_eq hi2, ← (hi1.comp hπ).rdist_eq (hi2.comp hπ),\n    rdist_of_indep_eq_sum_fibre π hi m1 m2,\n    condRuzsaDist_of_copy h1 (hπ.comp h1) h2 (hπ.comp h2) m1 (hπ.comp m1) m2 (hπ.comp m2) hπ1 hπ2]\n  exact le_add_of_nonneg_right (condMutualInfo_nonneg (by measurability) (Measurable.prod_mk (hπ.comp m1) (hπ.comp m2)) _ _)\n\n/-- \\[d[X;Y]\\geq d[\\pi(X);\\pi(Y)].\\] -/\nlemma rdist_of_hom_le {Z_1 : Ω → H} {Z_2 : Ω' → H}\n    (h1 : Measurable Z_1) (h2 : Measurable Z_2) [FiniteRange Z_1] [FiniteRange Z_2] :\n    d[π ∘ Z_1; μ # π ∘ Z_2; μ'] ≤ d[Z_1; μ # Z_2; μ'] := by\n  apply le_trans _ (rdist_le_sum_fibre π h1 h2 (μ := μ) (μ' := μ'))\n  rw [le_add_iff_nonneg_right]\n  exact condRuzsaDist_nonneg h1 ((measurable_of_countable π).comp h1) h2\n    ((measurable_of_countable π).comp h2)\n\nend GeneralFibring\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G]\nvariable {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ : Measure Ω} [IsProbabilityMeasure μ]\n\n/-- The conditional Ruzsa Distance step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condRuzsaDist {Y : Fin 4 → Ω → G} (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[⟨Y 0, Y 2⟩ | Y 0 - Y 2 ; μ # ⟨Y 1, Y 3⟩ | Y 1 - Y 3 ; μ] = d[Y 0 | Y 0 - Y 2 ; μ # Y 1 | Y 1 - Y 3 ; μ] := by\n  let Y' : Fin 4 → Ω → G\n    | 0 => Y 0\n    | 1 => Y 1\n    | 2 => Y 0 - Y 2\n    | 3 => Y 1 - Y 3\n  let f : (G × G) → (G × G) := fun (g, h) ↦ (g, g - h)\n  have hf : Measurable f := measurable_of_countable _\n  have h_indep' : IndepFun (⟨Y' 0, Y' 2⟩) (⟨Y' 1, Y' 3⟩) μ :=\n    (h_indep.indepFun_prod_mk_prod_mk h_meas 0 2 1 3\n      (by decide) (by decide) (by decide) (by decide)).comp hf hf\n  have h_meas' : ∀ i, Measurable (Y' i)\n    | 0 => h_meas 0\n    | 1 => h_meas 1\n    | 2 => (h_meas 0).sub (h_meas 2)\n    | 3 => (h_meas 1).sub (h_meas 3)\n  have h' (i j : Fin 4) : ⟨Y i, Y j⟩ = ⟨Y i, Y i - (Y i - Y j)⟩ := by simp only [sub_sub_cancel]\n  rw [h' 0 2, h' 1 3]\n  exact condRuzsaDist_of_inj_map Y' h_indep' h_meas'\n    ((AddMonoidHom.fst G G).prod ((AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)))\n    (fun _ _ _ h ↦ (Prod.ext_iff.1 h).1)\n\n/-- The conditional mutual information step of `sum_of_rdist_eq` -/\nlemma sum_of_rdist_eq_step_condMutualInfo {Y : Fin 4 → Ω → G}\n  (h_meas : ∀ i, Measurable (Y i)) :\n    I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - Y 2 + Y 3;μ] := by\n  suffices : I[⟨Y 0 - Y 1, Y 2 - Y 3⟩:⟨Y 0 - Y 2, Y 1 - Y 3⟩|Y 0 - Y 1 - (Y 2 - Y 3);μ] =\n    I[Y 0 - Y 1:Y 1 - Y 3|Y 0 - Y 1 - (Y 2 - Y 3) ;μ]\n  . convert this using 2\n    abel\n  symm\n  have hm (f : G → G → G × G) {a b i j k l : Fin 4} :\n    Measurable (Function.uncurry f ∘ ⟨Y i - Y j - (Y k - Y l), Y a - Y b⟩) :=\n    (measurable_of_countable (Function.uncurry f)).comp\n    ((((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))).prod_mk\n    ((h_meas _).sub (h_meas _)))\n  have hmf : Measurable fun ω ↦ ((Y 0 - Y 1) ω, (Y 0 - Y 1) ω - (Y 0 - Y 1 - (Y 2 - Y 3)) ω) :=\n    hm (fun z x ↦ (x, x - z))\n  have hmg : Measurable fun ω ↦ ((Y 1 - Y 3) ω + (Y 0 - Y 1 - (Y 2 - Y 3)) ω, (Y 1 - Y 3) ω) :=\n    hm (fun z x ↦ (x + z, x))\n  have hmij {i j : Fin 4} : Measurable (Y i - Y j) := (h_meas _).sub (h_meas _)\n  have hm0123 {i j k l : Fin 4} : Measurable (Y i - Y j - (Y k - Y l)) :=\n    ((h_meas _).sub (h_meas _)).sub ((h_meas _).sub (h_meas _))\n  rw [← condMutualInfo_of_inj_map hmij hmij hm0123 (fun z x ↦ (x, x - z)),\n    condMutualInfo_comm hmf hmij,\n    ← condMutualInfo_of_inj_map hmij hmf hm0123 (fun z x ↦ (x + z, x)),\n    condMutualInfo_comm hmg hmf]\n  . congr 1\n    { ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n    { rw [sub_sub, add_sub_left_comm, ← sub_sub]\n      ext ω\n      { simp only [Function.comp_apply, Pi.sub_apply, add_sub_cancel'_right] }\n      { simp only [Function.comp_apply, Pi.sub_apply, sub_sub_cancel] } }\n  . exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).2\n  exact fun _ _ _ h ↦ (Prod.ext_iff.1 h).1\n\n\n/-- Let $Y_1,Y_2,Y_3$ and $Y_4$ be independent $G$-valued random variables.\n  Then\n$$d[Y_1-Y_3; Y_2-Y_4] + d[Y_1|Y_1-Y_3; Y_2|Y_2-Y_4] $$\n$$ + I[Y_1-Y_2 : Y_2 - Y_4 | Y_1-Y_2-Y_3+Y_4] = d[Y_1; Y_2] + d[Y_3; Y_4].$$\n-/\nlemma sum_of_rdist_eq (Y : Fin 4 → Ω → G) (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[Y 0; μ # Y 1; μ] + d[Y 2; μ # Y 3; μ]\n      = d[(Y 0) - (Y 2); μ # (Y 1) - (Y 3); μ]\n        + d[Y 0 | (Y 0) - (Y 2); μ # Y 1 | (Y 1) - (Y 3); μ]\n        + I[(Y 0) - (Y 1) : (Y 1) - (Y 3) | (Y 0) - (Y 1) - (Y 2) + (Y 3); μ] := by\n  let π : G × G →+ G := (AddMonoidHom.fst G G) - (AddMonoidHom.snd G G)\n  have hπ {W_1 W_2 : Ω → G} : π ∘ ⟨W_1, W_2⟩ = W_1 - W_2 := rfl\n  let Z_1 : Ω → G × G := ⟨Y 0, Y 2⟩\n  let Z_2 : Ω → G × G := ⟨Y 1, Y 3⟩\n  have hZ : Z_1 - Z_2 = ⟨Y 0 - Y 1, Y 2 - Y 3⟩ := rfl\n  have m1 : Measurable Z_1 := (h_meas 0).prod_mk (h_meas 2)\n  have m2 : Measurable Z_2 := (h_meas 1).prod_mk (h_meas 3)\n  have h_indep_0 : IndepFun (Y 0) (Y 1) μ := h_indep.indepFun (by decide)\n  have h_indep_2 : IndepFun (Y 2) (Y 3) μ := h_indep.indepFun (by decide)\n  have h_indep_Z : IndepFun Z_1 Z_2 μ := h_indep.indepFun_prod_mk_prod_mk h_meas\n    0 2 1 3 (by decide) (by decide) (by decide) (by decide)\n  have h_indep_sub : IndepFun (Y 0 - Y 1) (Y 2 - Y 3) μ :=\n    h_indep.indepFun_sub_sub h_meas 0 1 2 3 (by decide) (by decide) (by decide) (by decide)\n  have msub (i j : Fin 4) : Measurable (Y i - Y j) := (h_meas i).sub (h_meas j)\n  have h_add : d[Z_1; μ # Z_2; μ] = d[Y 0; μ # Y 1; μ] + d[Y 2; μ # Y 3; μ] := by\n    rw [h_indep_0.rdist_eq (h_meas 0) (h_meas 1), h_indep_2.rdist_eq (h_meas 2) (h_meas 3),\n      h_indep_Z.rdist_eq m1 m2, hZ,\n      (entropy_pair_eq_add (h_meas 0) (h_meas 2)).2 (h_indep.indepFun (by decide)),\n      (entropy_pair_eq_add (h_meas 1) (h_meas 3)).2 (h_indep.indepFun (by decide)),\n      (entropy_pair_eq_add (msub 0 1) (msub 2 3)).2 h_indep_sub]\n    ring_nf\n  rw [← h_add, rdist_of_indep_eq_sum_fibre π h_indep_Z m1 m2]\n  simp only [hπ, hZ]\n  rw [sum_of_rdist_eq_step_condRuzsaDist h_indep h_meas,\n    sum_of_rdist_eq_step_condMutualInfo h_meas]\n\n","proof":":= by\n  simpa using sum_of_rdist_eq Y h_indep h_meas","declId":"PFR.Fibring.190_0.yPsb0LSqh9ovyrz","decl":"/-- Let $Y_1,Y_2,Y_3$ and $Y_4$ be independent $G$-valued random variables.\n  Then\n$$d[Y_1+Y_3; Y_2+Y_4] + d[Y_1|Y_1+Y_3; Y_2|Y_2+Y_4] $$\n$$ + I[Y_1+Y_2 : Y_2 + Y_4 | Y_1+Y_2+Y_3+Y_4] = d[Y_1; Y_2] + d[Y_3; Y_4].$$\n-/\nlemma sum_of_rdist_eq_char_2\n  [ElementaryAddCommGroup G 2] (Y : Fin 4 → Ω → G) (h_indep: iIndepFun (fun _ : Fin 4 ↦ hG) Y μ)\n  (h_meas : ∀ i, Measurable (Y i)) :\n    d[Y 0; μ # Y 1; μ] + d[Y 2; μ # Y 3; μ]\n      = d[(Y 0) + (Y 2); μ # (Y 1) + (Y 3); μ]\n        + d[Y 0 | (Y 0) + (Y 2); μ # Y 1 | (Y 1) + (Y 3); μ]\n        + I[(Y 0) + (Y 1) : (Y 1) + (Y 3) | (Y 0) + (Y 1) + (Y 2) + (Y 3); μ] "}
