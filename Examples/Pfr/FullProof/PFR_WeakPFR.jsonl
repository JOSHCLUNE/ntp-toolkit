{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\n","proof":":= ∃ x : G, A = x +ᵥ B","declId":"PFR.WeakPFR.31_0.kVNJP4iHuXEJCsB","decl":"def IsShift (A B : Set G) : Prop "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\n","proof":":= by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]","declId":"PFR.WeakPFR.33_0.kVNJP4iHuXEJCsB","decl":"lemma IsShift.sub_self_congr : IsShift A B → A - A = B - B "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\n","proof":":= by rintro ⟨x, rfl⟩; simp","declId":"PFR.WeakPFR.36_0.kVNJP4iHuXEJCsB","decl":"lemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n","proof":":= AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤","declId":"PFR.WeakPFR.38_0.kVNJP4iHuXEJCsB","decl":"/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n","proof":":= by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]","declId":"PFR.WeakPFR.42_0.kVNJP4iHuXEJCsB","decl":"/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\n","proof":":= by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']","declId":"PFR.WeakPFR.76_0.kVNJP4iHuXEJCsB","decl":"variable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n","proof":":= by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]","declId":"PFR.WeakPFR.81_0.kVNJP4iHuXEJCsB","decl":"/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n","proof":":= by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this","declId":"PFR.WeakPFR.203_0.kVNJP4iHuXEJCsB","decl":"/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\n","proof":":=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩","declId":"PFR.WeakPFR.221_0.kVNJP4iHuXEJCsB","decl":"instance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n","proof":":= by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩","declId":"PFR.WeakPFR.232_0.kVNJP4iHuXEJCsB","decl":"/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\n","proof":":= by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']","declId":"PFR.WeakPFR.282_0.kVNJP4iHuXEJCsB","decl":"variable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n","proof":":=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY","declId":"PFR.WeakPFR.286_0.kVNJP4iHuXEJCsB","decl":"lemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n","proof":":= by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩","declId":"PFR.WeakPFR.294_0.kVNJP4iHuXEJCsB","decl":"/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\n","proof":":= by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩","declId":"PFR.WeakPFR.293_0.kVNJP4iHuXEJCsB","decl":"set_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n","proof":":= by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith","declId":"PFR.WeakPFR.398_0.kVNJP4iHuXEJCsB","decl":"/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\n","proof":":= by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity","declId":"PFR.WeakPFR.420_0.kVNJP4iHuXEJCsB","decl":"lemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\n","proof":":= by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl","declId":"PFR.WeakPFR.424_0.kVNJP4iHuXEJCsB","decl":"lemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n","proof":":= by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]","declId":"PFR.WeakPFR.438_0.kVNJP4iHuXEJCsB","decl":"/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\n","proof":":= by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩","declId":"PFR.WeakPFR.602_0.kVNJP4iHuXEJCsB","decl":"lemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n","proof":":= Nat.find (exists_coset_cover A)","declId":"PFR.WeakPFR.608_0.kVNJP4iHuXEJCsB","decl":"/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\n","proof":":= by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩","declId":"PFR.WeakPFR.611_0.kVNJP4iHuXEJCsB","decl":"lemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\n","proof":":= by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S","declId":"PFR.WeakPFR.617_0.kVNJP4iHuXEJCsB","decl":"lemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n","proof":":= α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this","declId":"PFR.WeakPFR.629_0.kVNJP4iHuXEJCsB","decl":"/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n","proof":":= by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith","declId":"PFR.WeakPFR.647_0.kVNJP4iHuXEJCsB","decl":"/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n","proof":":= G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩","declId":"PFR.WeakPFR.656_0.kVNJP4iHuXEJCsB","decl":"/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n","proof":":= G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1","declId":"PFR.WeakPFR.742_0.kVNJP4iHuXEJCsB","decl":"/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\n","proof":":= by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption","declId":"PFR.WeakPFR.767_0.kVNJP4iHuXEJCsB","decl":"lemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n","proof":":= by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this","declId":"PFR.WeakPFR.778_0.kVNJP4iHuXEJCsB","decl":"/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n","proof":":=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]","declId":"PFR.WeakPFR.955_0.kVNJP4iHuXEJCsB","decl":"/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n","proof":":= AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤","declId":"PFR.WeakPFR.961_0.kVNJP4iHuXEJCsB","decl":"/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤\n\n\n","proof":":= by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with ⟨ S, v, hrank, hshift ⟩\n  change FiniteDimensional.finrank ℤ S = dimension A at hrank\n  rw [← hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with ⟨ b, ⟨ hb, hb'⟩ ⟩\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [← hb']\n  abel","declId":"PFR.WeakPFR.965_0.kVNJP4iHuXEJCsB","decl":"/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H ↦ (a:G) + x) '' A) ≤ dimension A "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H ↦ (a:G) + x) '' A) ≤ dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with ⟨ S, v, hrank, hshift ⟩\n  change FiniteDimensional.finrank ℤ S = dimension A at hrank\n  rw [← hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with ⟨ b, ⟨ hb, hb'⟩ ⟩\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [← hb']\n  abel\n\n","proof":":= by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with ⟨A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq⟩\n  rcases hA with ⟨ x, hA ⟩\n  set f : G' → G := fun a ↦ (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  rcases hB with ⟨ y, hB ⟩\n  set g : G' → G := fun a ↦ (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : dᵤ[A # B] = dᵤ[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (φ := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n        have : x + z + -x ∈ G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro ⟨ h, ha ⟩\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n      have : y + z + -y ∈ G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro ⟨ h, ha ⟩\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine ⟨ ?_, ?_, ?_, ?_, ?_, ?_ ⟩\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  · exact dimension_of_shift B'' y","declId":"PFR.WeakPFR.984_0.kVNJP4iHuXEJCsB","decl":"lemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H ↦ (a:G) + x) '' A) ≤ dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with ⟨ S, v, hrank, hshift ⟩\n  change FiniteDimensional.finrank ℤ S = dimension A at hrank\n  rw [← hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with ⟨ b, ⟨ hb, hb'⟩ ⟩\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [← hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with ⟨A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq⟩\n  rcases hA with ⟨ x, hA ⟩\n  set f : G' → G := fun a ↦ (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  rcases hB with ⟨ y, hB ⟩\n  set g : G' → G := fun a ↦ (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : dᵤ[A # B] = dᵤ[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (φ := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n        have : x + z + -x ∈ G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro ⟨ h, ha ⟩\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n      have : y + z + -y ∈ G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro ⟨ h, ha ⟩\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine ⟨ ?_, ?_, ?_, ?_, ?_, ?_ ⟩\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  · exact dimension_of_shift B'' y\n\n","proof":":= by\n  let P : ℕ → Prop := fun M ↦ (∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M), WeakPFRAsymmConclusion A B)\n  suffices : ∀ M, (∀ M', M' < M → P M') → P M\n  . set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) ≤ M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G ‹_› ‹_› ‹_› ‹_› _ ‹_› A B ‹_› ‹_› ‹_› ‹_› hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices : ∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M) (_hnot: NotInCoset A B), WeakPFRAsymmConclusion A B\n  . intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n\n    obtain ⟨ G', A', B', hAA', hBB', hnot' ⟩ := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite ℤ G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free ℤ G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis ℤ G) (AddSubgroup.toIntSubmodule G') with ⟨ n, ⟨ b ⟩ ⟩\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty ∧ Finite A' := by\n      have := Nat.card_pos (α := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    have hB'_nonfin : B'.Nonempty ∧ Finite B' := by\n      have := Nat.card_pos (α := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    obtain ⟨ hA'_non, hA'_fin ⟩ := hA'_nonfin\n    obtain ⟨ hB'_non, hB'_fin ⟩ := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with ⟨ N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard⟩\n  have hAxA : Ax ⊆ A := by rw [hAx]; simp\n  have hByB : By ⊆ B := by rw [hBy]; simp\n  have hA_pos : (0 : ℝ) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : ℝ) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with ⟨ A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq ⟩\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : ℝ) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : ℝ) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : ℝ) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : ℝ) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : ℝ) ≤ (Nat.card A : ℝ) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : ℝ) ≤ (Nat.card B : ℝ) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine ⟨ hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ ⟩\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine ⟨ Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ ⟩\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = ⊤ := by\n    have : (A-A) ∪ (B-B) ⊆ N := by\n      rw [← hAx_eq, ← hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with ⟨ a, ⟨ -, ha⟩, a', ⟨-, ha'⟩, haa' ⟩ | ⟨ b, ⟨ -, hb⟩, b', ⟨ -,hb'⟩, hbb' ⟩\n      . rw [← haa']; simp [ha, ha']\n      rw [← hbb']; simp [hb, hb']\n    rw [← AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G ⧸ N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [← le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact ⟨ dimension_le_rank A, dimension_le_rank B ⟩","declId":"PFR.WeakPFR.1058_0.kVNJP4iHuXEJCsB","decl":"/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\nlemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B  "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H ↦ (a:G) + x) '' A) ≤ dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with ⟨ S, v, hrank, hshift ⟩\n  change FiniteDimensional.finrank ℤ S = dimension A at hrank\n  rw [← hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with ⟨ b, ⟨ hb, hb'⟩ ⟩\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [← hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with ⟨A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq⟩\n  rcases hA with ⟨ x, hA ⟩\n  set f : G' → G := fun a ↦ (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  rcases hB with ⟨ y, hB ⟩\n  set g : G' → G := fun a ↦ (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : dᵤ[A # B] = dᵤ[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (φ := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n        have : x + z + -x ∈ G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro ⟨ h, ha ⟩\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n      have : y + z + -y ∈ G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro ⟨ h, ha ⟩\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine ⟨ ?_, ?_, ?_, ?_, ?_, ?_ ⟩\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  · exact dimension_of_shift B'' y\n\n/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\nlemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B  := by\n  let P : ℕ → Prop := fun M ↦ (∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M), WeakPFRAsymmConclusion A B)\n  suffices : ∀ M, (∀ M', M' < M → P M') → P M\n  . set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) ≤ M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G ‹_› ‹_› ‹_› ‹_› _ ‹_› A B ‹_› ‹_› ‹_› ‹_› hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices : ∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M) (_hnot: NotInCoset A B), WeakPFRAsymmConclusion A B\n  . intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n\n    obtain ⟨ G', A', B', hAA', hBB', hnot' ⟩ := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite ℤ G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free ℤ G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis ℤ G) (AddSubgroup.toIntSubmodule G') with ⟨ n, ⟨ b ⟩ ⟩\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty ∧ Finite A' := by\n      have := Nat.card_pos (α := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    have hB'_nonfin : B'.Nonempty ∧ Finite B' := by\n      have := Nat.card_pos (α := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    obtain ⟨ hA'_non, hA'_fin ⟩ := hA'_nonfin\n    obtain ⟨ hB'_non, hB'_fin ⟩ := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with ⟨ N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard⟩\n  have hAxA : Ax ⊆ A := by rw [hAx]; simp\n  have hByB : By ⊆ B := by rw [hBy]; simp\n  have hA_pos : (0 : ℝ) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : ℝ) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with ⟨ A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq ⟩\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : ℝ) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : ℝ) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : ℝ) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : ℝ) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : ℝ) ≤ (Nat.card A : ℝ) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : ℝ) ≤ (Nat.card B : ℝ) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine ⟨ hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ ⟩\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine ⟨ Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ ⟩\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = ⊤ := by\n    have : (A-A) ∪ (B-B) ⊆ N := by\n      rw [← hAx_eq, ← hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with ⟨ a, ⟨ -, ha⟩, a', ⟨-, ha'⟩, haa' ⟩ | ⟨ b, ⟨ -, hb⟩, b', ⟨ -,hb'⟩, hbb' ⟩\n      . rw [← haa']; simp [ha, ha']\n      rw [← hbb']; simp [hb, hb']\n    rw [← AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G ⧸ N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [← le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact ⟨ dimension_le_rank A, dimension_le_rank B ⟩\n\n","proof":":= by\n  rcases weak_PFR_asymm A A hA hA with ⟨A', A'', hA', hA'', hA'nonempty, hA''nonempty, hcard, hdim⟩\n\n  have : ∃ B : Set G, B ⊆ A ∧ (Nat.card B) ≥ (Nat.card A') ∧ (Nat.card B) ≥ (Nat.card A'') ∧ (dimension B) ≤\nmax (dimension A') (dimension A'') := by\n    rcases lt_or_ge (Nat.card A') (Nat.card A'') with h | h\n    . use A''\n      exact ⟨hA'', by linarith, by linarith, le_max_right _ _⟩\n    use A'\n    exact ⟨hA', by linarith, by linarith, le_max_left _ _⟩\n\n  rcases this with ⟨B, hB, hBcard, hBcard', hBdim⟩\n  use B\n  have hApos : Nat.card A > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    exact ⟨hA.to_subtype, inferInstance⟩\n  have hA'pos : Nat.card A' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine ⟨ hA'nonempty.to_subtype, Finite.Set.subset _ hA' ⟩\n  have hA''pos : Nat.card A'' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine ⟨ hA''nonempty.to_subtype, Finite.Set.subset _ hA'' ⟩\n  have hBpos : Nat.card B > 0 := by linarith\n\n  refine ⟨hB, ?_, ?_⟩\n  . have := calc 2 * log ((Nat.card A) / (Nat.card B))\n      _ = log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card B) * (Nat.card B)) ) := by\n        convert (log_pow (((Nat.card A) : ℝ)/(Nat.card B)) 2).symm\n        field_simp\n        rw [← pow_two, ← pow_two]\n      _ ≤ log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card A') * (Nat.card A'')) ) := by\n        apply log_le_log\n        . positivity\n        gcongr\n      _ ≤ 34 * dᵤ[A # A] := hcard\n      _ ≤ 34 * log K := mul_le_mul_of_nonneg_left hdist (by linarith)\n      _ = 2 * (17 * log K) := by ring\n      _ = 2 * log (K^17) := by\n        congr\n        convert (log_pow K 17).symm\n    rw [mul_le_mul_left (by norm_num), log_le_log_iff (by positivity) (by positivity), div_le_iff (by positivity), <- mul_inv_le_iff (by positivity), <-ge_iff_le, mul_comm] at this\n    convert this using 2\n    convert zpow_neg K 17 using 1\n    norm_cast\n  calc (dimension B : ℝ)\n    _ ≤ (((max (dimension A') (dimension A'')) : ℕ) : ℝ) := by norm_cast\n    _ ≤ (40 / log 2) * dᵤ[A # A] := hdim\n    _ ≤ (40 / log 2) * log K := mul_le_mul_of_nonneg_left hdist (by positivity)","declId":"PFR.WeakPFR.1170_0.kVNJP4iHuXEJCsB","decl":"/-- If $A\\subseteq \\mathbb{Z}^d$ is a finite non-empty set with $d[U_A;U_A]\\leq \\log K$ then there exists a non-empty $A'\\subseteq A$ such that\n$\\lvert A'\\rvert\\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A'\\leq \\frac{40}{\\log 2} \\log K$. -/\nlemma weak_PFR {A : Set G} [Finite A] {K : ℝ} (hA : A.Nonempty) (hK: 0 < K) (hdist: dᵤ[A # A] ≤ log K):\n    ∃ A' : Set G, A' ⊆ A ∧ (Nat.card A') ≥ K^(-17 : ℝ) * (Nat.card A)\n    ∧ (dimension A') ≤ (40 / log 2) * log K "}
{"srcUpToDecl":"import Mathlib.Algebra.Order.Ring.Defs\nimport Mathlib.Algebra.Quotient\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.GroupTheory.Torsion\nimport Mathlib.LinearAlgebra.FreeModule.PID\nimport PFR.Mathlib.Data.Set.Pointwise.SMul\nimport PFR.EntropyPFR\nimport PFR.ImprovedPFR\nimport PFR.ForMathlib.Entropy.RuzsaSetDist\nimport PFR.Mathlib.GroupTheory.Torsion\n\n/-!\n# Weak PFR over the integers\n\nHere we use the entropic form of PFR to deduce a weak form of PFR over the integers.\n\n## Main statement\n\n* `weak_PFR_int`: Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A+A\\rvert\\leq K\\lvert A\\rvert$.\n  There exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$ and\n  $\\dim A' \\leq (40/\\log 2)\\log K$.\n\n-/\n\nsection AddCommGroup\nvariable {G : Type*} [AddCommGroup G] {A B : Set G}\n\nopen Set\nopen scoped Pointwise\n\ndef IsShift (A B : Set G) : Prop := ∃ x : G, A = x +ᵥ B\n\nlemma IsShift.sub_self_congr : IsShift A B → A - A = B - B := by\n  rintro ⟨x, rfl⟩; simp [vadd_sub_vadd_comm, singleton_zero]\n\nlemma IsShift.card_congr : IsShift A B → Nat.card A = Nat.card B := by rintro ⟨x, rfl⟩; simp\n\n/-- The property of two sets A, B of a group G not being contained in cosets of the same proper\nsubgroup -/\ndef NotInCoset (A B : Set G) : Prop := AddSubgroup.closure ((A - A) ∪ (B - B)) = ⊤\n\n/-- Without loss of generality, one can move (up to translation and embedding) any pair A, B of non-empty sets into a subgroup where they are not in a coset. -/\nlemma wlog_notInCoset (hA : A.Nonempty) (hB : B.Nonempty) :\n    ∃ (G' : AddSubgroup G) (A' B' : Set G'), IsShift A A' ∧ IsShift B B' ∧ NotInCoset A' B' := by\n  obtain ⟨x, hx⟩ := hA\n  obtain ⟨y, hy⟩ := hB\n  set G' := AddSubgroup.closure ((A - A) ∪ (B - B))\n  set A' : Set G' := (↑) ⁻¹' ((-x) +ᵥ A)\n  set B' : Set G' := (↑) ⁻¹' ((-y) +ᵥ B)\n  have hxA : -x +ᵥ A ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hx).trans $ (subset_union_left ..).trans\n      AddSubgroup.subset_closure\n  have hyB : -y +ᵥ B ⊆ range ((↑) : G' → G)\n  · simp only [← singleton_add', ← neg_singleton, neg_add_eq_sub, SetLike.coe_sort_coe,\n      Subtype.range_coe_subtype, SetLike.mem_coe]\n    exact (sub_subset_sub_left $ singleton_subset_iff.2 hy).trans $ (subset_union_right ..).trans\n      AddSubgroup.subset_closure\n  have hA : IsShift A A' := ⟨x, by rw [Set.image_preimage_eq_of_subset hxA, vadd_neg_vadd]⟩\n  have hB : IsShift B B' := ⟨y, by rw [Set.image_preimage_eq_of_subset hyB, vadd_neg_vadd]⟩\n  refine ⟨G', A', B', hA, hB, ?_⟩\n  unfold NotInCoset\n  convert AddSubgroup.closure_preimage_eq_top ((A - A) ∪ (B - B))\n  simp_rw [preimage_union, hA.sub_self_congr, hB.sub_self_congr]\n  rw [preimage_sub, preimage_sub]\n  simp [preimage_image_preimage]\n  all_goals apply_rules [Subtype.coe_injective, (image_preimage_subset ..).trans, hxA, hyB]\n\nend AddCommGroup\n\nsection Torsion\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [Countable G] {Ω Ω' : Type u} [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  (μ : Measure Ω := by volume_tac) (μ': Measure Ω' := by volume_tac)\n  [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\n/-- If $G$ is torsion-free and $X,Y$ are $G$-valued random variables then $d[X;2Y]\\leq 5d[X;Y]$.  -/\nlemma torsion_free_doubling [FiniteRange X] [FiniteRange Y]\n    (hX : Measurable X) (hY : Measurable Y) (hG : AddMonoid.IsTorsionFree G) :\n    d[X ; μ # (Y + Y) ; μ'] ≤ 5 * d[X; μ # Y ; μ'] := by\n  obtain ⟨A, mA, μA, X', Y'₁, Y'₂, hμA, h_indep, hX'_meas, hY'₁_meas, hY'₂_meas, hX'_ident,\n    hY'₁_ident, hY'₂_ident, _, _, _⟩ := independent_copies3_nondep_finiteRange hX hY hY μ μ' μ'\n  have h_meas (i : Fin 3) : Measurable (![X', Y'₁, Y'₂] i) := by fin_cases i <;> assumption\n  haveI : NoZeroSMulDivisors ℕ G := hG.noZeroNsmulDivisors\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] = H[⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨x, y₁, y₂⟩ ↦ (x, y₁ - y₂, x - 2 • y₁)\n      show H[f ∘ ⟨X', ⟨Y'₁, Y'₂⟩⟩ ; μA] = _\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hX'_meas <| Measurable.prod hY'₁_meas hY'₂_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun X' (prod Y'₁ Y'₂) μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 1 2 0 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hX'_meas (by exact Measurable.prod hY'₁_meas hY'₂_meas),\n        IndepFun.entropy_pair_eq_add hY'₁_meas hY'₂_meas (h_indep.indepFun (show 1 ≠ 2 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, two_mul]\n  have : H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[X ; μ] + H[Y ; μ'] := calc\n    H[⟨X', X' - 2 • Y'₁⟩ ; μA] = H[⟨X', Y'₁⟩ ; μA] := by\n      let f : G × G → G × G := fun ⟨x, y₁⟩ ↦ (x, x - 2 • y₁)\n      show H[f ∘ ⟨X', Y'₁⟩ ; μA] = _\n      apply entropy_comp_of_injective μA (by exact Measurable.prod hX'_meas hY'₁_meas) f\n      exact fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all [smul_right_inj]\n    _ = H[X ; μ] + H[Y ; μ'] := by\n      rw [IndepFun.entropy_pair_eq_add hX'_meas hY'₁_meas (h_indep.indepFun (show 0 ≠ 1 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq]\n  let f : G × G → G × G := fun ⟨x, y⟩ ↦ (x, y - x)\n  have hf : f.Injective := fun ⟨_, _⟩ _ h ↦ by simp at h; obtain ⟨_, _⟩ := h; simp_all\n  have : H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] := calc\n    H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] = H[f ∘ ⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      show _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂ - (Y'₁ - Y'₂)⟩ ; μA]\n      rw [sub_sub_sub_cancel_right, ← sub_add_eq_sub_sub, two_nsmul]\n    _ = H[⟨Y'₁ - Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n      refine entropy_comp_of_injective μA (Measurable.prod ?_ ?_) f hf\n      · exact Measurable.sub hY'₁_meas hY'₂_meas\n      · exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] :=\n      entropy_pair_le_add (hY'₁_meas.sub' hY'₂_meas) (hX'_meas.sub' hY'₁_meas |>.sub' hY'₂_meas) μA\n  have : H[⟨X', ⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩⟩ ; μA] + H[X' - 2 • Y'₁ ; μA] ≤\n      H[⟨X', X' - 2 • Y'₁⟩ ; μA] + H[⟨Y'₁ - Y'₂, X' - 2 • Y'₁⟩ ; μA] := by\n    haveI : FiniteRange (Y'₁ - Y'₂) := FiniteRange.sub Y'₁ Y'₂\n    haveI : FiniteRange (2 • Y'₁) := by show FiniteRange ((fun x ↦ 2 • x) ∘ Y'₁); infer_instance\n    apply entropy_triple_add_entropy_le μA hX'_meas (Measurable.sub hY'₁_meas hY'₂_meas)\n    exact Measurable.sub' hX'_meas <| Measurable.const_smul hY'₁_meas 2\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[X ; μ] + 2 * H[Y ; μ'] := calc\n    H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] := by\n      let f : G × G × G → G × G × G := fun ⟨y₁, y₂, x⟩ ↦ (y₁, y₂, x - y₁ - y₂)\n      show H[f ∘ ⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA] = H[⟨Y'₁, ⟨Y'₂, X'⟩⟩ ; μA]\n      refine entropy_comp_of_injective μA ?_ f ?_\n      · exact Measurable.prod hY'₁_meas <| Measurable.prod hY'₂_meas hX'_meas\n      · exact fun ⟨_, _, _⟩ _ h ↦ by simp at h; obtain ⟨_, _, _⟩ := h; simp_all\n    _ = H[X ; μ] + 2 * H[Y ; μ'] := by\n      have : IndepFun Y'₁ (prod Y'₂ X') μA := Indep.symm <|\n        h_indep.indepFun_prod_mk h_meas 2 0 1 (by decide) (by decide)\n      rw [this.entropy_pair_eq_add hY'₁_meas (by exact Measurable.prod hY'₂_meas hX'_meas),\n        IndepFun.entropy_pair_eq_add hY'₂_meas hX'_meas (h_indep.indepFun (show 2 ≠ 0 by decide)),\n        hX'_ident.entropy_eq, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq]\n      group\n  have : H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₂ ; μA] := calc\n    H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₁, X' - Y'₂⟩ ; μA] := by rw [sub_right_comm] ; rfl\n    _ = H[⟨Y'₁, X' - Y'₂⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₁_meas <| Measurable.sub hX'_meas hY'₂_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₂ ; μA] := by\n      haveI : FiniteRange (X' - Y'₂) := FiniteRange.sub X' Y'₂\n      convert IndepFun.entropy_pair_eq_add hY'₁_meas (hX'_meas.sub hY'₂_meas)\n        <| h_indep.indepFun_sub_right h_meas 1 0 2 (by decide) (by decide)\n      exact hY'₁_ident.entropy_eq.symm\n  have : H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[Y ; μ'] + H[X' - Y'₁ ; μA] := calc\n    H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] = H[f ∘ ⟨Y'₂, X' - Y'₁⟩ ; μA] := rfl\n    _ = H[⟨Y'₂, X' - Y'₁⟩ ; μA] := entropy_comp_of_injective μA\n      (by exact Measurable.prod hY'₂_meas <| Measurable.sub hX'_meas hY'₁_meas) f hf\n    _ = H[Y ; μ'] + H[X' - Y'₁ ; μA] := by\n      haveI : FiniteRange (X' - Y'₁) := FiniteRange.sub X' Y'₁\n      convert IndepFun.entropy_pair_eq_add hY'₂_meas (hX'_meas.sub hY'₁_meas)\n        <| h_indep.indepFun_sub_right h_meas 2 0 1 (by decide) (by decide)\n      exact hY'₂_ident.entropy_eq.symm\n  have : H[⟨Y'₁, ⟨Y'₂, X' - Y'₁ - Y'₂⟩⟩ ; μA] + H[X' - Y'₁ - Y'₂ ; μA] ≤\n      H[⟨Y'₁, X' - Y'₁ - Y'₂⟩ ; μA] + H[⟨Y'₂, X' - Y'₁ - Y'₂⟩ ; μA] := by\n    apply entropy_triple_add_entropy_le μA hY'₁_meas hY'₂_meas\n    exact Measurable.sub (Measurable.sub hX'_meas hY'₁_meas) hY'₂_meas\n  have : H[X' - Y'₁ - Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := calc\n    H[X' - Y'₁ - Y'₂ ; μA] ≤ H[X' - Y'₁ ; μA] + H[X' - Y'₂ ; μA] - H[X ; μ] := by linarith\n    _ = 2 * d[X ; μ # Y ; μ'] + H[Y ; μ'] := by\n      nth_rw 1 [two_mul, ← hX'_ident.rdist_eq hY'₁_ident, ← hX'_ident.rdist_eq hY'₂_ident]\n      have h1 : d[X' ; μA # Y'₁ ; μA] = H[X' - Y'₁ ; μA] - H[X' ; μA] / 2 - H[Y'₁ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 1 by decide)).rdist_eq hX'_meas hY'₁_meas\n      have h2 : d[X' ; μA # Y'₂ ; μA] = H[X' - Y'₂ ; μA] - H[X' ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 0 ≠ 2 by decide)).rdist_eq hX'_meas hY'₂_meas\n      rw [h1, h2, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, hX'_ident.entropy_eq]\n      group\n  have : d[X ; μ # 2 • Y ; μ'] ≤\n      d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := calc\n    d[X ; μ # 2 • Y ; μ'] = H[X' - 2 • Y'₁ ; μA] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by\n      have h2Y_ident : IdentDistrib (2 • Y'₁) (2 • Y) (μ := μA) (ν := μ') := by\n        convert hY'₁_ident.comp <| measurable_discrete <| fun g ↦ 2 • g\n      have h2Y_indep : IndepFun X' (2 • Y'₁) (μ := μA) := by\n        convert (h_indep.indepFun (show 0 ≠ 1 by decide)).comp measurable_id\n          (measurable_const_smul 2)\n      rw [← hX'_ident.rdist_eq h2Y_ident,\n        h2Y_indep.rdist_eq hX'_meas <| Measurable.const_smul hY'₁_meas 2,\n        hX'_ident.entropy_eq, h2Y_ident.entropy_eq]\n    _ ≤ H[Y'₁ - Y'₂ ; μA] + 2 * d[X ; μ # Y ; μ'] - H[X ; μ] / 2 - H[2 • Y ; μ'] / 2 := by linarith\n    _ = d[Y'₁ ; μA # Y'₂ ; μA] + (H[Y ; μ'] - H[X ; μ]) / 2 + 2 * d[X ; μ # Y ; μ'] := by\n      have H2Y : H[2 • Y ; μ'] = H[Y ; μ'] := by\n        let f (g : G) := 2 • g\n        exact entropy_comp_of_injective μ' hY f (fun _ _ ↦ by simp [smul_right_inj])\n      have : d[Y'₁ ; μA # Y'₂ ; μA] = H[Y'₁ - Y'₂ ; μA] - H[Y'₁ ; μA] / 2 - H[Y'₂ ; μA] / 2 :=\n        (h_indep.indepFun (show 1 ≠ 2 by decide)).rdist_eq hY'₁_meas hY'₂_meas\n      rw [this, hY'₁_ident.entropy_eq, hY'₂_ident.entropy_eq, H2Y]\n      group\n  have : d[Y'₁ ; μA # Y'₂ ; μA] ≤ 2 * d[X ; μ # Y ; μ'] := by\n    rw [two_mul]\n    convert rdist_triangle hY'₁_meas hX'_meas hY'₂_meas (μ := μA) (μ' := μA) (μ'' := μA)\n    · exact rdist_symm.trans (hY'₁_ident.rdist_eq hX'_ident).symm\n    · exact (hX'_ident.rdist_eq hY'₂_ident).symm\n  rw [← two_nsmul]\n  linarith [abs_le.mp <| diff_ent_le_rdist hX hY (μ := μ) (μ' := μ')]\n\n/-- If $G$ is a torsion-free group and $X,Y$ are $G$-valued random variables and\n$\\phi : G\\to \\mathbb{F}_2^d$ is a homomorphism then\n\\[\\mathbb{H}(\\phi(X))\\leq 10d[X;Y].\\] -/\nlemma torsion_dist_shrinking {H : Type u} [FiniteRange X] [FiniteRange Y] (hX : Measurable X)\n  (hY : Measurable Y) [AddCommGroup H] [ElementaryAddCommGroup H 2]\n  [MeasurableSpace H] [MeasurableSingletonClass H] [Countable H]\n  (hG : AddMonoid.IsTorsionFree G) (φ : G →+ H) :\n  H[φ ∘ X ; μ] ≤ 10 * d[X; μ # Y ; μ'] := by\n  have :=\n    calc d[φ ∘ X ; μ # φ ∘ (Y + Y); μ'] ≤ d[X; μ # (Y + Y) ; μ'] := rdist_of_hom_le φ hX (Measurable.add hY hY)\n    _ ≤ 5 * d[X; μ # Y ; μ'] := torsion_free_doubling X Y μ μ' hX hY hG\n  have eq_zero : φ ∘ (Y + Y) = fun _ ↦ 0 := by ext x ; simp only [Function.comp_apply, Pi.add_apply,\n    map_add, ElementaryAddCommGroup.add_self]\n  rwa [eq_zero, rdist_zero_eq_half_ent, div_le_iff zero_lt_two, mul_assoc, mul_comm _ 2, ←mul_assoc,\n    show (5*2 : ℝ) = 10 by norm_num] at this\n\nend Torsion\n\ninstance {G : Type u} [AddCommGroup G] [Fintype G] [MeasurableSpace G] [MeasurableSingletonClass G] (H : AddSubgroup G)\n    : MeasurableSingletonClass (G ⧸ H) :=\n  ⟨λ _ ↦ by { rw [measurableSet_quotient]; simp [measurableSet_discrete] }⟩\n\nsection F2_projection\n\nopen Real ProbabilityTheory MeasureTheory\n\nvariable {G : Type u} [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n[MeasurableSingletonClass G] {Ω Ω' : Type*}\n\n/-- Let $G=\\mathbb{F}_2^n$ and $X,Y$ be $G$-valued random variables such that\n\\[\\mathbb{H}(X)+\\mathbb{H}(Y)> (20/\\alpha) d[X;Y],\\]\nfor some $\\alpha > 0$.\nThere is a non-trivial subgroup $H\\leq G$ such that\n\\[\\log \\lvert H\\rvert <(1+\\alpha)/2 (\\mathbb{H}(X)+\\mathbb{H}(Y))\\] and\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))< \\alpha (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nwhere $\\psi:G\\to G/H$ is the natural projection homomorphism.\n-/\nlemma app_ent_PFR' [MeasureSpace Ω] [MeasureSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n  [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n  {α : ℝ} (hent : 20 * d[X # Y] < α * (H[X] + H[Y])) (hX : Measurable X) (hY : Measurable Y) :\n  ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X] + H[Y]) ∧\n  H[(QuotientAddGroup.mk' H) ∘ X] + H[(QuotientAddGroup.mk' H) ∘ Y] < α * (H[X] + H[Y]) := by\n  let p : refPackage Ω Ω' G := {\n    X₀₁ := X\n    X₀₂ := Y\n    hmeas1 := hX\n    hmeas2 := hY\n    η := 1/8\n    hη := by norm_num\n    hη' := by norm_num }\n  obtain ⟨H, Ω'', hΩ'', U, _, hUmeas, hUunif, ineq⟩ := entropic_PFR_conjecture_improv p rfl\n  let ψ := (QuotientAddGroup.mk' H)\n  use H\n  haveI : Finite H := Subtype.finite\n  -- Note that  H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y]\n  have ent_le : H[ψ ∘ X] + H[ψ ∘ Y] ≤ 20 * d[X # Y] := calc\n    H[ψ ∘ X] + H[ψ ∘ Y] ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · exact ent_of_proj_le hX hUmeas hUunif\n      · exact ent_of_proj_le hY hUmeas hUunif\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- Note that (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y]\n  have log_sub_le : (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) ≤ 20 * d[X # Y] := calc\n    (log (Nat.card H) - H[X]) + (log (Nat.card H) - H[Y]) =\n      (H[U] - H[X]) + (H[U] - H[Y]) := by\n        rw [IsUniform.entropy_eq' hUunif hUmeas, SetLike.coe_sort_coe]\n    _ ≤ |(H[U] - H[X])| + |(H[U] - H[Y])| := by gcongr <;> exact le_abs_self _\n    _ ≤ 2 * d[X # U] + 2 * d[Y # U] := by\n      gcongr\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hX\n      · rw [rdist_symm]; exact diff_ent_le_rdist hUmeas hY\n    _ = 2 * (d[X # U] + d[Y # U]) := by ring\n    _ ≤ 2 * (10 * d[X # Y]) := by gcongr\n    _ = 20 * d[X # Y] := by ring\n  -- then the conclusion follows from the assumption `hent` and basic inequality manipulations\n  exact ⟨by linarith, by linarith⟩\n\nvariable [MeasurableSpace Ω] [MeasurableSpace Ω'] (X : Ω → G) (Y : Ω' → G)\n(μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac)\n[IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n\nlemma app_ent_PFR (α : ℝ) (hent: 20 * d[X;μ # Y;μ'] < α * (H[X; μ] + H[Y; μ'])) (hX : Measurable X)\n    (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) < (1 + α) / 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ']\n      < α * (H[ X; μ] + H[Y; μ']) :=\n  @app_ent_PFR' _ _ _ _ _ _ _ _ (MeasureSpace.mk μ) (MeasureSpace.mk μ') _ _ _ _ α hent hX hY\n\nset_option maxHeartbeats 300000 in\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables and $\\alpha < 1$ then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq (1 + α) / (2 * (1 - α)) * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 20/\\alpha * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection'\n    (α : ℝ) (hX : Measurable X) (hY : Measurable Y) (αpos : 0 < α) (αone : α < 1) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (H[X ; μ] + H[Y ; μ']) ∧\n    α * (H[(QuotientAddGroup.mk' H) ∘ X ; μ] + H[(QuotientAddGroup.mk' H) ∘ Y ; μ']) ≤\n      20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] := by\n  let S := { H : AddSubgroup G | (∃ (c : ℝ), 0 ≤ c ∧\n      log (Nat.card H) ≤ (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      c * (H[X; μ] + H[Y;μ'])) ∧\n    20 * d[(QuotientAddGroup.mk' H) ∘ X ; μ # (QuotientAddGroup.mk' H) ∘ Y ; μ'] <\n      α * (H[ (QuotientAddGroup.mk' H) ∘ X; μ ] + H[ (QuotientAddGroup.mk' H) ∘ Y; μ']) }\n  have : 0 ≤ H[X ; μ] + H[Y ; μ'] := by linarith [entropy_nonneg X μ, entropy_nonneg Y μ']\n  have : 0 < 1 - α := sub_pos.mpr αone\n  by_cases hE : (⊥ : AddSubgroup G) ∈ S\n  · classical\n    obtain ⟨H, ⟨⟨c, hc, hlog, hup⟩, hent⟩, hMaxl⟩ :=\n      S.toFinite.exists_maximal_wrt id S (Set.nonempty_of_mem hE)\n    set ψ : G →+ G ⧸ H := QuotientAddGroup.mk' H\n    have surj : Function.Surjective ψ := QuotientAddGroup.mk'_surjective H\n\n    set G' := G ⧸ H\n    have : ElementaryAddCommGroup G' 2 := ElementaryAddCommGroup.quotient_group (by decide)\n      (by simp [AddSubgroup.zero_mem])\n\n    obtain ⟨H', hlog', hup'⟩ := app_ent_PFR _ _ _ _ α hent ((measurable_discrete _).comp hX)\n      ((measurable_discrete _).comp hY)\n    have H_ne_bot: H' ≠ ⊥ := by\n      by_contra!\n      rcases this with rfl\n      have inj : Function.Injective (QuotientAddGroup.mk' (⊥ : AddSubgroup G')) :=\n          (QuotientAddGroup.quotientBot : (G' ⧸ ⊥) ≃+ G').symm.injective\n      rw [entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ inj,\n          entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ inj] at hup'\n      nlinarith [entropy_nonneg (ψ ∘ X) μ, entropy_nonneg (ψ ∘ Y) μ']\n    let H'' := H'.comap ψ\n    use H''\n\n    rw [← (AddSubgroup.map_comap_eq_self_of_surjective surj _ : H''.map ψ = H')] at hup' hlog'\n    set H' := H''.map ψ\n\n    have Hlt : H < H'' := by\n      have : H = (⊥ : AddSubgroup G').comap ψ := by\n        simp only [AddMonoidHom.comap_bot, QuotientAddGroup.ker_mk']\n      rw [this, AddSubgroup.comap_lt_comap_of_surjective surj]\n      exact Ne.bot_lt H_ne_bot\n\n    let φ : G' ⧸ H' ≃+ G ⧸ H'' := QuotientAddGroup.quotientQuotientEquivQuotient H H'' Hlt.le\n    set ψ' : G' →+ G' ⧸ H' := QuotientAddGroup.mk' H'\n    set ψ'' : G →+ G ⧸ H'' := QuotientAddGroup.mk' H''\n    have diag : ψ' ∘ ψ = φ.symm ∘ ψ'' := rfl\n    rw [← Function.comp.assoc, ← Function.comp.assoc, diag, Function.comp.assoc,\n        Function.comp.assoc] at hup'\n\n    have cond : log (Nat.card H'') ≤\n        (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := by\n      have cardprod : Nat.card H'' = Nat.card H' * Nat.card H := by\n        have hcard₀ := Nat.card_congr <| (AddSubgroup.addSubgroupOfEquivOfLe Hlt.le).toEquiv\n        have hcard₁ := Nat.card_congr <|\n          (QuotientAddGroup.quotientKerEquivRange (ψ.restrict H'')).toEquiv\n        have hcard₂ := AddSubgroup.card_eq_card_quotient_add_card_addSubgroup (H.addSubgroupOf H'')\n        rw [ψ.ker_restrict H'', QuotientAddGroup.ker_mk', ψ.restrict_range H''] at hcard₁\n        simpa only [← Nat.card_eq_fintype_card, hcard₀, hcard₁] using hcard₂\n      calc\n          log (Nat.card H'')\n      _ = log ((Nat.card H' : ℝ) * (Nat.card H : ℝ)) := by rw [cardprod]; norm_cast\n      _ = log (Nat.card H') + log (Nat.card H) := by\n        rw [Real.log_mul (Nat.cast_ne_zero.2 (@Nat.card_pos H').ne')\n              (Nat.cast_ne_zero.2 (@Nat.card_pos H).ne')]\n      _ ≤ (1 + α) / 2 * (H[⇑ψ ∘ X ; μ] + H[⇑ψ ∘ Y ; μ']) + log (Nat.card H) := by gcongr\n      _ ≤ (1 + α) / 2 * (c * (H[X; μ] + H[Y;μ'])) +\n            (1 + α) / (2 * (1 - α)) * (1 - c) * (H[X ; μ] + H[Y ; μ']) := by gcongr\n      _ = (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X ; μ] + H[Y ; μ']) := by\n        field_simp; ring\n\n    have HS : H'' ∉ S := λ Hs => Hlt.ne (hMaxl H'' Hs Hlt.le)\n    simp only [Set.mem_setOf_eq, not_and, not_lt] at HS\n    refine ⟨?_, HS ⟨α * c, by positivity, cond, ?_⟩⟩\n    · calc\n      log (Nat.card H'')\n      _ ≤ (1 + α) / (2 * (1 - α)) * (1 - α * c) * (H[X; μ] + H[Y;μ']) := cond\n      _ ≤ (1 + α) / (2 * (1 - α)) * 1 * (H[X; μ] + H[Y;μ']) := by gcongr; simp; positivity\n      _ = (1 + α) / (2 * (1 - α)) * (H[X; μ] + H[Y;μ']) := by simp only [mul_one]\n    · calc\n      H[ ψ'' ∘ X; μ ] + H[ ψ'' ∘ Y; μ' ]\n      _ = H[ φ.symm ∘ ψ'' ∘ X; μ ] + H[ φ.symm ∘ ψ'' ∘ Y; μ' ] := by\n        simp_rw [← entropy_comp_of_injective _ ((measurable_discrete _).comp hX) _ φ.symm.injective,\n                 ← entropy_comp_of_injective _ ((measurable_discrete _).comp hY) _ φ.symm.injective]\n      _ ≤ α * (H[ ψ ∘ X; μ ] + H[ ψ ∘ Y; μ' ]) := hup'.le\n      _ ≤ α * (c * (H[X ; μ] + H[Y ; μ'])) := by gcongr\n      _ = (α * c) * (H[X ; μ] + H[Y ; μ']) := by ring\n  · use ⊥\n    constructor\n    · simp only [AddSubgroup.mem_bot, Nat.card_eq_fintype_card, Fintype.card_ofSubsingleton,\n        Nat.cast_one, log_one]\n      positivity\n    · simp only [Set.mem_setOf_eq, not_and, not_lt] at hE\n      exact hE ⟨1, by norm_num, by\n        norm_num; exact add_le_add (entropy_comp_le μ hX _) (entropy_comp_le μ' hY _)⟩\n\n/-- If $G=\\mathbb{F}_2^d$ and $X,Y$ are $G$-valued random variables then there is\na subgroup  $H\\leq \\mathbb{F}_2^d$ such that\n\\[\\log \\lvert H\\rvert \\leq 2 * (\\mathbb{H}(X)+\\mathbb{H}(Y))\\]\nand if $\\psi:G \\to G/H$ is the natural projection then\n\\[\\mathbb{H}(\\psi(X))+\\mathbb{H}(\\psi(Y))\\leq 34 * d[\\psi(X);\\psi(Y)].\\] -/\nlemma PFR_projection (hX : Measurable X) (hY : Measurable Y) :\n    ∃ H : AddSubgroup G, log (Nat.card H) ≤ 2 * (H[X; μ] + H[Y;μ']) ∧\n    H[(QuotientAddGroup.mk' H) ∘ X; μ] + H[(QuotientAddGroup.mk' H) ∘ Y; μ'] ≤\n      34 * d[(QuotientAddGroup.mk' H) ∘ X;μ # (QuotientAddGroup.mk' H) ∘ Y;μ'] := by\n  rcases PFR_projection' X Y μ μ' ((3 : ℝ) / 5) hX hY (by norm_num) (by norm_num) with ⟨H, h, h'⟩\n  refine ⟨H, ?_, ?_⟩\n  · convert h\n    norm_num\n  · have : 0 ≤ d[⇑(QuotientAddGroup.mk' H) ∘ X ; μ # ⇑(QuotientAddGroup.mk' H) ∘ Y ; μ'] :=\n      rdist_nonneg ((measurable_discrete _).comp hX) ((measurable_discrete _).comp hY)\n    linarith\n\nend F2_projection\n\nopen MeasureTheory ProbabilityTheory Real Set\nopen scoped BigOperators\n\nlemma four_logs {a b c d : ℝ} (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) :\n    log ((a*b)/(c*d)) = log a + log b - log c - log d := by\n  rw [log_div, log_mul, log_mul, sub_sub] <;> positivity\n\nlemma sum_prob_preimage {G H : Type*} {X : Finset H} {A : Set G} [Finite A] {φ : A → X}\n    {A_ : H → Set G} (hA : A.Nonempty) (hφ : ∀ x : X, A_ x = Subtype.val '' (φ ⁻¹' {x})) :\n    ∑ x in X, (Nat.card (A_ x) : ℝ) / (Nat.card A) = 1 := by\n  rw [← Finset.sum_div]\n  apply (div_eq_one_iff_eq <| Nat.cast_ne_zero.mpr <| Nat.pos_iff_ne_zero.mp (@Nat.card_pos _ hA.to_subtype _)).mpr\n  classical\n  haveI := Fintype.ofFinite A\n  rewrite [Nat.card_eq_fintype_card, ← Finset.card_univ, Finset.card_eq_sum_card_fiberwise\n    <| fun a _ ↦ Finset.mem_univ (φ a), ← Finset.sum_coe_sort]\n  norm_cast\n  congr; ext\n  rewrite [← Set.Finite.toFinset_setOf, (Set.toFinite _).card_toFinset, ← Nat.card_eq_fintype_card,\n    hφ, Nat.card_image_of_injective Subtype.val_injective]; rfl\n\n/-- Let $\\phi : G\\to H$ be a homomorphism and $A,B\\subseteq G$ be finite subsets. If $x,y\\in H$ then let $A_x=A\\cap \\phi^{-1}(x)$ and $B_y=B\\cap \\phi^{-1}(y)$. There exist $x,y\\in H$ such that $A_x,B_y$ are both non-empty and\n\\[d[\\phi(U_A);\\phi(U_B)]\\log \\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A_x\\rvert\\lvert B_y\\rvert}\\leq (\\mathbb{H}(\\phi(U_A))+\\mathbb{H}(\\phi(U_B)))(d(U_A,U_B)-d(U_{A_x},U_{B_y}).\\] -/\nlemma single_fibres {G H Ω Ω': Type u}\n    [AddCommGroup G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n    [AddCommGroup H] [Countable H] [MeasurableSpace H] [MeasurableSingletonClass H]\n    [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    (φ : G →+ H)\n    {A B : Set G} [Finite A] [Finite B] {UA : Ω → G} {UB: Ω' → G} (hA : A.Nonempty) (hB : B.Nonempty)\n    (hUA': Measurable UA) (hUB': Measurable UB) (hUA: IsUniform A UA) (hUB: IsUniform B UB)\n    (hUA_mem : ∀ ω, UA ω ∈ A) (hUB_mem : ∀ ω, UB ω ∈ B) :\n    ∃ (x y : H) (Ax By: Set G),\n    Ax = A ∩ φ.toFun ⁻¹' {x} ∧ By = B ∩ φ.toFun ⁻¹' {y} ∧ Ax.Nonempty ∧ By.Nonempty ∧\n    d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n    * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) ≤\n    (H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n  have : Nonempty A := hA.to_subtype\n  have : Nonempty B := hB.to_subtype\n  haveI : FiniteRange UA := finiteRange_of_finset UA A.toFinite.toFinset (by simpa)\n  haveI : FiniteRange UB := finiteRange_of_finset UB B.toFinite.toFinset (by simpa)\n  have hUA_coe : IsUniform A.toFinite.toFinset.toSet UA := by rwa [Set.Finite.coe_toFinset]\n  have hUB_coe : IsUniform B.toFinite.toFinset.toSet UB := by rwa [Set.Finite.coe_toFinset]\n\n  let A_ (x : H) : Set G := A ∩ φ.toFun ⁻¹' {x}\n  let B_ (y : H) : Set G := B ∩ φ.toFun ⁻¹' {y}\n  let X : Finset H := FiniteRange.toFinset (φ.toFun ∘ UA)\n  let Y : Finset H := FiniteRange.toFinset (φ.toFun ∘ UB)\n\n  haveI h_Ax (x : X) : Nonempty (A_ x.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp x.property\n    use UA ω; exact Set.mem_inter (hUA_mem ω) (by exact hω)\n  haveI h_By (y : Y) : Nonempty (B_ y.val) := by\n    obtain ⟨ω, hω⟩ := (FiniteRange.mem_iff _ _).mp y.property\n    use UB ω; exact Set.mem_inter (hUB_mem ω) (by exact hω)\n  have h_AX (a : A) : φ.toFun a.val ∈ X := by\n    obtain ⟨ω, hω⟩ := hUA_coe.nonempty_preimage_of_mem hUA' (A.toFinite.mem_toFinset.mpr a.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun a.val)).mpr ⟨ω, congr_arg _ hω⟩\n  have h_BY (b : B) : φ.toFun b.val ∈ Y := by\n    obtain ⟨ω, hω⟩ := hUB_coe.nonempty_preimage_of_mem hUB' (B.toFinite.mem_toFinset.mpr b.property)\n    exact (FiniteRange.mem_iff _ (φ.toFun b.val)).mpr ⟨ω, congr_arg _ hω⟩\n\n  let φ_AX (a : A) : X := by use φ.toFun a.val; exact h_AX a\n  let φ_BY (b : B) : Y := by use φ.toFun b.val; exact h_BY b\n  have h_φ_AX (x : X) : A_ x.val = φ_AX ⁻¹' {x} := by ext; simp; simp [Subtype.ext_iff]\n  have h_φ_BY (y : Y) : B_ y.val = φ_BY ⁻¹' {y} := by ext; simp; simp [Subtype.ext_iff]\n\n  let p (x : H) (y : H) : ℝ :=\n    (Nat.card (A_ x).Elem) * (Nat.card (B_ y).Elem) / ((Nat.card A.Elem) * (Nat.card B.Elem))\n  have : ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB]\n  calc\n    _ = d[UA | φ.toFun ∘ UA # UB | φ.toFun ∘ UB] := by\n      rewrite [condRuzsaDist_eq_sum hUA' ((measurable_discrete _).comp hUA')\n        hUB' ((measurable_discrete _).comp hUB')]\n      refine Finset.sum_congr rfl <| fun x hx ↦ Finset.sum_congr rfl <| fun y hy ↦ ?_\n      haveI : Nonempty (A_ x) := h_Ax ⟨x, hx⟩\n      haveI : Nonempty (B_ y) := h_By ⟨y, hy⟩\n      let μx := (ℙ : Measure Ω)[|(φ.toFun ∘ UA) ⁻¹' {x}]\n      let μy := (ℙ : Measure Ω')[|(φ.toFun ∘ UB) ⁻¹' {y}]\n      have h_μ_p : IsProbabilityMeasure μx ∧ IsProbabilityMeasure μy := by\n        constructor <;> apply ProbabilityTheory.cond_isProbabilityMeasure <;> rw [Set.preimage_comp]\n        refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUA_coe hUA' _ ?_\n        swap; refine @IsUniform.measure_preimage_ne_zero _ _ _ _ _ _ _ _ _ _ hUB_coe hUB' _ ?_\n        all_goals rwa [Set.inter_comm, Set.Finite.coe_toFinset]\n      have h_μ_unif : IsUniform (A_ x) UA μx ∧ IsUniform (B_ y) UB μy := by\n        have : _ ∧ _ := ⟨hUA.restrict hUA' (φ.toFun ⁻¹' {x}), hUB.restrict hUB' (φ.toFun ⁻¹' {y})⟩\n        rwa [Set.inter_comm _ A, Set.inter_comm _ B] at this\n      rewrite [rdist_set_eq_rdist h_μ_p.1 h_μ_p.2 h_μ_unif.1 h_μ_unif.2 hUA' hUB']\n      show _ = (Measure.real _ (UA ⁻¹' (_ ⁻¹' _))) * (Measure.real _ (UB ⁻¹' (_ ⁻¹' _))) * _\n      rewrite [hUA_coe.measureReal_preimage hUA', hUB_coe.measureReal_preimage hUB']\n      simp_rw [IsProbabilityMeasure.measureReal_univ, one_mul]\n      rewrite [mul_div_mul_comm, Set.inter_comm A, Set.inter_comm B]\n      simp only [Set.Finite.coe_toFinset, Set.Finite.mem_toFinset, Finset.mem_val]; rfl\n    _ ≤ d[UA # UB] - d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      rewrite [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe]\n      linarith only [rdist_le_sum_fibre φ hUA' hUB' (μ := ℙ) (μ' := ℙ)]\n  let M := H[φ.toFun ∘ UA] + H[φ.toFun ∘ UB]\n  have hM : M = ∑ x in X, ∑ y in Y, Real.negMulLog (p x y) := by\n    have h_compl (z : H × H) (h_notin : z ∉ X ×ˢ Y) : Real.negMulLog (p z.1 z.2) = 0 := by\n      have h_p_empty {a b : ℝ} : negMulLog ((Nat.card (∅ : Set G)) * a / b) = 0 := by simp\n      unfold_let p; beta_reduce\n      rewrite [Finset.mem_product, not_and_or] at h_notin\n      cases' h_notin with h_notin h_notin\n      have h_empty : A_ z.1 = ∅; rotate_left 2\n      have h_empty : B_ z.2 = ∅; let h_AX := h_BY; rotate_left\n      rw [mul_comm, h_empty, h_p_empty]; rotate_left\n      rw [h_empty, h_p_empty]\n      all_goals {\n        by_contra hc\n        obtain ⟨a, ha⟩ := Set.nonempty_iff_ne_empty'.mpr hc\n        rewrite [← ha.right] at h_notin\n        exact h_notin (h_AX ⟨a, ha.left⟩)\n      }\n    unfold_let M\n    unfold entropy\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUA').aemeasurable\n    haveI := isProbabilityMeasure_map (μ := ℙ) ((measurable_discrete φ).comp hUB').aemeasurable\n    rewrite [← Finset.sum_product', ← tsum_eq_sum h_compl, ← measureEntropy_prod]\n    apply tsum_congr; intro; congr\n    rewrite [← Set.singleton_prod_singleton, Measure.smul_apply, Measure.prod_prod,\n      Measure.map_apply ((measurable_discrete _).comp hUA') (MeasurableSet.singleton _),\n      Measure.map_apply ((measurable_discrete _).comp hUB') (MeasurableSet.singleton _),\n      Set.preimage_comp, hUA_coe.measure_preimage hUA',\n      Set.preimage_comp, hUB_coe.measure_preimage hUB']\n    simp? [mul_div_mul_comm, Set.inter_comm, ENNReal.toReal_div]\n      says simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,\n        measure_univ, inv_one, Finite.coe_toFinset, inter_comm, one_mul,\n        Finite.mem_toFinset, smul_eq_mul, ENNReal.toReal_mul, ENNReal.toReal_div,\n        ENNReal.toReal_nat, mul_div_mul_comm]\n  have h_sum : ∑ x in X, ∑ y in Y,\n      (p x y) * (M * dᵤ[A_ x # B_ y] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x y)) ≤\n      M * d[UA # UB]\n  calc\n    _ = ∑ x in X, ∑ y in Y, (p x y) * M * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [hM, Finset.sum_mul, ← Finset.sum_add_distrib]\n      refine Finset.sum_congr rfl <| fun _ _ ↦ Finset.sum_congr rfl <| fun _ _ ↦ ?_\n      simp only [negMulLog, left_distrib, mul_assoc, Finset.sum_mul]\n      exact congrArg (HAdd.hAdd _) (by group)\n    _ = M * ∑ x in X, ∑ y in Y, (p x y) * dᵤ[A_ x # B_ y] + M * d[φ.toFun ∘ UA # φ.toFun ∘ UB] := by\n      simp_rw [Finset.mul_sum]\n      congr; ext; congr; ext; group\n    _ ≤ M * d[UA # UB] := by\n      rewrite [← left_distrib]\n      apply mul_le_mul_of_nonneg_left\n      · linarith\n      · unfold_let M\n        linarith only [entropy_nonneg (φ.toFun ∘ UA) ℙ, entropy_nonneg (φ.toFun ∘ UB) ℙ]\n  have : ∃ x : X, ∃ y : Y,\n      M * dᵤ[A_ x.val # B_ y.val] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p x.val y.val) ≤\n      M * d[UA # UB] := by\n    let f (xy : H × H) := (p xy.1 xy.2) * (M * d[UA # UB])\n    let g (xy : H × H) := (p xy.1 xy.2) *\n      (M * dᵤ[A_ xy.1 # B_ xy.2] + d[φ.toFun ∘ UA # φ.toFun ∘ UB] * -Real.log (p xy.1 xy.2))\n    by_contra hc; push_neg at hc\n    replace hc : ∀ xy ∈ X ×ˢ Y, f xy < g xy := by\n      refine fun xy h ↦ mul_lt_mul_of_pos_left ?_ ?_\n      · exact hc ⟨xy.1, (Finset.mem_product.mp h).1⟩ ⟨xy.2, (Finset.mem_product.mp h).2⟩\n      · haveI : Nonempty _ := h_Ax ⟨xy.1, (Finset.mem_product.mp h).1⟩\n        haveI : Nonempty _ := h_By ⟨xy.2, (Finset.mem_product.mp h).2⟩\n        simp only [div_pos, mul_pos, Nat.cast_pos, Nat.card_pos]\n    have h_nonempty : Finset.Nonempty (X ×ˢ Y) := by\n      use ⟨φ.toFun <| UA <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩,\n        φ.toFun <| UB <| Classical.choice <| ProbabilityMeasure.nonempty ⟨ℙ, inferInstance⟩⟩\n      exact Finset.mem_product.mpr ⟨FiniteRange.mem _ _, FiniteRange.mem _ _⟩\n    replace hc := Finset.sum_lt_sum_of_nonempty h_nonempty hc\n    have h_p_one : ∑ x in X ×ˢ Y, p x.1 x.2 = 1 := by\n      simp_rw [Finset.sum_product, mul_div_mul_comm, ← Finset.mul_sum,\n        ← sum_prob_preimage hA h_φ_AX, sum_prob_preimage hB h_φ_BY, mul_one]\n    rewrite [← Finset.sum_mul, h_p_one, one_mul, Finset.sum_product] at hc\n    exact not_le_of_gt hc h_sum\n  obtain ⟨x, y, hxy⟩ := this\n  refine ⟨x, y, A_ x.val, B_ y.val, rfl, rfl, @nonempty_of_nonempty_subtype _ _ (h_Ax x), @nonempty_of_nonempty_subtype _ _ (h_By y), ?_⟩\n  rewrite [← inv_div, Real.log_inv]\n  show _ * -log (p x.val y.val) ≤ M * _\n  linarith only [hxy]\n\nsection dim\n\nopen Classical\n\nvariable {G : Type*} [AddCommGroup G]\n\n/- If G ≅ ℤᵈ then there is a subgroup H of G such that A lies in a coset of H. This is helpful to\n  give the equivalent definition of `dimension`. Here this is stated in greated generality since the\n  proof carries over automatically-/\nlemma exists_coset_cover (A : Set G) :\n    ∃ (d : ℕ), ∃ (S : Submodule ℤ G) (v : G),\n      FiniteDimensional.finrank ℤ S = d ∧ ∀ a ∈ A, a - v ∈ S := by\n  existsi FiniteDimensional.finrank ℤ (⊤ : Submodule ℤ G), ⊤, 0\n  refine ⟨rfl, fun a _ ↦ trivial⟩\n\n/-- The dimension of the affine span over `ℤ` of a subset of an additive group. -/\nnoncomputable def dimension (A : Set G) : ℕ := Nat.find (exists_coset_cover A)\n\nlemma dimension_le_of_coset_cover (A : Set G) (S : Submodule ℤ G) (v : G)\n    (hA : ∀ a ∈ A, a - v ∈ S) : dimension A ≤ FiniteDimensional.finrank ℤ S := by\n  apply Nat.find_le\n  existsi S , v\n  exact ⟨rfl, hA⟩\n\nlemma dimension_le_rank [Module.Finite ℤ G] (A : Set G) :\n    dimension A ≤ FiniteDimensional.finrank ℤ G := by\n  obtain ⟨S, v, hs, _⟩ := Nat.find_spec (exists_coset_cover A)\n  rw [dimension, ←hs]\n  apply Submodule.finrank_le S\n\nend dim\n\nvariable {G : Type u} [AddCommGroup G] [Module.Free ℤ G] [Module.Finite ℤ G] [Countable G] [MeasurableSpace G] [MeasurableSingletonClass G]\n\nopen Real MeasureTheory ProbabilityTheory Pointwise Set\n\n/-- Move to Mathlib? `Finsupp.mapRange` of a surjective function is surjective. -/\nlemma Finsupp.mapRange_surjective {α : Type u_1} {M : Type u_5} {N : Type u_7} [Zero M] [Zero N] (f : M → N) (hf : f 0 = 0)\n  (hs : Function.Surjective f) : Function.Surjective (Finsupp.mapRange (α := α) f hf) := by\n  classical\n  let g (n : N) : M := if n = 0 then 0 else Function.surjInv hs n\n  have : Function.RightInverse g f := by\n    intro n\n    by_cases h : n = 0\n    . simp [h,hf]\n    simp [h, Function.surjInv_eq hs n]\n  have hg : g 0 = 0 := by simp\n  have hfg : (f ∘ g) 0 = 0 := by simp [hf, hg]\n  intro F\n  use Finsupp.mapRange g hg F\n  rw [← Finsupp.mapRange_comp (h := hfg)]\n  convert Finsupp.mapRange_id F\n  convert Function.RightInverse.id this\n\n/-- A free Z-module is torsion-free. Move to Mathlib? -/\nlemma torsion_free : AddMonoid.IsTorsionFree G := by\n    rintro x hx hn\n    rw [isOfFinAddOrder_iff_nsmul_eq_zero] at hn\n    rcases hn with ⟨ n, hn, hn' ⟩\n    apply_fun Module.Free.repr ℤ G at hn'\n    simp_rw [map_nsmul, map_zero, smul_eq_zero, AddEquivClass.map_eq_zero_iff, hx, or_false] at hn'\n    linarith\n\n/-- If G is a rank n free Z-module, then G/2G is a finite elementary 2-group of cardinality 2^n.  Code is slow, needs to be golfed -/\nlemma weak_PFR_quotient_prelim :\n  let H := G ⧸ (AddMonoidHom.range (zsmulAddGroupHom 2))\n  ElementaryAddCommGroup H 2 ∧ Finite H ∧ Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  set φ : G →+ H := QuotientAddGroup.mk' G₂\n  have hH_elem : ElementaryAddCommGroup H 2 := by\n    apply ElementaryAddCommGroup.quotient_group (by decide)\n    intro x; rw [AddMonoidHom.mem_range]\n    use x\n    rw [zsmulAddGroupHom_apply]\n    norm_cast\n  let B := Module.Free.ChooseBasisIndex ℤ G\n  let bG : Basis B ℤ G := Module.Free.chooseBasis ℤ G\n  have hB_fin : Fintype B := by infer_instance\n  have hB_card : Nat.card B = FiniteDimensional.finrank ℤ G := by\n    rw [FiniteDimensional.finrank_eq_card_basis bG, Nat.card_eq_fintype_card]\n  have hH_module : Module (ZMod 2) H := by infer_instance\n  let mod : (B →₀ ℤ) →+ (B →₀ ZMod 2) := Finsupp.mapRange.addMonoidHom (Int.castAddHom (ZMod 2))\n  let f : G →+ (B →₀ ℤ) := bG.repr\n  have hker : G₂ ≤ AddMonoidHom.ker (AddMonoidHom.comp mod f) := by\n    intro x hx\n    simp_rw [AddMonoidHom.mem_range, zsmulAddGroupHom_apply, AddMonoidHom.mem_ker, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom] at hx ⊢\n    rcases hx with ⟨ y, rfl⟩\n    ext b\n    simp_rw [map_zsmul, Finsupp.mapRange_apply, Finsupp.coe_smul, Pi.smul_apply, smul_eq_mul,\n      Int.cast_mul, Int.int_cast_ofNat, Finsupp.coe_zero, Pi.zero_apply, mul_eq_zero]\n    left\n    exact ZMod.nat_cast_self 2\n  let g : H →+ (B →₀ ZMod 2) := QuotientAddGroup.lift G₂ (AddMonoidHom.comp mod f) hker\n  have hsur : Function.Surjective g := by\n    have h1 : Function.Surjective mod := Finsupp.mapRange_surjective (Int.castAddHom (ZMod 2)) (map_zero _) ZMod.int_cast_surjective\n    have h2 := h1.comp bG.repr.surjective\n    have h3 : mod ∘ bG.repr = g ∘ (QuotientAddGroup.mk' G₂) := by\n      ext x b\n      simp only [Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,\n        Finsupp.mapRange_apply, QuotientAddGroup.coe_mk', QuotientAddGroup.lift_mk,\n        AddMonoidHom.coe_comp, AddMonoidHom.coe_coe]\n    rw [h3] at h2\n    apply Function.Surjective.of_comp h2\n  have hinj : Function.Injective g := by\n    rw [injective_iff_map_eq_zero]\n    intro x hx\n    rcases QuotientAddGroup.mk'_surjective G₂ x with ⟨y, rfl⟩\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.lift_mk, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, Function.comp_apply, Finsupp.mapRange.addMonoidHom_apply, Int.coe_castAddHom,FunLike.ext_iff,Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply,ZMod.int_cast_zmod_eq_zero_iff_dvd] at hx\n    replace hx := fun x ↦ Int.mul_ediv_cancel' (hx x)\n    let z (b : B) := ((Module.Free.chooseBasis ℤ G).repr y) b / 2\n    let z' := (Finsupp.equivFunOnFinite).symm z\n    change ∀ b : B, 2 * z' b = (f y) b at hx\n    let x' := bG.repr.symm z'\n    simp_rw [QuotientAddGroup.mk'_apply, QuotientAddGroup.eq_zero_iff, AddMonoidHom.mem_range, zsmulAddGroupHom_apply]\n    use x'\n    change 2 • (bG.repr.symm.toLinearMap.toAddMonoidHom z') = y\n    rw [← AddMonoidHom.map_zsmul bG.repr.symm.toLinearMap.toAddMonoidHom z' (2 : ℤ)]\n    rw [← LinearEquiv.symm_apply_apply bG.repr y]\n    change bG.repr.symm (2 • z') = bG.repr.symm (f y)\n    congr\n    ext b\n    rw [Finsupp.smul_apply, ← hx b, smul_eq_mul]\n  rcases Function.bijective_iff_has_inverse.mp ⟨ hinj, hsur ⟩ with ⟨ g', hg' ⟩\n\n  have bH : Basis B (ZMod 2) H := by\n    constructor\n    exact {\n      toFun := g\n      invFun := g'\n      left_inv := hg'.1\n      right_inv := hg'.2\n      map_add' := AddMonoidHom.map_add _\n      map_smul' := by\n        intro r x\n        rcases ZMod.int_cast_surjective r with ⟨ n, rfl ⟩\n        change g ((n : ZMod 2) • x) = (n : ZMod 2) • g x\n        rw [intCast_smul, intCast_smul]\n        exact AddMonoidHom.map_zsmul g x n\n    }\n  have hH_fin : Fintype H := Module.fintypeOfFintype bH\n  have hH_card : Nat.card H = 2^(FiniteDimensional.finrank ℤ G) := by\n    rw [Nat.card_eq_fintype_card, Module.card_fintype bH, ← Nat.card_eq_fintype_card (α := B), hB_card]\n    congr\n  exact ⟨ hH_elem, Finite.of_fintype H, hH_card ⟩\n\nopen QuotientAddGroup\n\n/-- A version of the third isomorphism theorem: if G₂ ≤ G and H' is a subgroup of G⧸G₂, then there is a canonical isomorphism between H⧸H' and G⧸N, where N is the preimage of H' in G. A bit clunky; may be a better way to do this -/\nlemma third_iso {G : Type u} [AddCommGroup G] {G₂ : AddSubgroup G} (H' : AddSubgroup (G ⧸ G₂)) :\n  let H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  ∃ e : H ⧸ H' ≃+ G ⧸ N, ∀ x : G, e (mk' H' (φ x))= mk' N x := by\n  set H := G ⧸ G₂\n  let φ : G →+ H := mk' G₂\n  let N := AddSubgroup.comap φ H'\n  have h1 : G₂ ≤ N := by\n    intro x hx\n    rw [← eq_zero_iff] at hx\n    simp [hx, AddSubgroup.zero_mem H']\n  set H'' := AddSubgroup.map (mk' G₂) N\n  have h2 : H' = H'' := by\n    change H' = AddSubgroup.map (mk' G₂) N\n    rw [AddSubgroup.map_comap_eq, AddMonoidHom.range_top_of_surjective _ (mk'_surjective G₂)]\n    simp\n  let e1 : H ⧸ H'' ≃+ G ⧸ N := quotientQuotientEquivQuotient _ _ h1\n  let e2 := quotientAddEquivOfEq h2\n  set e := e2.trans e1\n  use e\n  intro x\n  convert (quotientQuotientEquivQuotientAux_mk_mk _ _ h1 x) using 1\n\nlemma single {Ω : Type u} [MeasurableSpace Ω] [DiscreteMeasurableSpace Ω] (μ : Measure Ω)\n    [IsProbabilityMeasure μ] {A : Set Ω} {z : Ω} (hA : μ.real A = 1) (hz : μ.real {z} > 0) :\n    z ∈ A := by\n  contrapose! hz\n  have : Disjoint {z} A := by simp [hz]\n  replace this := measureReal_union (μ := μ) this (measurableSet_discrete _)\n  simp [hA] at this\n  have h := measureReal_mono (μ := μ) (show insert z A ⊆ Set.univ by simp)\n  simp [this] at h\n  assumption\n\n/-- Given two non-empty finite subsets A, B of a rank n free Z-module G, there exists a subgroup N and points x, y in G/N such that the fibers Ax, By of A, B over x, y respectively are non-empty, one has the inequality\n$$ \\log \\frac{|A| |B|}{|A_x| |B_y|} ≤ 34 (d[U_A; U_B] - d[U_{A_x}; U_{B_y}])$$\nand one has the dimension bound\n$$ n \\log 2 ≤ \\log |G/N| + 40 d[U_A; U_B].$$\n -/\nlemma weak_PFR_asymm_prelim (A B : Set G) [Finite A] [Finite B] (hnA : A.Nonempty) (hnB : B.Nonempty):\n    ∃ (N : AddSubgroup G) (x y : G ⧸ N) (Ax By : Set G), Ax.Nonempty ∧ By.Nonempty ∧\n    Set.Finite Ax ∧ Set.Finite By ∧ Ax = {z:G | z ∈ A ∧ QuotientAddGroup.mk' N z = x } ∧\n    By = {z:G | z ∈ B ∧ QuotientAddGroup.mk' N z = y } ∧\n    (log 2) * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) +\n      40 * dᵤ[ A # B ] ∧ log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By)\n      ≤ 34 * (dᵤ[ A # B ] - dᵤ[ Ax # By ]) := by\n  have : Nonempty A := hnA.to_subtype\n  have : Nonempty B := hnB.to_subtype\n  obtain ⟨ h_elem, h_finite, h_card ⟩ := weak_PFR_quotient_prelim (G := G)\n  set ψ : G →+ G := zsmulAddGroupHom 2\n  set G₂ := AddMonoidHom.range ψ\n  set H := G ⧸ G₂\n  let φ : G →+ H := QuotientAddGroup.mk' G₂\n  let _mH : MeasurableSpace H := ⊤\n  have h_fintype : Fintype H := Fintype.ofFinite H\n  have h_torsionfree := torsion_free (G := G)\n\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, hUA_mem, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, hUB_mem, hUB_fin ⟩ :=\n    exists_isUniform_measureSpace' B\n\n  rcases (PFR_projection (φ.toFun ∘ UA) (φ.toFun ∘ UB) ℙ ℙ (by measurability) (by measurability)) with ⟨H', ⟨ hH1, hH2 ⟩ ⟩\n  let N := AddSubgroup.comap φ H'\n  set φ' := QuotientAddGroup.mk' N\n  have _cGN : Countable (G ⧸ N) := Function.Surjective.countable (QuotientAddGroup.mk'_surjective N)\n  have _msGN : MeasurableSingletonClass (G ⧸ N) := by\n    constructor\n    intro x\n    exact MeasurableSpace.map_def.mpr (measurableSet_discrete _)\n\n  rcases third_iso H' with ⟨ e : H ⧸ H' ≃+ G ⧸ N, he ⟩\n  rcases single_fibres φ' hnA hnB hUA_mes hUB_mes hUA_unif hUB_unif hUA_mem hUB_mem with\n    ⟨x, y, Ax, By, hAx, hBy, hnAx, hnBy, hcard_ineq⟩\n\n  have : Nonempty Ax := hnAx.to_subtype\n  have : Nonempty By := hnBy.to_subtype\n  have Axf : Finite Ax := by rw [hAx]; infer_instance\n  have Byf : Finite By := by rw [hBy]; infer_instance\n\n  have h1 := torsion_dist_shrinking UA UB ℙ ℙ hUA_mes hUB_mes h_torsionfree φ\n  have h2 := torsion_dist_shrinking UB UA ℙ ℙ hUB_mes hUA_mes h_torsionfree φ\n  rw [rdist_symm] at h2\n  rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes] at h1 h2\n  -- using explicit .toFun casts as this saves a lot of heartbeats\n  change H[φ.toFun ∘ UA] ≤ 10 * dᵤ[A # B] at h1\n  change H[φ.toFun ∘ UB] ≤ 10 * dᵤ[A # B] at h2\n  replace hH1 : log (Nat.card H') ≤ 40  * dᵤ[A # B] := by\n    apply hH1.trans\n    linarith\n  replace h_card : log 2 * FiniteDimensional.finrank ℤ G ≤ log (Nat.card (G ⧸ N)) + 40 * dᵤ[A # B] := by\n    rw [mul_comm, ← log_rpow (by norm_num)]\n    norm_cast\n    classical\n    rwa [← h_card, ← Nat.card_congr e.toEquiv, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card, ← AddSubgroup.index_mul_card H', AddSubgroup.index_eq_card, Nat.cast_mul, log_mul, add_le_add_iff_left, ← Nat.card_eq_fintype_card]\n    all_goals norm_cast; exact Fintype.card_ne_zero\n\n\n  use N, x, y, Ax, By\n  refine ⟨ hnAx, hnBy, Ax.toFinite, By.toFinite, hAx, hBy, h_card, ?_ ⟩\n\n  replace hH2 : H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] ≤ 34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] := by\n    set X := ((mk' H').toFun ∘ φ.toFun) ∘ UA\n    set Y := ((mk' H').toFun ∘ φ.toFun) ∘ UB\n    have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n    have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n    change H[X] + H[Y] ≤ 34 * d[X # Y] at hH2\n\n    have ha : φ'.toFun ∘ UA = e.toFun ∘ X := by ext x; exact (he (UA x)).symm\n    have hb : φ'.toFun ∘ UB = e.toFun ∘ Y := by ext x; exact (he (UB x)).symm\n    have he_inj : Function.Injective e.toFun := AddEquiv.injective e\n    rw [ha, hb, entropy_comp_of_injective _ hX _ he_inj, entropy_comp_of_injective _ hY _ he_inj]\n    have : d[e.toFun ∘ X # e.toFun ∘ Y] = d[X # Y] :=  rdist_of_inj hX hY e.toAddMonoidHom he_inj\n    rwa [this]\n\n  set X : Ω → G ⧸ N := φ'.toFun ∘ UA\n  set Y : Ω' → G ⧸ N := φ'.toFun ∘ UB\n  have hX : Measurable X := Measurable.comp (measurable_discrete _) hUA_mes\n  have hY : Measurable Y := Measurable.comp (measurable_discrete _) hUB_mes\n  rcases le_iff_lt_or_eq.mp (rdist_nonneg (μ := ℙ) (μ' := ℙ) hX hY) with h | h\n  swap\n  . rw [← h] at hH2\n    have hH2A : H[X] ≥ 0 := entropy_nonneg _ _\n    have hH2B : H[Y] ≥ 0 := entropy_nonneg _ _\n    have hH2A' : H[X] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n    have hH2B' : H[Y] ≤ 0 := by linarith only [hH2, hH2A, hH2B]\n\n    rcases const_of_nonpos_entropy (μ := ℙ) hX hH2A' with ⟨ x', hx ⟩\n    rcases const_of_nonpos_entropy (μ := ℙ) hY hH2B' with ⟨ y', hy ⟩\n\n    have hAAx {z : G} (hz : z ∈ A) : φ'.toFun z = x' := by\n      change (ℙ).real (UA⁻¹' (φ'⁻¹' {x'})) = 1 at hx\n      rw [← MeasureTheory.map_measureReal_apply hUA_mes (measurableSet_discrete _)] at hx\n      set Af := A.toFinite.toFinset\n      have hUAf : IsUniform Af UA := by\n        convert hUA_unif; simp only [Set.Finite.coe_toFinset]\n      have hnAf : 0 < Nat.card Af := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Af := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UA ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUAf hUA_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UA) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUA_mes)\n      replace this := single ((ℙ).map UA) hx this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hxx : Ax = A := by\n      have h : hnAx.some ∈ Ax := hnAx.some_mem\n      simp [hAx] at h ⊢\n      have := hAAx h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hAAx hz\n\n    have hBBy {z : G} (hz : z ∈ B) : φ'.toFun z = y' := by\n      change (ℙ).real (UB⁻¹' (φ'⁻¹' {y'})) = 1 at hy\n      rw [← MeasureTheory.map_measureReal_apply hUB_mes (measurableSet_discrete _)] at hy\n      set Bf := B.toFinite.toFinset\n      have hUBf : IsUniform Bf UB := by convert hUB_unif; simp only [Set.Finite.coe_toFinset]\n      have hnBf : 0 < Nat.card Bf := by simp only [Set.Finite.mem_toFinset, Nat.card_pos]\n      have hzf : z ∈ Bf := by simp [Set.Finite.mem_toFinset, hz]\n      have : (Measure.map UB ℙ).real {z} > 0 := by\n        rw [IsUniform.measureReal_preimage_of_mem' hUBf hUB_mes hzf]\n        positivity\n      have _ : IsProbabilityMeasure ((ℙ).map UB) := by\n        exact MeasureTheory.isProbabilityMeasure_map (Measurable.aemeasurable hUB_mes)\n      replace this := single ((ℙ).map UB) hy this\n      rwa [Set.mem_preimage, Set.mem_singleton_iff] at this\n\n    have hyy : By = B := by\n      have h : hnBy.some ∈ By := hnBy.some_mem\n      simp [hBy] at h ⊢\n      have := hBBy h.1\n      simp [h.2] at this\n      intro z hz\n      simp [this]\n      convert hBBy hz\n\n    simp [hxx, hyy]\n\n  have := calc d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (log (Nat.card A) + log (Nat.card B) - log (Nat.card Ax) - log (Nat.card By))\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By))) := by\n      congr\n      convert (four_logs ?_ ?_ ?_ ?_).symm\n      all_goals norm_cast; exact Nat.card_pos\n    _ ≤ (H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := hcard_ineq\n    _ ≤ (34 * d[φ'.toFun ∘ UA # φ'.toFun ∘ UB]) * (d[UA # UB] - dᵤ[Ax # By]) := by\n      apply mul_le_mul_of_nonneg_right hH2\n      have := rdist_le_avg_ent (Measurable.comp (measurable_discrete φ'.toFun) hUA_mes) (Measurable.comp (measurable_discrete φ'.toFun) hUB_mes)\n      replace this : 0 < H[φ'.toFun ∘ UA] + H[φ'.toFun ∘ UB] := by linarith\n      rw [← mul_le_mul_left this]\n      apply le_trans _ hcard_ineq\n      rw [mul_zero]\n      change 0 ≤ d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * log ((Nat.card A) * (Nat.card B) / ((Nat.card Ax) * (Nat.card By)))\n      rw [← mul_zero d[φ'.toFun ∘ UA # φ'.toFun ∘ UB], mul_le_mul_left h]\n      apply Real.log_nonneg\n      rw [one_le_div]\n      gcongr\n      . apply Nat.card_mono\n        . exact Set.toFinite A\n        rw [hAx]; exact Set.inter_subset_left _ _\n      apply Nat.card_mono\n      . exact Set.toFinite B\n      rw [hBy]; exact Set.inter_subset_left _ _\n      norm_cast\n      exact mul_pos Nat.card_pos Nat.card_pos\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (d[UA # UB] - dᵤ[Ax # By])) := by ring\n    _ = d[φ'.toFun ∘ UA # φ'.toFun ∘ UB] * (34 * (dᵤ[A # B] - dᵤ[Ax # By])) := by\n      rw [<- rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact (mul_le_mul_left h).mp this\n\n/-- Separating out the conclusion of `weak_PFR_asymm` for convenience of induction arguments.-/\ndef WeakPFRAsymmConclusion (A B : Set G) : Prop :=\n  ∃ A' B' : Set G, A' ⊆ A ∧ B' ⊆ B ∧ A'.Nonempty ∧ B'.Nonempty ∧\n  log (((Nat.card A) * (Nat.card B)) / ((Nat.card A') * (Nat.card B'))) ≤ 34 * dᵤ[A # B] ∧\n  max (dimension A') (dimension B') ≤ (40 / log 2) * dᵤ[A # B]\n\n/-- The property of two sets A,B of a group G not being contained in cosets of the same proper subgroup -/\ndef not_in_coset {G: Type u} [AddCommGroup G] (A B : Set G) : Prop := AddSubgroup.closure ((A-A) ∪ (B-B)) = ⊤\n\n\n/-- In fact one has equality here, but this is tricker to prove and not needed for the argument. -/\nlemma dimension_of_shift {G: Type u} [AddCommGroup G]\n  {H: AddSubgroup G} (A : Set H) (x : G) :\n  dimension ((fun a:H ↦ (a:G) + x) '' A) ≤ dimension A := by\n  classical\n  rcases Nat.find_spec (exists_coset_cover A) with ⟨ S, v, hrank, hshift ⟩\n  change FiniteDimensional.finrank ℤ S = dimension A at hrank\n  rw [← hrank]\n  convert dimension_le_of_coset_cover _ (Submodule.map H.subtype.toIntLinearMap S) (x+v) ?_\n  . apply LinearEquiv.finrank_eq\n    exact Submodule.equivMapOfInjective _ (by simpa using Subtype.val_injective) _\n  intro a ha\n  rw [Set.mem_image] at ha\n  rcases ha with ⟨ b, ⟨ hb, hb'⟩ ⟩\n  rw [Submodule.mem_map]\n  use b - v, hshift b hb\n  simp [← hb']\n  abel\n\nlemma conclusion_transfers {A B : Set G}\n    (G': AddSubgroup G) (A' B' : Set G')\n    (hA : IsShift A A') (hB : IsShift B B') [Finite A'] [Finite B'] (hA' : A'.Nonempty) (hB' : B'.Nonempty)\n    (h : WeakPFRAsymmConclusion A' B') : WeakPFRAsymmConclusion A B := by\n  have : Nonempty A' := hA'.to_subtype\n  have : Nonempty B' := hB'.to_subtype\n  rcases h with ⟨A'', B'', hA'', hB'', hA''_non, hB''_non, hcard_ineq, hdim_ineq⟩\n  rcases hA with ⟨ x, hA ⟩\n  set f : G' → G := fun a ↦ (a : G) + x\n  have hf : Function.Injective f := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hA' : A = f '' A' := by\n    simp_rw [hA, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  rcases hB with ⟨ y, hB ⟩\n  set g : G' → G := fun a ↦ (a : G) + y\n  have hg : Function.Injective g := by\n    intro y z hyz\n    simp at hyz\n    exact hyz\n  have hB' : B = g '' B' := by\n    simp_rw [hB, ← Set.image_vadd, Set.image_image, vadd_eq_add, add_comm]; rfl\n  use f '' A'', g '' B''\n  have : dᵤ[A # B] = dᵤ[A' # B'] := by\n    rw [<-rdist_set_of_inj _ _ (φ := G'.subtype) Subtype.val_injective, <-rdist_set_add_const (G'.subtype '' A') (G'.subtype '' B') x y]\n    congr\n    . rw [hA]\n      ext y\n      simp [Set.mem_vadd_set]\n      constructor\n      . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n        have : x + z + -x ∈ G' := by simp [w]\n        use this\n        simp\n        convert hw\n      rintro ⟨ h, ha ⟩\n      use y + -x\n      constructor\n      . use h\n      abel\n    rw [hB]\n    ext x\n    simp [Set.mem_vadd_set]\n    constructor\n    . rintro ⟨ z, ⟨ ⟨ w, hw ⟩, rfl ⟩ ⟩\n      have : y + z + -y ∈ G' := by simp [w]\n      use this\n      simp\n      convert hw\n    rintro ⟨ h, ha ⟩\n    use x + -y\n    constructor\n    . use h\n    abel\n\n\n  refine ⟨ ?_, ?_, ?_, ?_, ?_, ?_ ⟩\n  . simp [hA', hf, hA'']\n  . simp [hB', hg, hB'']\n  . simp [hA''_non]\n  . simp [hB''_non]\n  . convert hcard_ineq using 2\n    . congr 3\n      . rw [hA', Nat.card_image_of_injective hf]\n      . rw [hB', Nat.card_image_of_injective hg]\n      . rw [Nat.card_image_of_injective hf]\n      rw [Nat.card_image_of_injective hg]\n  convert LE.le.trans _ hdim_ineq using 2\n  norm_cast\n  apply max_le_max\n  . exact dimension_of_shift A'' x\n  · exact dimension_of_shift B'' y\n\n/-- If $A,B\\subseteq \\mathbb{Z}^d$ are finite non-empty sets then there exist non-empty $A'\\subseteq A$ and $B'\\subseteq B$ such that\n\\[\\log\\frac{\\lvert A\\rvert\\lvert B\\rvert}{\\lvert A'\\rvert\\lvert B'\\rvert}\\leq 34 d[U_A;U_B]\\]\nsuch that $\\max(\\dim A',\\dim B')\\leq \\frac{40}{\\log 2} d[U_A;U_B]$. -/\nlemma weak_PFR_asymm (A B : Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) : WeakPFRAsymmConclusion A B  := by\n  let P : ℕ → Prop := fun M ↦ (∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M), WeakPFRAsymmConclusion A B)\n  suffices : ∀ M, (∀ M', M' < M → P M') → P M\n  . set M := (Nat.card A) + (Nat.card B)\n    have hM : (Nat.card A) + (Nat.card B) ≤ M := Nat.le_refl _\n    convert (Nat.strong_induction_on (p := P) M this) G ‹_› ‹_› ‹_› ‹_› _ ‹_› A B ‹_› ‹_› ‹_› ‹_› hM\n  intro M h_induct\n  -- wlog we can assume A, B are not in cosets of a smaller subgroup\n  suffices : ∀ (G : Type u) (hG_comm : AddCommGroup G) (_hG_free : Module.Free ℤ G) (_hG_fin : Module.Finite ℤ G) (_hG_count : Countable G) (hG_mes : MeasurableSpace G) (_hG_sing: MeasurableSingletonClass G) (A B: Set G) (_hA_fin: Finite A) (_hB_fin: Finite B) (_hA_non: A.Nonempty) (_hB_non: B.Nonempty) (_hM : (Nat.card A) + (Nat.card B) ≤ M) (_hnot: NotInCoset A B), WeakPFRAsymmConclusion A B\n  . intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM\n\n    obtain ⟨ G', A', B', hAA', hBB', hnot' ⟩ := wlog_notInCoset hA_non hB_non\n    have hG'_fin : Module.Finite ℤ G' :=\n      Module.Finite.iff_fg (N := AddSubgroup.toIntSubmodule G').2 (IsNoetherian.noetherian _)\n\n    have hG'_free : Module.Free ℤ G' := by\n      rcases Submodule.nonempty_basis_of_pid (Module.Free.chooseBasis ℤ G) (AddSubgroup.toIntSubmodule G') with ⟨ n, ⟨ b ⟩ ⟩\n      exact Module.Free.of_basis b\n    have hAA'_card: Nat.card A = Nat.card A' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hAA'.card_congr\n    have hBB'_card: Nat.card B = Nat.card B' := (Nat.card_image_of_injective Subtype.val_injective _) ▸ hBB'.card_congr\n    have hA_non' : Nonempty A := Set.nonempty_coe_sort.mpr hA_non\n    have hB_non' : Nonempty B := Set.nonempty_coe_sort.mpr hB_non\n\n    rw [hAA'_card, hBB'_card] at hM\n\n    have hA'_nonfin : A'.Nonempty ∧ Finite A' := by\n      have := Nat.card_pos (α := A)\n      rw [hAA'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    have hB'_nonfin : B'.Nonempty ∧ Finite B' := by\n      have := Nat.card_pos (α := B)\n      rw [hBB'_card, Nat.card_pos_iff] at this\n      exact ⟨@nonempty_of_nonempty_subtype _ _ this.1, this.2⟩\n    obtain ⟨ hA'_non, hA'_fin ⟩ := hA'_nonfin\n    obtain ⟨ hB'_non, hB'_fin ⟩ := hB'_nonfin\n\n    replace this := this G' _ hG'_free hG'_fin (by infer_instance) (by infer_instance) (by infer_instance) A' B' hA'_fin hB'_fin hA'_non hB'_non hM hnot'\n    exact conclusion_transfers G' A' B' hAA' hBB' hA'_non hB'_non this\n  intro G hG_comm hG_free hG_fin hG_count hG_mes hG_sing A B hA_fin hB_fin hA_non hB_non hM hnot\n  rcases weak_PFR_asymm_prelim A B hA_non hB_non with ⟨ N, x, y, Ax, By, hAx_non, hBy_non, hAx_fin, hBy_fin, hAx, hBy, hdim, hcard⟩\n  have hAxA : Ax ⊆ A := by rw [hAx]; simp\n  have hByB : By ⊆ B := by rw [hBy]; simp\n  have hA_pos : (0 : ℝ) < Nat.card A := Nat.cast_pos.mpr (@Nat.card_pos _ hA_non.to_subtype _)\n  have hB_pos : (0 : ℝ) < Nat.card B := Nat.cast_pos.mpr (@Nat.card_pos _ hB_non.to_subtype _)\n\n  rcases lt_or_ge (Nat.card Ax + Nat.card By) (Nat.card A + Nat.card B) with h | h\n  . replace h := h_induct (Nat.card Ax + Nat.card By) (h.trans_le hM) G hG_comm hG_free hG_fin hG_count hG_mes hG_sing Ax By (Set.finite_coe_iff.mpr hAx_fin) (Set.finite_coe_iff.mpr hBy_fin) hAx_non hBy_non (Eq.le rfl)\n    rcases h with ⟨ A', B', hA', hB', hA'_non, hB'_non, hcard_ineq, hdim_ineq ⟩\n    use A', B'\n    have hAx_fin' := Set.finite_coe_iff.mpr hAx_fin\n    have hBy_fin' := Set.finite_coe_iff.mpr hBy_fin\n    have hA'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hAx_fin hA')\n    have hB'_fin' := Set.finite_coe_iff.mpr (Set.Finite.subset hBy_fin hB')\n    have hAx_non' := Set.nonempty_coe_sort.mpr hAx_non\n    have hBy_non' := Set.nonempty_coe_sort.mpr hBy_non\n    have hA'_non' := Set.nonempty_coe_sort.mpr hA'_non\n    have hB'_non' := Set.nonempty_coe_sort.mpr hB'_non\n    have hAx_pos : (0 : ℝ) < Nat.card Ax := Nat.cast_pos.mpr Nat.card_pos\n    have hBy_pos : (0 : ℝ) < Nat.card By := Nat.cast_pos.mpr Nat.card_pos\n    have hA'_pos : (0 : ℝ) < Nat.card A' := Nat.cast_pos.mpr Nat.card_pos\n    have hB'_pos : (0 : ℝ) < Nat.card B' := Nat.cast_pos.mpr Nat.card_pos\n    have hAxA_le : (Nat.card Ax : ℝ) ≤ (Nat.card A : ℝ) := Nat.cast_le.mpr (Nat.card_mono A.toFinite hAxA)\n    have hByB_le : (Nat.card By : ℝ) ≤ (Nat.card B : ℝ) := Nat.cast_le.mpr (Nat.card_mono B.toFinite hByB)\n\n    refine ⟨ hA'.trans hAxA, hB'.trans hByB, hA'_non, hB'_non, ?_, ?_ ⟩\n    . rw [four_logs hA_pos hB_pos hA'_pos hB'_pos]\n      rw [four_logs hAx_pos hBy_pos hA'_pos hB'_pos] at hcard_ineq\n      linarith only [hcard, hcard_ineq]\n    apply hdim_ineq.trans\n    gcongr\n    linarith only [Real.log_le_log hAx_pos hAxA_le, Real.log_le_log hBy_pos hByB_le, hcard]\n  use A, B\n  refine ⟨ Eq.subset rfl, Eq.subset rfl, hA_non, hB_non, ?_, ?_ ⟩\n  . have := hA_non.to_subtype\n    have := hB_non.to_subtype\n    apply LE.le.trans _ <| mul_nonneg (by norm_num) <| rdist_set_nonneg A B\n    rw [div_self (by positivity)]\n    simp\n  have hAx_eq : Ax = A := by\n    apply Set.Finite.eq_of_subset_of_card_le A.toFinite hAxA\n    linarith only [h, Nat.card_mono B.toFinite hByB]\n  have hBy_eq : By = B := by\n    apply Set.Finite.eq_of_subset_of_card_le B.toFinite hByB\n    linarith only [h, Nat.card_mono A.toFinite hAxA]\n  have hN : N = ⊤ := by\n    have : (A-A) ∪ (B-B) ⊆ N := by\n      rw [← hAx_eq, ← hBy_eq, hAx, hBy]\n      intro z hz\n      simp [Set.mem_sub] at hz\n      convert (QuotientAddGroup.eq_zero_iff z).mp ?_\n      . infer_instance\n      rcases hz with ⟨ a, ⟨ -, ha⟩, a', ⟨-, ha'⟩, haa' ⟩ | ⟨ b, ⟨ -, hb⟩, b', ⟨ -,hb'⟩, hbb' ⟩\n      . rw [← haa']; simp [ha, ha']\n      rw [← hbb']; simp [hb, hb']\n    rw [← AddSubgroup.closure_le, hnot] at this\n    exact top_le_iff.mp this\n  have : Nat.card (G ⧸ N) = 1 := by\n    rw [Nat.card_eq_one_iff_unique]\n    constructor\n    . rw [hN]\n      exact  QuotientAddGroup.subsingleton_quotient_top\n    infer_instance\n  simp [this] at hdim\n  rw [← le_div_iff' (by positivity)] at hdim\n  convert LE.le.trans ?_ hdim using 1\n  . field_simp\n  simp\n  exact ⟨ dimension_le_rank A, dimension_le_rank B ⟩\n\n/-- If $A\\subseteq \\mathbb{Z}^d$ is a finite non-empty set with $d[U_A;U_A]\\leq \\log K$ then there exists a non-empty $A'\\subseteq A$ such that\n$\\lvert A'\\rvert\\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A'\\leq \\frac{40}{\\log 2} \\log K$. -/\nlemma weak_PFR {A : Set G} [Finite A] {K : ℝ} (hA : A.Nonempty) (hK: 0 < K) (hdist: dᵤ[A # A] ≤ log K):\n    ∃ A' : Set G, A' ⊆ A ∧ (Nat.card A') ≥ K^(-17 : ℝ) * (Nat.card A)\n    ∧ (dimension A') ≤ (40 / log 2) * log K := by\n  rcases weak_PFR_asymm A A hA hA with ⟨A', A'', hA', hA'', hA'nonempty, hA''nonempty, hcard, hdim⟩\n\n  have : ∃ B : Set G, B ⊆ A ∧ (Nat.card B) ≥ (Nat.card A') ∧ (Nat.card B) ≥ (Nat.card A'') ∧ (dimension B) ≤\nmax (dimension A') (dimension A'') := by\n    rcases lt_or_ge (Nat.card A') (Nat.card A'') with h | h\n    . use A''\n      exact ⟨hA'', by linarith, by linarith, le_max_right _ _⟩\n    use A'\n    exact ⟨hA', by linarith, by linarith, le_max_left _ _⟩\n\n  rcases this with ⟨B, hB, hBcard, hBcard', hBdim⟩\n  use B\n  have hApos : Nat.card A > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    exact ⟨hA.to_subtype, inferInstance⟩\n  have hA'pos : Nat.card A' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine ⟨ hA'nonempty.to_subtype, Finite.Set.subset _ hA' ⟩\n  have hA''pos : Nat.card A'' > 0 := by\n    rw [gt_iff_lt, Nat.card_pos_iff]\n    refine ⟨ hA''nonempty.to_subtype, Finite.Set.subset _ hA'' ⟩\n  have hBpos : Nat.card B > 0 := by linarith\n\n  refine ⟨hB, ?_, ?_⟩\n  . have := calc 2 * log ((Nat.card A) / (Nat.card B))\n      _ = log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card B) * (Nat.card B)) ) := by\n        convert (log_pow (((Nat.card A) : ℝ)/(Nat.card B)) 2).symm\n        field_simp\n        rw [← pow_two, ← pow_two]\n      _ ≤ log ( ((Nat.card A) * (Nat.card A)) / ((Nat.card A') * (Nat.card A'')) ) := by\n        apply log_le_log\n        . positivity\n        gcongr\n      _ ≤ 34 * dᵤ[A # A] := hcard\n      _ ≤ 34 * log K := mul_le_mul_of_nonneg_left hdist (by linarith)\n      _ = 2 * (17 * log K) := by ring\n      _ = 2 * log (K^17) := by\n        congr\n        convert (log_pow K 17).symm\n    rw [mul_le_mul_left (by norm_num), log_le_log_iff (by positivity) (by positivity), div_le_iff (by positivity), <- mul_inv_le_iff (by positivity), <-ge_iff_le, mul_comm] at this\n    convert this using 2\n    convert zpow_neg K 17 using 1\n    norm_cast\n  calc (dimension B : ℝ)\n    _ ≤ (((max (dimension A') (dimension A'')) : ℕ) : ℝ) := by norm_cast\n    _ ≤ (40 / log 2) * dᵤ[A # A] := hdim\n    _ ≤ (40 / log 2) * log K := mul_le_mul_of_nonneg_left hdist (by positivity)\n\n","proof":":= by\n  apply weak_PFR hnA hK ((rdist_set_le A A hnA hnA).trans _)\n  suffices log (Nat.card (A-A)) ≤ log K + log (Nat.card A) by linarith\n  rw [← log_mul (by positivity) _]\n  . apply log_le_log _ hA\n    norm_cast\n    have : Nonempty (A-A) := by\n      exact Set.Nonempty.coe_sort (Set.Nonempty.sub hnA hnA)\n    apply Nat.card_pos\n  norm_cast\n  apply ne_of_gt (@Nat.card_pos _ hnA.to_subtype _)","declId":"PFR.WeakPFR.1224_0.kVNJP4iHuXEJCsB","decl":"/-- Let $A\\subseteq \\mathbb{Z}^d$ and $\\lvert A-A\\rvert\\leq K\\lvert A\\rvert$.\nThere exists $A'\\subseteq A$ such that $\\lvert A'\\rvert \\geq K^{-17}\\lvert A\\rvert$\nand $\\dim A' \\leq \\frac{40}{\\log 2} \\log K$.-/\ntheorem weak_PFR_int {A : Set G} [Finite A] (hnA : A.Nonempty) {K : ℝ} (hK : 0 < K)\n    (hA: Nat.card (A-A) ≤ K * Nat.card A) :\n    ∃ A' : Set G, A' ⊆ A ∧ Nat.card A' ≥ K ^ (-17 : ℝ) * (Nat.card A) ∧\n      dimension A' ≤ (40 / log 2) * log K "}
