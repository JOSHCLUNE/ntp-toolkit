{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\n","proof":":=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous","declId":"PFR.Mathlib.Probability.ConditionalProbability.16_0.riYZeOofPOh6Ts4","decl":"lemma cond_absolutelyContinuous : μ[|s] ≪ μ "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n","proof":":= by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top","declId":"PFR.Mathlib.Probability.ConditionalProbability.19_0.riYZeOofPOh6Ts4","decl":"/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) := by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\n","proof":":= by\n  simp [cond, restrict_eq_zero.2 hμs]","declId":"PFR.Mathlib.Probability.ConditionalProbability.27_0.riYZeOofPOh6Ts4","decl":"lemma cond_eq_zero_of_measure_eq_zero (hμs : μ s = 0) : μ[|s] = 0 "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) := by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\nlemma cond_eq_zero_of_measure_eq_zero (hμs : μ s = 0) : μ[|s] = 0 := by\n  simp [cond, restrict_eq_zero.2 hμs]\n\n","proof":":= by simp [cond, hμs]","declId":"PFR.Mathlib.Probability.ConditionalProbability.30_0.riYZeOofPOh6Ts4","decl":"@[simp] lemma cond_eq_zero (hμs : μ s ≠ ⊤) : μ[|s] = 0 ↔ μ s = 0 "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) := by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\nlemma cond_eq_zero_of_measure_eq_zero (hμs : μ s = 0) : μ[|s] = 0 := by\n  simp [cond, restrict_eq_zero.2 hμs]\n\n@[simp] lemma cond_eq_zero (hμs : μ s ≠ ⊤) : μ[|s] = 0 ↔ μ s = 0 := by simp [cond, hμs]\n\n","proof":":= by\n  ext t ht\n  change μ (range i)ᶜ = 0 at hi'\n  rw [cond_apply, comap_apply, cond_apply, comap_apply, comap_apply, image_inter,\n    image_preimage_eq_inter_range, inter_right_comm, measure_inter_conull hi',\n    measure_inter_conull hi']\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hs\n  | exact ht\n  | exact hi.measurable hs\n  | exact (hi.measurable hs).inter ht","declId":"PFR.Mathlib.Probability.ConditionalProbability.32_0.riYZeOofPOh6Ts4","decl":"lemma comap_cond (hi : MeasurableEmbedding i) (hi' : ∀ᵐ ω ∂μ, ω ∈ range i) (hs : MeasurableSet s) :\n    comap i (μ[|s]) = (comap i μ)[|i ⁻¹' s] "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) := by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\nlemma cond_eq_zero_of_measure_eq_zero (hμs : μ s = 0) : μ[|s] = 0 := by\n  simp [cond, restrict_eq_zero.2 hμs]\n\n@[simp] lemma cond_eq_zero (hμs : μ s ≠ ⊤) : μ[|s] = 0 ↔ μ s = 0 := by simp [cond, hμs]\n\nlemma comap_cond (hi : MeasurableEmbedding i) (hi' : ∀ᵐ ω ∂μ, ω ∈ range i) (hs : MeasurableSet s) :\n    comap i (μ[|s]) = (comap i μ)[|i ⁻¹' s] := by\n  ext t ht\n  change μ (range i)ᶜ = 0 at hi'\n  rw [cond_apply, comap_apply, cond_apply, comap_apply, comap_apply, image_inter,\n    image_preimage_eq_inter_range, inter_right_comm, measure_inter_conull hi',\n    measure_inter_conull hi']\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hs\n  | exact ht\n  | exact hi.measurable hs\n  | exact (hi.measurable hs).inter ht\n\nvariable [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T]\n\n","proof":":= by\n  apply Measure.ext\n  intro E hE\n  simp only [Measure.coe_finset_sum, smul_toOuterMeasure, OuterMeasure.coe_smul, Finset.sum_apply,\n    Pi.smul_apply, smul_eq_mul]\n  have : μ E = ∑ y : T, μ (Y ⁻¹' {y} ∩ E) := by\n    have : E = ⋃ y ∈ Set.univ, Y ⁻¹' {y} ∩ E := by\n      simp; ext _; simp\n    nth_rewrite 1 [this]\n    convert measure_biUnion_finset _ _\n    . simp\n    · intro _ _ _ _ hyz\n      apply Disjoint.inf_left\n      apply Disjoint.inf_right\n      apply Disjoint.preimage\n      simp [hyz]\n    intro b _\n    exact MeasurableSet.inter (hY (MeasurableSet.singleton b)) hE\n  rw [this]\n  congr with y\n  rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n  . simp [hy]\n    exact measure_inter_null_of_null_left E hy\n  symm\n  rw [mul_comm, cond_mul_eq_inter _ (hY (MeasurableSet.singleton y)) hy]","declId":"PFR.Mathlib.Probability.ConditionalProbability.49_0.riYZeOofPOh6Ts4","decl":"/-- The law of total probability : a measure $\\mu$ can be expressed as a mixture of its conditional\nmeasures $\\mu[|Y^{-1}\\{y\\}]$ from a finitely valued random variable $Y$.-/\nlemma law_of_total_probability {Y : Ω → T} (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    μ = ∑ y, μ (Y ⁻¹' {y}) • (μ[|Y ← y]) "}
{"srcUpToDecl":"import Mathlib.Probability.ConditionalProbability\nimport Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen ENNReal MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators\n\nvariable {Ω Ω' α β γ : Type*} {m : MeasurableSpace Ω} [MeasurableSpace Ω'] {μ : Measure Ω}\n  {s t : Set Ω} {i : Ω' → Ω}\n\nnamespace ProbabilityTheory\n\n@[inherit_doc cond] -- TODO: Also tag the two existing notations\nscoped notation:60 μ \"[|\" T \" ← \" t \"]\" => μ[|T ⁻¹' {t}]\n\nlemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n/-- `μ[|s]` is always a finite measure. -/\ninstance cond_isFiniteMeasure : IsFiniteMeasure (μ[|s]) := by\n  constructor\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, MeasurableSet.univ,\n    Measure.restrict_apply, Set.univ_inter, smul_eq_mul, ProbabilityTheory.cond,\n    ← ENNReal.div_eq_inv_mul]\n  exact ENNReal.div_self_le_one.trans_lt ENNReal.one_lt_top\n\nlemma cond_eq_zero_of_measure_eq_zero (hμs : μ s = 0) : μ[|s] = 0 := by\n  simp [cond, restrict_eq_zero.2 hμs]\n\n@[simp] lemma cond_eq_zero (hμs : μ s ≠ ⊤) : μ[|s] = 0 ↔ μ s = 0 := by simp [cond, hμs]\n\nlemma comap_cond (hi : MeasurableEmbedding i) (hi' : ∀ᵐ ω ∂μ, ω ∈ range i) (hs : MeasurableSet s) :\n    comap i (μ[|s]) = (comap i μ)[|i ⁻¹' s] := by\n  ext t ht\n  change μ (range i)ᶜ = 0 at hi'\n  rw [cond_apply, comap_apply, cond_apply, comap_apply, comap_apply, image_inter,\n    image_preimage_eq_inter_range, inter_right_comm, measure_inter_conull hi',\n    measure_inter_conull hi']\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hs\n  | exact ht\n  | exact hi.measurable hs\n  | exact (hi.measurable hs).inter ht\n\nvariable [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T]\n\n/-- The law of total probability : a measure $\\mu$ can be expressed as a mixture of its conditional\nmeasures $\\mu[|Y^{-1}\\{y\\}]$ from a finitely valued random variable $Y$.-/\nlemma law_of_total_probability {Y : Ω → T} (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    μ = ∑ y, μ (Y ⁻¹' {y}) • (μ[|Y ← y]) := by\n  apply Measure.ext\n  intro E hE\n  simp only [Measure.coe_finset_sum, smul_toOuterMeasure, OuterMeasure.coe_smul, Finset.sum_apply,\n    Pi.smul_apply, smul_eq_mul]\n  have : μ E = ∑ y : T, μ (Y ⁻¹' {y} ∩ E) := by\n    have : E = ⋃ y ∈ Set.univ, Y ⁻¹' {y} ∩ E := by\n      simp; ext _; simp\n    nth_rewrite 1 [this]\n    convert measure_biUnion_finset _ _\n    . simp\n    · intro _ _ _ _ hyz\n      apply Disjoint.inf_left\n      apply Disjoint.inf_right\n      apply Disjoint.preimage\n      simp [hyz]\n    intro b _\n    exact MeasurableSet.inter (hY (MeasurableSet.singleton b)) hE\n  rw [this]\n  congr with y\n  rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n  . simp [hy]\n    exact measure_inter_null_of_null_left E hy\n  symm\n  rw [mul_comm, cond_mul_eq_inter _ (hY (MeasurableSet.singleton y)) hy]\n\n","proof":":= by finiteness) :\n    μ[|s][|t] = μ[|s ∩ t] := by\n  ext u\n  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]\n  rcases eq_or_ne (μ (s ∩ t)) 0 with hst|hst\n  · have : μ (s ∩ t ∩ u) = 0 :=\n      le_antisymm (le_trans (measure_mono (Set.inter_subset_left _ _)) hst.le) bot_le\n    simp [this, ← Set.inter_assoc]\n  · have hcs' : μ s ≠ 0 :=\n      (μ.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'\n    simp [*, hms.inter hmt, cond_apply, ← mul_assoc, ← Set.inter_assoc, ENNReal.mul_inv, mul_comm, ←\n      mul_assoc, ENNReal.mul_inv_cancel]","declId":"PFR.Mathlib.Probability.ConditionalProbability.78_0.riYZeOofPOh6Ts4","decl":"/-- Replace `cond_cond_eq_cond_inter'` in mathlib with this version, which removes a nonzero measure\nassumption-/\ntheorem cond_cond_eq_cond_inter'' (hms : MeasurableSet s) (hmt : MeasurableSet t)\n    (hcs : μ s ≠ ∞ "}
