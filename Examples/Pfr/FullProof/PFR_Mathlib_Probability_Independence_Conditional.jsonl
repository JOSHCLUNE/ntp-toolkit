{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n","proof":":= by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]","declId":"PFR.Mathlib.Probability.Independence.Conditional.17_0.A1CVKTdcshpEZA7","decl":"/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n","proof":":= by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]","declId":"PFR.Mathlib.Probability.Independence.Conditional.30_0.A1CVKTdcshpEZA7","decl":"/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n","proof":":=\n  (h.symm'.cond_left ht hB).symm'","declId":"PFR.Mathlib.Probability.Independence.Conditional.51_0.A1CVKTdcshpEZA7","decl":"/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n","proof":":= by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]","declId":"PFR.Mathlib.Probability.Independence.Conditional.58_0.A1CVKTdcshpEZA7","decl":"/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]\n\nend\n\nsection defs\nvariable {Ω Ω' α β γ : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω'] [MeasurableSpace α]\n  [MeasurableSpace β] [MeasurableSpace γ] {μ : Measure Ω} {f : Ω → α} {g : Ω → β} {h : Ω → γ}\n\n","proof":":= by volume_tac) : Prop :=\n  ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z])","declId":"PFR.Mathlib.Probability.Independence.Conditional.101_0.A1CVKTdcshpEZA7","decl":"/-- The assertion that `f` and `g` are conditionally independent relative to `h`. -/\ndef CondIndepFun (f : Ω → α) (g : Ω → β) (h : Ω → γ) (μ : Measure Ω "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]\n\nend\n\nsection defs\nvariable {Ω Ω' α β γ : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω'] [MeasurableSpace α]\n  [MeasurableSpace β] [MeasurableSpace γ] {μ : Measure Ω} {f : Ω → α} {g : Ω → β} {h : Ω → γ}\n\n/-- The assertion that `f` and `g` are conditionally independent relative to `h`. -/\ndef CondIndepFun (f : Ω → α) (g : Ω → β) (h : Ω → γ) (μ : Measure Ω := by volume_tac) : Prop :=\n  ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z])\n\n","proof":":= by rfl","declId":"PFR.Mathlib.Probability.Independence.Conditional.105_0.A1CVKTdcshpEZA7","decl":"lemma condIndepFun_iff : CondIndepFun f g h μ ↔ ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z]) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]\n\nend\n\nsection defs\nvariable {Ω Ω' α β γ : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω'] [MeasurableSpace α]\n  [MeasurableSpace β] [MeasurableSpace γ] {μ : Measure Ω} {f : Ω → α} {g : Ω → β} {h : Ω → γ}\n\n/-- The assertion that `f` and `g` are conditionally independent relative to `h`. -/\ndef CondIndepFun (f : Ω → α) (g : Ω → β) (h : Ω → γ) (μ : Measure Ω := by volume_tac) : Prop :=\n  ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z])\n\nlemma condIndepFun_iff : CondIndepFun f g h μ ↔ ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z]) := by rfl\n\nvariable [MeasurableSingletonClass γ]\n\n","proof":":= by\n  rw [condIndepFun_iff] at hfg ⊢\n  rw [← Measure.map_map hh hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n  refine hfg.mono $ fun c hc ↦ ?_\n  rw [preimage_comp, ← comap_cond hi hi' $ hh $ measurableSet_singleton _]\n  exact IndepFun.comp_right hi (cond_absolutelyContinuous.ae_le hi') hf hg hc","declId":"PFR.Mathlib.Probability.Independence.Conditional.109_0.A1CVKTdcshpEZA7","decl":"/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma CondIndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hh : Measurable h) (hfg : CondIndepFun f g h μ) :\n    CondIndepFun (f ∘ i) (g ∘ i) (h ∘ i) (μ.comap i) "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]\n\nend\n\nsection defs\nvariable {Ω Ω' α β γ : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω'] [MeasurableSpace α]\n  [MeasurableSpace β] [MeasurableSpace γ] {μ : Measure Ω} {f : Ω → α} {g : Ω → β} {h : Ω → γ}\n\n/-- The assertion that `f` and `g` are conditionally independent relative to `h`. -/\ndef CondIndepFun (f : Ω → α) (g : Ω → β) (h : Ω → γ) (μ : Measure Ω := by volume_tac) : Prop :=\n  ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z])\n\nlemma condIndepFun_iff : CondIndepFun f g h μ ↔ ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z]) := by rfl\n\nvariable [MeasurableSingletonClass γ]\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma CondIndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hh : Measurable h) (hfg : CondIndepFun f g h μ) :\n    CondIndepFun (f ∘ i) (g ∘ i) (h ∘ i) (μ.comap i) := by\n  rw [condIndepFun_iff] at hfg ⊢\n  rw [← Measure.map_map hh hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n  refine hfg.mono $ fun c hc ↦ ?_\n  rw [preimage_comp, ← comap_cond hi hi' $ hh $ measurableSet_singleton _]\n  exact IndepFun.comp_right hi (cond_absolutelyContinuous.ae_le hi') hf hg hc\n\nend defs\n\nsection copy\nuniverse u\nvariable {Ω : Type*} {α β : Type u} [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β]\n    [MeasurableSingletonClass β] [Fintype β]\n\nopen Function Set Measure\n\n","proof":":= by\n  let m' := fun (y : β) ↦ ((μ[|Y ← y]).map X)\n  let m := fun (y : β) ↦ ((m' y).prod (m' y)).prod (Measure.dirac y)\n  let ν : Measure ((α × α) × β) := ∑ y : β, ((μ (Y ⁻¹' {y})) • (m y))\n\n  have h3' (y : β) : { ω : Ω | Y ω = y } ∈ ae (μ[|Y ← y]) := by\n    rw [mem_ae_iff, ← cond_inter_self]\n    . have : (Y ⁻¹' {y}) ∩ { ω : Ω | Y ω = y }ᶜ = ∅ := by\n        ext _; simp\n      simp [this]\n    exact hY $ measurableSet_discrete _\n\n  have h3 (y : β) : IdentDistrib (fun ω ↦ (X ω, y)) (⟨X, Y⟩) (μ[|Y ← y]) (μ[|Y ← y]) := by\n    apply IdentDistrib.of_ae_eq (hX.prod_mk measurable_const).aemeasurable\n    apply Filter.eventuallyEq_of_mem (h3' y)\n    intro ω; simp; exact fun a ↦ id a.symm\n\n  have h4 (y : β) : { ω : (α × α) × β| ω.2 = y } ∈ ae (m y) := by\n    rw [mem_ae_iff]\n    have : { ω : (α × α) × β | ω.2 = y}ᶜ = Prod.snd⁻¹' {t : β | t ≠ y} := by simp; rfl\n    rw [this, ← Measure.map_apply measurable_snd (measurableSet_discrete _)]\n    simp\n\n  have h5 {y : β} (hy : μ (Y ⁻¹' {y}) ≠ 0) : IsProbabilityMeasure (m' y) := by\n    have : IsProbabilityMeasure (μ[|Y ← y]) := cond_isProbabilityMeasure μ hy\n    exact isProbabilityMeasure_map hX.aemeasurable\n\n  refine ⟨(α × α) × β, by infer_instance, fun ω ↦ ω.1.1, fun ω ↦ ω.1.2, fun ω ↦ ω.2, ν, ?_, measurable_fst.comp measurable_fst, measurable_snd.comp measurable_fst, measurable_snd, ?_, ?_, ?_⟩\n  . constructor\n    simp\n    have : ∑ y : β, μ (Y ⁻¹' {y})*1 = 1 := by\n      simp\n      rw [sum_measure_preimage_singleton] <;>\n        simp [hY $ measurableSet_discrete _, measure_ne_top]\n    rw [← this]\n    congr with y\n    rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n    . simp [hy]\n    congr 1\n    have : IsProbabilityMeasure (m' y) := h5 hy\n    simp\n  . rw [condIndepFun_iff, ae_iff_of_countable ]\n    have h1 : ν.map Prod.snd = μ.map Y := by\n      rw [law_of_total_probability hY μ, ← Measure.mapₗ_apply_of_measurable measurable_snd, ← Measure.mapₗ_apply_of_measurable hY]\n      simp\n      congr with y\n      rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n      . simp [hy]\n      have h6 : IsProbabilityMeasure (m' y) := h5 hy\n      have h7 : IsProbabilityMeasure (μ[|Y ← y]) := cond_isProbabilityMeasure μ hy\n      congr 3\n      rw [Measure.mapₗ_apply_of_measurable measurable_snd, Measure.mapₗ_apply_of_measurable hY]\n      simp\n      have := (μ[|Y ← y]).map_const y\n      simp at this; rw [← this]\n      apply Measure.map_congr\n      apply Filter.eventuallyEq_of_mem (h3' y)\n      intro ω; simp; exact fun a ↦ id a.symm\n    intro y hy\n    have hy' : ν (Prod.snd⁻¹' {y}) = μ (Y ⁻¹' {y}) := by\n      rw [← map_apply measurable_snd (by simp), ← map_apply hY $ measurableSet_discrete _, h1]\n    rw [h1] at hy\n    have hy'' : μ (Y ⁻¹' {y}) ≠ 0 := by\n      convert hy\n      exact (map_apply hY $ measurableSet_discrete _).symm\n\n    have h2 : ν[| Prod.snd⁻¹' {y}] = m y := by\n      rw [Measure.ext_iff]\n      intro E _\n      rw [cond_apply ν (measurable_snd (by simp)) E, hy']\n      simp\n      have h3 : (m y) ((Prod.snd⁻¹' {y}) ∩ E) = (m y) E := by\n        apply measure_congr\n        apply inter_ae_eq_right_of_ae_eq_univ\n        simp\n        rw [(show (Prod.snd⁻¹' {y})ᶜ = Prod.snd⁻¹' ({y}ᶜ) by rfl), ← map_apply measurable_snd (by simp)]\n        simp\n      have h3' {x : β} (hx : x ≠ y) : (m x) ((Prod.snd⁻¹' {y}) ∩ E) = 0 := by\n        apply measure_inter_null_of_null_left E\n        rw [← Measure.map_apply measurable_snd (by simp), MeasureTheory.Measure.map_snd_prod]\n        simp; right; exact hx\n      rw [Finset.sum_eq_single_of_mem y (Finset.mem_univ y)]\n      . rw [h3, ← mul_assoc, ENNReal.inv_mul_cancel hy'', one_mul]\n        finiteness\n      intro x _ hx\n      rw [h3' hx]\n      simp\n    rw [h2, indepFun_iff_map_prod_eq_prod_map_map]\n    . let f : (α × α) × β → α × α := Prod.fst\n      show ((m y).map f) = ((m y).map (Prod.fst ∘ f)).prod ((m y).map (Prod.snd ∘ f))\n      have : IsProbabilityMeasure (m' y) := h5 hy''\n      have : (m y).map f = (m' y).prod (m' y) := by simp\n      rw [← map_map measurable_fst measurable_fst, ← map_map measurable_snd measurable_fst, this]\n      simp\n    . exact (measurable_fst.comp measurable_fst).aemeasurable\n    exact (measurable_snd.comp measurable_fst).aemeasurable\n  . rw [law_of_total_probability hY μ]\n    apply identDistrib_of_sum ((measurable_fst.comp measurable_fst).prod_mk measurable_snd) (hX.prod_mk hY)\n    intro y hy\n    have h1 : IdentDistrib (fun ω ↦ (ω.1.1, ω.2)) (fun ω ↦ (ω.1.1, y)) (m y) (m y) := by\n      apply IdentDistrib.of_ae_eq ((measurable_fst.comp measurable_fst).prod_mk measurable_snd).aemeasurable\n      apply Filter.eventuallyEq_of_mem (h4 y)\n      intro _; simp\n    have h2 : IdentDistrib (fun ω ↦ (ω.1.1, y)) (fun ω ↦ (X ω, y)) (m y) (μ[|Y ← y]) := by\n      let f := fun (x : α) ↦ (x, y)\n      show IdentDistrib (f ∘ (Prod.fst ∘ Prod.fst)) (f ∘ X) (m y) (μ[|Y ← y])\n      apply IdentDistrib.comp _ measurable_prod_mk_right\n      apply (identDistrib_comp_fst measurable_fst _ _).trans\n      have : IsProbabilityMeasure ((μ[|Y ← y]).map X) := h5 hy\n      apply (identDistrib_comp_fst measurable_id _ _).trans\n      apply identDistrib_map hX measurable_id\n    exact (h1.trans h2).trans (h3 y)\n  rw [law_of_total_probability hY μ]\n  apply identDistrib_of_sum ((measurable_snd.comp measurable_fst).prod_mk measurable_snd) (hX.prod_mk hY)\n  intro y hy\n  have h1 : IdentDistrib (fun ω ↦ (ω.1.2, ω.2)) (fun ω ↦ (ω.1.2, y)) (m y) (m y) := by\n    apply IdentDistrib.of_ae_eq ((measurable_snd.comp measurable_fst).prod_mk measurable_snd).aemeasurable\n    apply Filter.eventuallyEq_of_mem (h4 y)\n    intro _; simp\n  have h2 : IdentDistrib (fun ω ↦ (ω.1.2, y)) (fun ω ↦ (X ω, y)) (m y) (μ[|Y ← y]) := by\n    let f := fun (x : α) ↦ (x, y)\n    show IdentDistrib (f ∘ (Prod.snd ∘ Prod.fst)) (f ∘ X) (m y) (μ[|Y ← y])\n    apply IdentDistrib.comp _ measurable_prod_mk_right\n    apply (identDistrib_comp_fst measurable_snd _ _).trans\n    have : IsProbabilityMeasure ((μ[|Y ← y]).map X) := h5 hy\n    apply (identDistrib_comp_snd measurable_id _ _).trans\n    apply identDistrib_map hX measurable_id\n  exact (h1.trans h2).trans (h3 y)","declId":"PFR.Mathlib.Probability.Independence.Conditional.129_0.A1CVKTdcshpEZA7","decl":"/-- For $X, Y$ random variables, there exist conditionally independent trials $X_1, X_2, Y'$. -/\nlemma condIndep_copies (X : Ω → α) (Y : Ω → β) (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    ∃ (Ω' : Type u) (mΩ' : MeasurableSpace Ω') (X₁ X₂ : Ω' → α) (Y' : Ω' → β) (ν : Measure Ω'),\n      IsProbabilityMeasure ν ∧ Measurable X₁ ∧ Measurable X₂ ∧ Measurable Y' ∧\n      CondIndepFun X₁ X₂ Y' ν ∧ IdentDistrib (⟨X₁, Y'⟩) (⟨X, Y⟩) ν μ ∧\n      IdentDistrib (⟨X₂, Y'⟩) (⟨X, Y⟩) ν μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Pair\nimport PFR.Mathlib.Data.Set.Image\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.IdentDistrib\nimport PFR.Tactic.Finiteness\n\nopen MeasureTheory Measure Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\n\nsection\n\nvariable {Ω α β : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n  {μ : Measure Ω} {A : Ω → α} {B : Ω → β}\n\n/-- If `A` is independent from `B`, then conditioning on an event given by `B` does not change\nthe distribution of `A`. -/\ntheorem IndepFun.identDistrib_cond [IsProbabilityMeasure μ]\n    (hi : IndepFun A B μ) {s : Set β}\n    (hs : MeasurableSet s) (hA : Measurable A) (hB : Measurable B)\n    (h : μ (B ⁻¹' s) ≠ 0) :\n    IdentDistrib A A μ (μ[|B ⁻¹' s]) := by\n  refine ⟨hA.aemeasurable, hA.aemeasurable, ?_⟩\n  ext t ht\n  rw [Measure.map_apply hA ht, Measure.map_apply hA ht, cond_apply _ (hB hs), Set.inter_comm,\n    hi.measure_inter_preimage_eq_mul ht hs, mul_comm, mul_assoc,\n    ENNReal.mul_inv_cancel h (by finiteness), mul_one]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s` of positive probability. -/\nlemma IndepFun.cond_left (hi : IndepFun A B μ) {s : Set α}\n    (hs : MeasurableSet s) (hA : Measurable A) :\n    IndepFun A B (μ[| A⁻¹' s]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have : A ⁻¹' s ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' v := by aesop\n  simp only [cond_apply _ (hA hs), this]\n  rcases eq_or_ne (μ (A ⁻¹' s)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' v) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact (inter_subset_left _ _).trans (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' s ∩ B ⁻¹' v) = 0 :=\n      le_antisymm ((measure_mono (inter_subset_left _ _)).trans h'.le) bot_le\n    simp only [I, J, mul_zero]\n  · rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) hv, Set.preimage_inter,\n      hi.measure_inter_preimage_eq_mul hs hv, ← mul_assoc (μ (A ⁻¹' s))⁻¹,\n      ← mul_assoc (μ (A ⁻¹' s))⁻¹, ENNReal.inv_mul_cancel h' h, one_mul]\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `B ∈ t` of positive probability. -/\nlemma IndepFun.cond_right (h : IndepFun A B μ) {t : Set β}\n    (ht : MeasurableSet t) (hB : Measurable B) :\n    IndepFun A B (μ[| B⁻¹' t]) :=\n  (h.symm'.cond_left ht hB).symm'\n\n/-- If `A` is independent of `B`, then they remain independent when conditioning on an event\nof the form `A ∈ s ∩ B ∈ t` of positive probability. -/\nlemma IndepFun.cond (hi : IndepFun A B μ) {s : Set α} {t : Set β}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hA : Measurable A) (hB : Measurable B) :\n    IndepFun A B (μ[| A ⁻¹' s ∩ B ⁻¹' t]) := by\n  apply indepFun_iff_measure_inter_preimage_eq_mul.2 (fun u v hu hv ↦ ?_)\n  have I1 : A ⁻¹' s ∩ B ⁻¹' t ∩ (A ⁻¹' u ∩ B ⁻¹' v) = A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v) := by aesop\n  have I2 : A ⁻¹' s ∩ B ⁻¹' t ∩ A ⁻¹' u = A ⁻¹' (s ∩ u) ∩ B ⁻¹' t := by aesop\n  have I3 : A ⁻¹' s ∩ B ⁻¹' t ∩ B ⁻¹' v = A ⁻¹' s ∩ B ⁻¹' (t ∩ v) := by aesop\n  simp only [cond_apply _ ((hA hs).inter (hB ht)), I1, I2, I3]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) ∞ with h|h\n  · simp [h]\n  rcases eq_or_ne (μ (A ⁻¹' s ∩ B⁻¹' t)) 0 with h'|h'\n  · have I : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' (t ∩ v)) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter (preimage_mono (inter_subset_left _ _))\n        (preimage_mono (inter_subset_left _ _))\n    have J : μ (A ⁻¹' (s ∩ u) ∩ B ⁻¹' t) = 0 := by\n      apply le_antisymm ((measure_mono _).trans h'.le) bot_le\n      exact inter_subset_inter_left _ (preimage_mono (inter_subset_left _ _))\n    simp only [I, J, mul_zero, zero_mul]\n  · simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, mul_eq_zero, not_or] at h'\n    simp only [hi.measure_inter_preimage_eq_mul hs ht, ne_eq, ENNReal.mul_eq_top, h'.1,\n      not_false_eq_true, true_and, h'.2, and_true, not_or] at h\n    rw [mul_assoc]\n    congr 1\n    rw [hi.measure_inter_preimage_eq_mul (hs.inter hu) (ht.inter hv),\n      hi.measure_inter_preimage_eq_mul (hs.inter hu) ht,\n      hi.measure_inter_preimage_eq_mul hs ht,\n      hi.measure_inter_preimage_eq_mul hs (ht.inter hv),\n      ENNReal.mul_inv (Or.inl h'.1) (Or.inr h'.2), mul_assoc]\n    congr 1\n    have : μ (B ⁻¹' t) * ((μ (A ⁻¹' s))⁻¹ * (μ (B ⁻¹' t))⁻¹ * (μ (A ⁻¹' s) * μ (B ⁻¹' (t ∩ v))))\n      = (μ (B ⁻¹' t) * (μ (B ⁻¹' t))⁻¹) * ((μ (A ⁻¹' s))⁻¹ * μ (A ⁻¹' s)) * μ (B ⁻¹' (t ∩ v)) := by\n        ring\n    rw [this, ENNReal.inv_mul_cancel h'.1 h.2, ENNReal.mul_inv_cancel h'.2 h.1, one_mul, one_mul]\n\nend\n\nsection defs\nvariable {Ω Ω' α β γ : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω'] [MeasurableSpace α]\n  [MeasurableSpace β] [MeasurableSpace γ] {μ : Measure Ω} {f : Ω → α} {g : Ω → β} {h : Ω → γ}\n\n/-- The assertion that `f` and `g` are conditionally independent relative to `h`. -/\ndef CondIndepFun (f : Ω → α) (g : Ω → β) (h : Ω → γ) (μ : Measure Ω := by volume_tac) : Prop :=\n  ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z])\n\nlemma condIndepFun_iff : CondIndepFun f g h μ ↔ ∀ᵐ z ∂ (μ.map h), IndepFun f g (μ[|h ← z]) := by rfl\n\nvariable [MeasurableSingletonClass γ]\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma CondIndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hh : Measurable h) (hfg : CondIndepFun f g h μ) :\n    CondIndepFun (f ∘ i) (g ∘ i) (h ∘ i) (μ.comap i) := by\n  rw [condIndepFun_iff] at hfg ⊢\n  rw [← Measure.map_map hh hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n  refine hfg.mono $ fun c hc ↦ ?_\n  rw [preimage_comp, ← comap_cond hi hi' $ hh $ measurableSet_singleton _]\n  exact IndepFun.comp_right hi (cond_absolutelyContinuous.ae_le hi') hf hg hc\n\nend defs\n\nsection copy\nuniverse u\nvariable {Ω : Type*} {α β : Type u} [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β]\n    [MeasurableSingletonClass β] [Fintype β]\n\nopen Function Set Measure\n\n/-- For $X, Y$ random variables, there exist conditionally independent trials $X_1, X_2, Y'$. -/\nlemma condIndep_copies (X : Ω → α) (Y : Ω → β) (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    ∃ (Ω' : Type u) (mΩ' : MeasurableSpace Ω') (X₁ X₂ : Ω' → α) (Y' : Ω' → β) (ν : Measure Ω'),\n      IsProbabilityMeasure ν ∧ Measurable X₁ ∧ Measurable X₂ ∧ Measurable Y' ∧\n      CondIndepFun X₁ X₂ Y' ν ∧ IdentDistrib (⟨X₁, Y'⟩) (⟨X, Y⟩) ν μ ∧\n      IdentDistrib (⟨X₂, Y'⟩) (⟨X, Y⟩) ν μ := by\n  let m' := fun (y : β) ↦ ((μ[|Y ← y]).map X)\n  let m := fun (y : β) ↦ ((m' y).prod (m' y)).prod (Measure.dirac y)\n  let ν : Measure ((α × α) × β) := ∑ y : β, ((μ (Y ⁻¹' {y})) • (m y))\n\n  have h3' (y : β) : { ω : Ω | Y ω = y } ∈ ae (μ[|Y ← y]) := by\n    rw [mem_ae_iff, ← cond_inter_self]\n    . have : (Y ⁻¹' {y}) ∩ { ω : Ω | Y ω = y }ᶜ = ∅ := by\n        ext _; simp\n      simp [this]\n    exact hY $ measurableSet_discrete _\n\n  have h3 (y : β) : IdentDistrib (fun ω ↦ (X ω, y)) (⟨X, Y⟩) (μ[|Y ← y]) (μ[|Y ← y]) := by\n    apply IdentDistrib.of_ae_eq (hX.prod_mk measurable_const).aemeasurable\n    apply Filter.eventuallyEq_of_mem (h3' y)\n    intro ω; simp; exact fun a ↦ id a.symm\n\n  have h4 (y : β) : { ω : (α × α) × β| ω.2 = y } ∈ ae (m y) := by\n    rw [mem_ae_iff]\n    have : { ω : (α × α) × β | ω.2 = y}ᶜ = Prod.snd⁻¹' {t : β | t ≠ y} := by simp; rfl\n    rw [this, ← Measure.map_apply measurable_snd (measurableSet_discrete _)]\n    simp\n\n  have h5 {y : β} (hy : μ (Y ⁻¹' {y}) ≠ 0) : IsProbabilityMeasure (m' y) := by\n    have : IsProbabilityMeasure (μ[|Y ← y]) := cond_isProbabilityMeasure μ hy\n    exact isProbabilityMeasure_map hX.aemeasurable\n\n  refine ⟨(α × α) × β, by infer_instance, fun ω ↦ ω.1.1, fun ω ↦ ω.1.2, fun ω ↦ ω.2, ν, ?_, measurable_fst.comp measurable_fst, measurable_snd.comp measurable_fst, measurable_snd, ?_, ?_, ?_⟩\n  . constructor\n    simp\n    have : ∑ y : β, μ (Y ⁻¹' {y})*1 = 1 := by\n      simp\n      rw [sum_measure_preimage_singleton] <;>\n        simp [hY $ measurableSet_discrete _, measure_ne_top]\n    rw [← this]\n    congr with y\n    rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n    . simp [hy]\n    congr 1\n    have : IsProbabilityMeasure (m' y) := h5 hy\n    simp\n  . rw [condIndepFun_iff, ae_iff_of_countable ]\n    have h1 : ν.map Prod.snd = μ.map Y := by\n      rw [law_of_total_probability hY μ, ← Measure.mapₗ_apply_of_measurable measurable_snd, ← Measure.mapₗ_apply_of_measurable hY]\n      simp\n      congr with y\n      rcases eq_or_ne (μ (Y ⁻¹' {y})) 0 with hy | hy\n      . simp [hy]\n      have h6 : IsProbabilityMeasure (m' y) := h5 hy\n      have h7 : IsProbabilityMeasure (μ[|Y ← y]) := cond_isProbabilityMeasure μ hy\n      congr 3\n      rw [Measure.mapₗ_apply_of_measurable measurable_snd, Measure.mapₗ_apply_of_measurable hY]\n      simp\n      have := (μ[|Y ← y]).map_const y\n      simp at this; rw [← this]\n      apply Measure.map_congr\n      apply Filter.eventuallyEq_of_mem (h3' y)\n      intro ω; simp; exact fun a ↦ id a.symm\n    intro y hy\n    have hy' : ν (Prod.snd⁻¹' {y}) = μ (Y ⁻¹' {y}) := by\n      rw [← map_apply measurable_snd (by simp), ← map_apply hY $ measurableSet_discrete _, h1]\n    rw [h1] at hy\n    have hy'' : μ (Y ⁻¹' {y}) ≠ 0 := by\n      convert hy\n      exact (map_apply hY $ measurableSet_discrete _).symm\n\n    have h2 : ν[| Prod.snd⁻¹' {y}] = m y := by\n      rw [Measure.ext_iff]\n      intro E _\n      rw [cond_apply ν (measurable_snd (by simp)) E, hy']\n      simp\n      have h3 : (m y) ((Prod.snd⁻¹' {y}) ∩ E) = (m y) E := by\n        apply measure_congr\n        apply inter_ae_eq_right_of_ae_eq_univ\n        simp\n        rw [(show (Prod.snd⁻¹' {y})ᶜ = Prod.snd⁻¹' ({y}ᶜ) by rfl), ← map_apply measurable_snd (by simp)]\n        simp\n      have h3' {x : β} (hx : x ≠ y) : (m x) ((Prod.snd⁻¹' {y}) ∩ E) = 0 := by\n        apply measure_inter_null_of_null_left E\n        rw [← Measure.map_apply measurable_snd (by simp), MeasureTheory.Measure.map_snd_prod]\n        simp; right; exact hx\n      rw [Finset.sum_eq_single_of_mem y (Finset.mem_univ y)]\n      . rw [h3, ← mul_assoc, ENNReal.inv_mul_cancel hy'', one_mul]\n        finiteness\n      intro x _ hx\n      rw [h3' hx]\n      simp\n    rw [h2, indepFun_iff_map_prod_eq_prod_map_map]\n    . let f : (α × α) × β → α × α := Prod.fst\n      show ((m y).map f) = ((m y).map (Prod.fst ∘ f)).prod ((m y).map (Prod.snd ∘ f))\n      have : IsProbabilityMeasure (m' y) := h5 hy''\n      have : (m y).map f = (m' y).prod (m' y) := by simp\n      rw [← map_map measurable_fst measurable_fst, ← map_map measurable_snd measurable_fst, this]\n      simp\n    . exact (measurable_fst.comp measurable_fst).aemeasurable\n    exact (measurable_snd.comp measurable_fst).aemeasurable\n  . rw [law_of_total_probability hY μ]\n    apply identDistrib_of_sum ((measurable_fst.comp measurable_fst).prod_mk measurable_snd) (hX.prod_mk hY)\n    intro y hy\n    have h1 : IdentDistrib (fun ω ↦ (ω.1.1, ω.2)) (fun ω ↦ (ω.1.1, y)) (m y) (m y) := by\n      apply IdentDistrib.of_ae_eq ((measurable_fst.comp measurable_fst).prod_mk measurable_snd).aemeasurable\n      apply Filter.eventuallyEq_of_mem (h4 y)\n      intro _; simp\n    have h2 : IdentDistrib (fun ω ↦ (ω.1.1, y)) (fun ω ↦ (X ω, y)) (m y) (μ[|Y ← y]) := by\n      let f := fun (x : α) ↦ (x, y)\n      show IdentDistrib (f ∘ (Prod.fst ∘ Prod.fst)) (f ∘ X) (m y) (μ[|Y ← y])\n      apply IdentDistrib.comp _ measurable_prod_mk_right\n      apply (identDistrib_comp_fst measurable_fst _ _).trans\n      have : IsProbabilityMeasure ((μ[|Y ← y]).map X) := h5 hy\n      apply (identDistrib_comp_fst measurable_id _ _).trans\n      apply identDistrib_map hX measurable_id\n    exact (h1.trans h2).trans (h3 y)\n  rw [law_of_total_probability hY μ]\n  apply identDistrib_of_sum ((measurable_snd.comp measurable_fst).prod_mk measurable_snd) (hX.prod_mk hY)\n  intro y hy\n  have h1 : IdentDistrib (fun ω ↦ (ω.1.2, ω.2)) (fun ω ↦ (ω.1.2, y)) (m y) (m y) := by\n    apply IdentDistrib.of_ae_eq ((measurable_snd.comp measurable_fst).prod_mk measurable_snd).aemeasurable\n    apply Filter.eventuallyEq_of_mem (h4 y)\n    intro _; simp\n  have h2 : IdentDistrib (fun ω ↦ (ω.1.2, y)) (fun ω ↦ (X ω, y)) (m y) (μ[|Y ← y]) := by\n    let f := fun (x : α) ↦ (x, y)\n    show IdentDistrib (f ∘ (Prod.snd ∘ Prod.fst)) (f ∘ X) (m y) (μ[|Y ← y])\n    apply IdentDistrib.comp _ measurable_prod_mk_right\n    apply (identDistrib_comp_fst measurable_snd _ _).trans\n    have : IsProbabilityMeasure ((μ[|Y ← y]).map X) := h5 hy\n    apply (identDistrib_comp_snd measurable_id _ _).trans\n    apply identDistrib_map hX measurable_id\n  exact (h1.trans h2).trans (h3 y)\n\n","proof":":= by\n  obtain ⟨Ω', _, X₁, X₂, Y', ν, _, hX₁, hX₂, hY', hXY, hXY₁, hXY₂⟩ :=\n    condIndep_copies X Y hX hY μ\n  let i := Subtype.val (p := fun ω ↦ p (X₁ ω) (Y' ω) ∧ p (X₂ ω) (Y' ω))\n  have hi : MeasurableEmbedding i := MeasurableEmbedding.subtype_coe\n    ((hp.comp $ hX₁.prod_mk hY').and $ hp.comp $ hX₂.prod_mk hY').setOf\n  have hi' : ∀ᵐ ω ∂ν, ω ∈ range i\n  · simp only [mem_setOf_eq, Subtype.range_coe_subtype, Filter.eventually_and]\n    exact ⟨hXY₁.symm.ae_snd (p := uncurry p) hp.setOf hp',\n      hXY₂.symm.ae_snd (p := uncurry p) hp.setOf hp'⟩\n  refine ⟨{ω // p (X₁ ω) (Y' ω) ∧ p (X₂ ω) (Y' ω)}, inferInstance, X₁ ∘ (↑), X₂ ∘ (↑), Y' ∘ (↑),\n    ν.comap (↑), ?_, hX₁.comp measurable_subtype_coe, hX₂.comp measurable_subtype_coe,\n    hY'.comp measurable_subtype_coe, ?_, ?_, ?_, fun ω ↦ ω.2.1, fun ω ↦ ω.2.2⟩\n  · exact hi.isProbabilityMeasure_comap hi'\n  · exact hXY.comp_right hi hi' hX₁ hX₂ hY'\n  · exact hXY₁.comp_left hi hi' $ hX₁.prod_mk hY'\n  · exact hXY₂.comp_left hi hi' $ hX₂.prod_mk hY'","declId":"PFR.Mathlib.Probability.Independence.Conditional.264_0.A1CVKTdcshpEZA7","decl":"/-- For $X, Y$ random variables, there exist conditionally independent trials $X_1, X_2, Y'$. -/\nlemma condIndep_copies' (X : Ω → α) (Y : Ω → β) (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsProbabilityMeasure μ] (p : α → β → Prop) (hp : Measurable (uncurry p))\n    (hp' : ∀ᵐ ω ∂μ, p (X ω) (Y ω)) :\n    ∃ (Ω' : Type u) (mΩ' : MeasurableSpace Ω') (X₁ X₂ : Ω' → α) (Y' : Ω' → β) (ν : Measure Ω'),\n      IsProbabilityMeasure ν ∧ Measurable X₁ ∧ Measurable X₂ ∧ Measurable Y' ∧\n      CondIndepFun X₁ X₂ Y' ν ∧ IdentDistrib (⟨X₁, Y'⟩) (⟨X, Y⟩) ν μ ∧\n       IdentDistrib (⟨X₂, Y'⟩) (⟨X, Y⟩) ν μ ∧ (∀ ω, p (X₁ ω) (Y' ω)) ∧ (∀ ω, p (X₂ ω) (Y' ω)) "}
