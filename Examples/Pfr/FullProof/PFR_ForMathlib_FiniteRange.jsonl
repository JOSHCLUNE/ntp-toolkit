{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n","proof":":= hX.finite.fintype","declId":"PFR.ForMathlib.FiniteRange.14_0.UebCMBHooLRWAeW","decl":"/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n","proof":":=\n    @Set.toFinset _ _ hX.fintype","declId":"PFR.ForMathlib.FiniteRange.18_0.UebCMBHooLRWAeW","decl":"/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n","proof":":= Set.toFinite (Set.range X)","declId":"PFR.ForMathlib.FiniteRange.22_0.UebCMBHooLRWAeW","decl":"/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\n","proof":":= by infer_instance","declId":"PFR.ForMathlib.FiniteRange.26_0.UebCMBHooLRWAeW","decl":"example {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n","proof":":= by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω","declId":"PFR.ForMathlib.FiniteRange.28_0.UebCMBHooLRWAeW","decl":"/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\n","proof":":= by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm","declId":"PFR.ForMathlib.FiniteRange.37_0.UebCMBHooLRWAeW","decl":"lemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\n","proof":":= by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp","declId":"PFR.ForMathlib.FiniteRange.42_0.UebCMBHooLRWAeW","decl":"lemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n","proof":":= by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp","declId":"PFR.ForMathlib.FiniteRange.47_0.UebCMBHooLRWAeW","decl":"@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n","proof":":= by\n  apply finiteRange_of_finset _ { c }\n  simp","declId":"PFR.ForMathlib.FiniteRange.52_0.UebCMBHooLRWAeW","decl":"/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n","proof":":= by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite","declId":"PFR.ForMathlib.FiniteRange.57_0.UebCMBHooLRWAeW","decl":"/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n","proof":":= by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)","declId":"PFR.ForMathlib.FiniteRange.63_0.UebCMBHooLRWAeW","decl":"/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n","proof":":= by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this","declId":"PFR.ForMathlib.FiniteRange.69_0.UebCMBHooLRWAeW","decl":"/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n","proof":":= by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance","declId":"PFR.ForMathlib.FiniteRange.80_0.UebCMBHooLRWAeW","decl":"/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) := by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n","proof":":= by\n  show FiniteRange ((fun p ↦ p.1 / p.2) ∘ ⟨X, Y⟩)\n  infer_instance","declId":"PFR.ForMathlib.FiniteRange.87_0.UebCMBHooLRWAeW","decl":"/-- The quotient of two functions with finite range, has finite range. -/\n@[to_additive \"The difference of functions of finite range, has finite range.\"]\ninstance FiniteRange.div {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X/Y) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) := by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The quotient of two functions with finite range, has finite range. -/\n@[to_additive \"The difference of functions of finite range, has finite range.\"]\ninstance FiniteRange.div {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X/Y) := by\n  show FiniteRange ((fun p ↦ p.1 / p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n","proof":":= by\n  show FiniteRange ((fun p ↦ p⁻¹) ∘ X)\n  infer_instance","declId":"PFR.ForMathlib.FiniteRange.94_0.UebCMBHooLRWAeW","decl":"/-- The inverse of a function of finite range, has finite range.-/\n@[to_additive \"The negation of a function of finite range, has finite range.\"]\ninstance FiniteRange.inv {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] :\n    FiniteRange X⁻¹ "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) := by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The quotient of two functions with finite range, has finite range. -/\n@[to_additive \"The difference of functions of finite range, has finite range.\"]\ninstance FiniteRange.div {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X/Y) := by\n  show FiniteRange ((fun p ↦ p.1 / p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The inverse of a function of finite range, has finite range.-/\n@[to_additive \"The negation of a function of finite range, has finite range.\"]\ninstance FiniteRange.inv {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] :\n    FiniteRange X⁻¹ := by\n  show FiniteRange ((fun p ↦ p⁻¹) ∘ X)\n  infer_instance\n\n","proof":":= by\n  show FiniteRange ((fun x ↦ x^c) ∘ X)\n  infer_instance","declId":"PFR.ForMathlib.FiniteRange.101_0.UebCMBHooLRWAeW","decl":"/-- A function of finite range raised to a constant power, has finite range.  -/\n@[to_additive \"The multiple of a function of finite range by a constant, has finite range.\"]\ninstance FiniteRange.pow {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] (c : ℤ) :\n    FiniteRange (X^c) "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) := by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The quotient of two functions with finite range, has finite range. -/\n@[to_additive \"The difference of functions of finite range, has finite range.\"]\ninstance FiniteRange.div {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X/Y) := by\n  show FiniteRange ((fun p ↦ p.1 / p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The inverse of a function of finite range, has finite range.-/\n@[to_additive \"The negation of a function of finite range, has finite range.\"]\ninstance FiniteRange.inv {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] :\n    FiniteRange X⁻¹ := by\n  show FiniteRange ((fun p ↦ p⁻¹) ∘ X)\n  infer_instance\n\n/-- A function of finite range raised to a constant power, has finite range.  -/\n@[to_additive \"The multiple of a function of finite range by a constant, has finite range.\"]\ninstance FiniteRange.pow {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] (c : ℤ) :\n    FiniteRange (X^c) := by\n  show FiniteRange ((fun x ↦ x^c) ∘ X)\n  infer_instance\n\n\nopen MeasureTheory\n\n","proof":":= by\n  rw [Measure.map_apply hX]\n  congr\n  ext ω; simp\n  measurability","declId":"PFR.ForMathlib.FiniteRange.111_0.UebCMBHooLRWAeW","decl":"lemma FiniteRange.full {Ω G : Type*} [MeasurableSpace Ω] [MeasurableSpace G] [MeasurableSingletonClass G] {X : Ω → G} (hX: Measurable X) [FiniteRange X] (μ: Measure Ω) : (μ.map X) (FiniteRange.toFinset X) = μ Set.univ "}
{"srcUpToDecl":"import Mathlib.Data.Set.Image\nimport Mathlib.Data.Set.Finite\nimport Mathlib.Data.Fintype.Basic\nimport Mathlib.Algebra.Group.Defs\nimport Mathlib.Algebra.GroupPower.Basic\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\nimport PFR.ForMathlib.Pair\n\n\n/-- The property of having a finite range. -/\nclass FiniteRange {Ω G : Type*} (X : Ω → G) : Prop where\n  finite : (Set.range X).Finite\n\n/-- fintype structure on the range of a finite range map. -/\nnoncomputable def FiniteRange.fintype {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Fintype (Set.range X) := hX.finite.fintype\n\n/-- The range of a finite range map, as a finset. -/\nnoncomputable def FiniteRange.toFinset {Ω G : Type*} (X : Ω → G) [hX: FiniteRange X] : Finset G :=\n    @Set.toFinset _ _ hX.fintype\n\n/-- If the codomain of X is finite, then X has finite range.  -/\ninstance {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X where\n  finite := Set.toFinite (Set.range X)\n\nexample {Ω G : Type*} (X : Ω → G) [Fintype G] : FiniteRange X := by infer_instance\n\n/-- Functions ranging in a Finset have finite range -/\nlemma finiteRange_of_finset {Ω G : Type*} (f: Ω → G) (A : Finset G) (h : ∀ ω, f ω ∈ A) : FiniteRange f := by\n  constructor\n  apply Set.Finite.subset (Finset.finite_toSet A)\n  intro y hy\n  simp at hy\n  rcases hy with ⟨ω, rfl⟩\n  exact h ω\n\nlemma FiniteRange.range {Ω G : Type*} (X : Ω → G) [hX : FiniteRange X] :\n    Set.range X = FiniteRange.toFinset X := by\n  simp [FiniteRange.toFinset]\n  convert (Set.coe_toFinset _).symm\n\nlemma FiniteRange.mem {Ω G : Type*} (X : Ω → G) [FiniteRange X] (ω : Ω) :\n    X ω ∈ FiniteRange.toFinset X := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n@[simp]\nlemma FiniteRange.mem_iff {Ω G : Type*} (X : Ω → G) [FiniteRange X] (x : G) : x ∈ FiniteRange.toFinset X ↔ ∃ ω, X ω = x := by\n  rw [← Finset.mem_coe, ← FiniteRange.range X]\n  simp\n\n/-- Constants have finite range -/\ninstance {Ω G : Type*} (c : G) : FiniteRange (fun _ : Ω ↦ c) := by\n  apply finiteRange_of_finset _ { c }\n  simp\n\n/-- If X has finite range, then any function of X has finite range.  -/\ninstance {Ω G H : Type*} (X : Ω → G) (f : G → H) [hX: FiniteRange X] : FiniteRange (f ∘ X) where\n  finite := by\n    rw [Set.range_comp f X]\n    exact Set.Finite.image f hX.finite\n\n/-- If X has finite range, then X of any function has finite range.  -/\ninstance {Ω Ω' G : Type*} (X : Ω → G) (f : Ω' → Ω) [hX: FiniteRange X] : FiniteRange (X ∘ f) := by\n  apply finiteRange_of_finset _ (FiniteRange.toFinset X)\n  intro ω\n  exact FiniteRange.mem X (f ω)\n\n/-- If X, Y have finite range, then so does the pair ⟨X, Y⟩. -/\ninstance {Ω G H : Type*} (X : Ω → G) (Y : Ω → H) [hX: FiniteRange X] [hY: FiniteRange Y]:\n    FiniteRange (⟨X, Y⟩) where\n  finite := by\n    have : Set.range (⟨X, Y⟩) ⊆ (Set.range X) ×ˢ (Set.range Y) := by\n      intro ⟨x, y⟩ hz\n      simp [Set.mem_range] at hz ⊢\n      rcases hz with ⟨ω, hω⟩\n      exact ⟨⟨ω, hω.1⟩, ω, hω.2⟩\n    exact Set.Finite.subset (Set.Finite.prod hX.finite hY.finite) this\n\n/-- The product of functions of finite range, has finite range.   -/\n@[to_additive \"The sum of functions of finite range, has finite range.\"]\ninstance FiniteRange.prod {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X*Y) := by\n  show FiniteRange ((fun p ↦ p.1 * p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The quotient of two functions with finite range, has finite range. -/\n@[to_additive \"The difference of functions of finite range, has finite range.\"]\ninstance FiniteRange.div {Ω G : Type*} (X : Ω → G) (Y : Ω → G) [Group G]\n    [hX: FiniteRange X] [hY: FiniteRange Y] : FiniteRange (X/Y) := by\n  show FiniteRange ((fun p ↦ p.1 / p.2) ∘ ⟨X, Y⟩)\n  infer_instance\n\n/-- The inverse of a function of finite range, has finite range.-/\n@[to_additive \"The negation of a function of finite range, has finite range.\"]\ninstance FiniteRange.inv {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] :\n    FiniteRange X⁻¹ := by\n  show FiniteRange ((fun p ↦ p⁻¹) ∘ X)\n  infer_instance\n\n/-- A function of finite range raised to a constant power, has finite range.  -/\n@[to_additive \"The multiple of a function of finite range by a constant, has finite range.\"]\ninstance FiniteRange.pow {Ω G : Type*} (X : Ω → G) [Group G] [hX: FiniteRange X] (c : ℤ) :\n    FiniteRange (X^c) := by\n  show FiniteRange ((fun x ↦ x^c) ∘ X)\n  infer_instance\n\n\nopen MeasureTheory\n\nlemma FiniteRange.full {Ω G : Type*} [MeasurableSpace Ω] [MeasurableSpace G] [MeasurableSingletonClass G] {X : Ω → G} (hX: Measurable X) [FiniteRange X] (μ: Measure Ω) : (μ.map X) (FiniteRange.toFinset X) = μ Set.univ := by\n  rw [Measure.map_apply hX]\n  congr\n  ext ω; simp\n  measurability\n\n","proof":":= by\n  by_cases hX : AEMeasurable X μ\n  · rw [Measure.map_apply₀ hX]\n    convert measure_empty\n    ext ω\n    simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage, Finset.mem_coe, mem_iff,\n      exists_apply_eq_apply, not_true_eq_false, Set.mem_empty_iff_false]\n    simp only [NullMeasurableSet.compl_iff]\n    refine MeasurableSet.nullMeasurableSet ?_\n    measurability\n  · simp [hX]","declId":"PFR.ForMathlib.FiniteRange.117_0.UebCMBHooLRWAeW","decl":"lemma FiniteRange.null_of_compl {Ω G : Type*} [MeasurableSpace Ω] [MeasurableSpace G]\n    [MeasurableSingletonClass G] (μ : Measure Ω) (X : Ω → G) [FiniteRange X] :\n    (μ.map X) (FiniteRange.toFinset X : Set G)ᶜ = 0 "}
