{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n","proof":":= simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective","declId":"PFR.ForMathlib.Entropy.Kernel.Group.19_0.mRp11HUrC7zmryh","decl":"@[to_additive (attr "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[","proof":":= simp)","declId":"PFR.ForMathlib.Entropy.Kernel.Group.19_2.mRp11HUrC7zmryh","decl":"to_additive (attr "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n","proof":":= by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Group.23_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n","proof":":=\n  entropy_map_of_injective κ μ inv_injective measurable_inv","declId":"PFR.ForMathlib.Entropy.Kernel.Group.32_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n","proof":":= by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Group.36_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n","proof":":=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Group.44_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n","proof":":=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Group.51_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n","proof":":= by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]","declId":"PFR.ForMathlib.Entropy.Kernel.Group.58_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n","proof":":= by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]","declId":"PFR.ForMathlib.Entropy.Kernel.Group.69_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n","proof":":=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Group.80_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n","proof":":= by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]","declId":"PFR.ForMathlib.Entropy.Kernel.Group.87_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]\n\n","proof":":= by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul _ _ hκ⟩","declId":"PFR.ForMathlib.Entropy.Kernel.Group.99_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul _ _ hκ⟩\n\n","proof":":= by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul' _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul' _ _ hκ⟩","declId":"PFR.ForMathlib.Entropy.Kernel.Group.109_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul' _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul' _ _ hκ⟩\n\n","proof":":= by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_div _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_div _ _ hκ⟩","declId":"PFR.ForMathlib.Entropy.Kernel.Group.119_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul' _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul' _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_div _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_div _ _ hκ⟩\n\n","proof":":= by\n  calc max (Hk[κ, μ]) (Hk[η, μ])\n    = max (Hk[κ, μ]) (Hk[η, μ]) - Ik[κ ×ₖ η, μ] := by\n        rw [mutualInfo_prod _ hκ hη, sub_zero]\n  _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n        convert max_entropy_sub_mutualInfo_le_entropy_mul (κ ×ₖ η) μ (hκ.prod hη)\n        · simp\n        · simp","declId":"PFR.ForMathlib.Entropy.Kernel.Group.129_0.mRp11HUrC7zmryh","decl":"@[to_additive]\nlemma max_entropy_le_entropy_mul_prod\n    (κ : kernel T G) [IsMarkovKernel κ] (η : kernel T G) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    max (Hk[κ, μ]) (Hk[η, μ]) ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 * p.2) measurable_mul, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.MutualInfo\nimport Mathlib.MeasureTheory.Group.Arithmetic\n/-!\n# Kernel entropy and mutual information in a commutative group\n\n## Main definitions\n\n## Main results\n\n-/\nopen MeasureTheory ProbabilityTheory\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace G] [MeasurableSingletonClass G] [Group G]\n  [MeasurableDiv₂ G] [MeasurableMul₂ G] [Countable G]\n  {κ : kernel T G} {μ : Measure T}\n\n@[to_additive (attr := simp)]\nlemma measureEntropy_inv (μ : Measure G) : Hm[μ.map (·⁻¹)] = Hm[μ] :=\n  measureEntropy_map_of_injective μ _ measurable_inv inv_injective\n\n@[to_additive]\nlemma measureEntropy_div_comm (μ : Measure (G × G)) :\n    Hm[μ.map fun p ↦ p.1 / p.2] = Hm[μ.map fun p ↦ p.2 / p.1] := by\n  rw [← measureEntropy_inv, Measure.map_map measurable_inv measurable_div]\n  congr with x\n  simp\n\nnamespace ProbabilityTheory.kernel\n\n@[to_additive]\nlemma entropy_inv (κ : kernel T G) (μ : Measure T) : Hk[map κ (·⁻¹) measurable_inv, μ] = Hk[κ, μ] :=\n  entropy_map_of_injective κ μ inv_injective measurable_inv\n\n@[to_additive]\nlemma entropy_div_comm (κ : kernel T (G × G)) (μ : Measure T) :\n    Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ]\n      = Hk[map κ (fun p ↦ p.2 / p.1) (measurable_snd.div measurable_fst), μ] := by\n  rw [← entropy_inv, kernel.map_map]\n  congr with x\n  simp\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_right_injective hκ\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ mul_left_injective hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul' (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.2 * p.1) ∘ Prod.swap = (fun p ↦ p.1 * p.2) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_mul (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 * p.2) ∘ Prod.swap = (fun p ↦ p.2 * p.1) := rfl\n    simp_rw [this]\n\n@[to_additive]\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] :=\n  entropy_snd_sub_mutualInfo_le_entropy_map_of_injective κ μ _ (fun _ ↦ div_right_injective) hκ\n\n@[to_additive]\nlemma entropy_fst_sub_mutualInfo_le_entropy_map_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    Hk[fst κ, μ] - Ik[κ, μ] ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n    have h := entropy_snd_sub_mutualInfo_le_entropy_map_div (swapRight κ) μ hκ.swapRight\n    simp only [snd_swapRight, mutualInfo_swapRight, map_swapRight] at h\n    refine h.trans_eq ?_\n    have : (fun p : G × G ↦ p.1 / p.2) ∘ Prod.swap = (fun p ↦ p.2 / p.1) := rfl\n    simp_rw [this]\n    rw [← entropy_div_comm]\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_mul'\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ)  :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.2 * p.1) $ measurable_discrete _, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_mul' _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_mul' _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_sub_mutualInfo_le_entropy_div\n    (κ : kernel T (G × G)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    max (Hk[fst κ, μ]) (Hk[snd κ, μ]) - Ik[κ, μ]\n      ≤ Hk[map κ (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n  rw [← max_sub_sub_right, max_le_iff]\n  exact ⟨entropy_fst_sub_mutualInfo_le_entropy_map_div _ _ hκ,\n    entropy_snd_sub_mutualInfo_le_entropy_map_div _ _ hκ⟩\n\n@[to_additive]\nlemma max_entropy_le_entropy_mul_prod\n    (κ : kernel T G) [IsMarkovKernel κ] (η : kernel T G) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    max (Hk[κ, μ]) (Hk[η, μ]) ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n  calc max (Hk[κ, μ]) (Hk[η, μ])\n    = max (Hk[κ, μ]) (Hk[η, μ]) - Ik[κ ×ₖ η, μ] := by\n        rw [mutualInfo_prod _ hκ hη, sub_zero]\n  _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 * p.2) measurable_mul, μ] := by\n        convert max_entropy_sub_mutualInfo_le_entropy_mul (κ ×ₖ η) μ (hκ.prod hη)\n        · simp\n        · simp\n\n","proof":":= by\n  calc max (Hk[κ, μ]) (Hk[η, μ])\n    = max (Hk[κ, μ]) (Hk[η, μ]) - Ik[κ ×ₖ η, μ] := by\n        rw [mutualInfo_prod _ hκ hη, sub_zero]\n  _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 / p.2) measurable_div, μ] := by\n        convert max_entropy_sub_mutualInfo_le_entropy_div (κ ×ₖ η) μ (hκ.prod hη)\n        · simp\n        · simp","declId":"PFR.ForMathlib.Entropy.Kernel.Group.143_0.mRp11HUrC7zmryh","decl":"@[to_additive max_entropy_le_entropy_sub_prod]\nlemma max_entropy_le_entropy_div_prod\n    (κ : kernel T G) [IsMarkovKernel κ] (η : kernel T G) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    max (Hk[κ, μ]) (Hk[η, μ]) ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1 / p.2) measurable_div, μ] "}
