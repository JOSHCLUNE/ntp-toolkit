{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\n","proof":":= by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }","declId":"PFR.ApproxHomPFR.23_0.N2CNz2HCkx04Gbg","decl":"lemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\n","proof":":= by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]","declId":"PFR.ApproxHomPFR.38_0.N2CNz2HCkx04Gbg","decl":"lemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n","proof":":= by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this","declId":"PFR.ApproxHomPFR.45_0.N2CNz2HCkx04Gbg","decl":"/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\n","proof":":= 2^4","declId":"PFR.ApproxHomPFR.140_0.N2CNz2HCkx04Gbg","decl":"def C₁ "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\n","proof":":= 1","declId":"PFR.ApproxHomPFR.141_0.N2CNz2HCkx04Gbg","decl":"def C₂ "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\ndef C₂ := 1\n","proof":":= 2^10","declId":"PFR.ApproxHomPFR.142_0.N2CNz2HCkx04Gbg","decl":"def C₃ "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\ndef C₂ := 1\ndef C₃ := 2^10\n","proof":":= 4","declId":"PFR.ApproxHomPFR.143_0.N2CNz2HCkx04Gbg","decl":"def C₄ "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\ndef C₂ := 1\ndef C₃ := 2^10\ndef C₄ := 4\n\n/-- Let $G$ be an abelian group, and let $A$ be a finite non-empty set with $E(A) \\geq |A|^3 / K$ for some $K \\geq 1$.  Then there is a subset $A'$ of $A$ with $|A'| \\geq |A| / (C_1 K^{C_2})$ and $|A'-A'| \\leq C_3 K^{C_4} |A'|$ -/\nlemma bsg (A : Finset G) (K : ℝ) (hK: 0 < K) (hE: E[A] ≥ (A.card)^3 / K): ∃ A' : Finset G, A' ⊆ A ∧ A'.card ≥ A.card / (C₁ * K^C₂) ∧ (A' - A').card ≤ C₃ * K^C₄ * A'.card := sorry\n\nopen scoped BigOperators\nvariable {G G' : Type*} [AddCommGroup G] [Fintype G] [AddCommGroup G'] [Fintype G']\n  [ElementaryAddCommGroup G 2] [ElementaryAddCommGroup G' 2]\n\n","proof":":= (Set.graph f).toFinite.toFinset\n    (A ×ˢ A).filter (fun (a, a') ↦ a + a' ∈ A) ≃\n    { x : G × G | f (x.1 + x.2) = (f x.1) + (f x.2) } where\n  toFun := fun ⟨a, ha⟩ ↦ by\n    let A := (Set.graph f).toFinite.toFinset\n    use (a.1.1, a.2.1)\n    apply Finset.mem_filter.mp at ha\n    have h {a} (h' : a ∈ A) := (Set.mem_graph _).mp <| (Set.graph f).toFinite.mem_toFinset.mp h'\n    show f (a.1.1 + a.2.1) = (f a.1.1) + (f a.2.1)\n    rw [h (Finset.mem_product.mp ha.1).1, h (Finset.mem_product.mp ha.1).2]\n    exact h ha.2\n  invFun := fun ⟨a, ha⟩ ↦ by\n    use ((a.1, f a.1), (a.2, f a.2))\n    refine Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨?_, ?_⟩, ?_⟩\n    <;> apply (Set.graph f).toFinite.mem_toFinset.mpr\n    · exact ⟨a.1, rfl⟩\n    · exact ⟨a.2, rfl⟩\n    · exact (Set.mem_graph _).mpr ha\n  left_inv := fun ⟨x, hx⟩ ↦ by\n    apply Subtype.ext\n    show ((x.1.1, f x.1.1), x.2.1, f x.2.1) = x\n    obtain ⟨hx1, hx2⟩ := Finset.mem_product.mp (Finset.mem_filter.mp hx).1\n    rewrite [(Set.graph f).toFinite.mem_toFinset] at hx1 hx2\n    rw [(Set.mem_graph x.1).mp hx1, (Set.mem_graph x.2).mp hx2]\n  right_inv := fun _ ↦ rfl","declId":"PFR.ApproxHomPFR.152_0.N2CNz2HCkx04Gbg","decl":"lemma equiv_filter_graph (f : G → G') :\n    let A "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\ndef C₂ := 1\ndef C₃ := 2^10\ndef C₄ := 4\n\n/-- Let $G$ be an abelian group, and let $A$ be a finite non-empty set with $E(A) \\geq |A|^3 / K$ for some $K \\geq 1$.  Then there is a subset $A'$ of $A$ with $|A'| \\geq |A| / (C_1 K^{C_2})$ and $|A'-A'| \\leq C_3 K^{C_4} |A'|$ -/\nlemma bsg (A : Finset G) (K : ℝ) (hK: 0 < K) (hE: E[A] ≥ (A.card)^3 / K): ∃ A' : Finset G, A' ⊆ A ∧ A'.card ≥ A.card / (C₁ * K^C₂) ∧ (A' - A').card ≤ C₃ * K^C₄ * A'.card := sorry\n\nopen scoped BigOperators\nvariable {G G' : Type*} [AddCommGroup G] [Fintype G] [AddCommGroup G'] [Fintype G']\n  [ElementaryAddCommGroup G 2] [ElementaryAddCommGroup G' 2]\n\nlemma equiv_filter_graph (f : G → G') :\n    let A := (Set.graph f).toFinite.toFinset\n    (A ×ˢ A).filter (fun (a, a') ↦ a + a' ∈ A) ≃\n    { x : G × G | f (x.1 + x.2) = (f x.1) + (f x.2) } where\n  toFun := fun ⟨a, ha⟩ ↦ by\n    let A := (Set.graph f).toFinite.toFinset\n    use (a.1.1, a.2.1)\n    apply Finset.mem_filter.mp at ha\n    have h {a} (h' : a ∈ A) := (Set.mem_graph _).mp <| (Set.graph f).toFinite.mem_toFinset.mp h'\n    show f (a.1.1 + a.2.1) = (f a.1.1) + (f a.2.1)\n    rw [h (Finset.mem_product.mp ha.1).1, h (Finset.mem_product.mp ha.1).2]\n    exact h ha.2\n  invFun := fun ⟨a, ha⟩ ↦ by\n    use ((a.1, f a.1), (a.2, f a.2))\n    refine Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨?_, ?_⟩, ?_⟩\n    <;> apply (Set.graph f).toFinite.mem_toFinset.mpr\n    · exact ⟨a.1, rfl⟩\n    · exact ⟨a.2, rfl⟩\n    · exact (Set.mem_graph _).mpr ha\n  left_inv := fun ⟨x, hx⟩ ↦ by\n    apply Subtype.ext\n    show ((x.1.1, f x.1.1), x.2.1, f x.2.1) = x\n    obtain ⟨hx1, hx2⟩ := Finset.mem_product.mp (Finset.mem_filter.mp hx).1\n    rewrite [(Set.graph f).toFinite.mem_toFinset] at hx1 hx2\n    rw [(Set.mem_graph x.1).mp hx1, (Set.mem_graph x.2).mp hx2]\n  right_inv := fun _ ↦ rfl\n\nset_option maxHeartbeats 400000 in\n","proof":":= by\n  let A := (Set.graph f).toFinite.toFinset\n\n  have h_cs : ((A ×ˢ A).filter (fun (a, a') ↦ a + a' ∈ A) |>.card : ℝ) ^ 2 ≤\n      Finset.card A * E[A] := by norm_cast; convert cauchy_schwarz A A\n  rewrite [← Nat.card_eq_finsetCard, ← Nat.card_eq_finsetCard,\n    Nat.card_congr (equiv_filter_graph f)] at h_cs\n\n  have hA : Nat.card A = Nat.card G := by\n    rewrite [← Set.card_graph f, Nat.card_eq_finsetCard, Set.Finite.card_toFinset]; simp\n  have hA_pos : 0 < (Nat.card A : ℝ) := Nat.cast_pos.mpr <| Nat.card_pos.trans_eq hA.symm\n  have : ((Nat.card G)^2 / K)^2 ≤ Nat.card A * E[A] := LE.le.trans (by gcongr) h_cs\n  rewrite [← hA] at this\n  replace : E[A] ≥ (Finset.card A)^3 / K^2 := calc\n    _ ≥ ((Nat.card A)^2 / K)^2 / Nat.card A := (div_le_iff' <| hA_pos).mpr this\n    _ = ((Nat.card A)^4 / (Nat.card A)) / K^2 := by ring\n    _ = (Finset.card A)^3 / K^2 := by\n      rw [pow_succ, mul_comm, mul_div_assoc, div_self (ne_of_gt hA_pos), mul_one,\n        Nat.card_eq_finsetCard]\n  obtain ⟨A', hA', hA'1, hA'2⟩ := bsg A (K^2) (sq_pos_of_pos hK) (by convert this)\n  clear h_cs hf this\n\n  let A'' := A'.toSet\n  have hA''_coe : Nat.card A'' = Finset.card A' := Nat.card_eq_finsetCard A'\n  have h_pos1 : 0 < (C₁ : ℝ) * (K ^ 2) ^ C₂ :=\n    mul_pos (by unfold C₁; norm_num) (pow_pos (pow_pos hK 2) C₂)\n  have hA''_pos : 0 < Nat.card A'' := by\n    rewrite [hA''_coe, ← Nat.cast_pos (α := ℝ)]\n    exact LT.lt.trans_le (div_pos (by rwa [← Nat.card_eq_finsetCard]) h_pos1) hA'1\n  have hA''_nonempty : Set.Nonempty A'' := nonempty_subtype.mp (Finite.card_pos_iff.mp hA''_pos)\n  have : Finset.card (A' - A') = Nat.card (A'' + A'') := calc\n    _ = Nat.card (A' - A').toSet := (Nat.card_eq_finsetCard _).symm\n    _ = Nat.card (A'' + A'') := by rw [Finset.coe_sub, sumset_eq_sub]\n  replace :  Nat.card (A'' + A'') ≤ C₃ * (K ^ 2) ^ C₄ * (Nat.card A'') := by\n    rewrite [← this, hA''_coe]\n    convert hA'2\n  obtain ⟨H, c, hc_card, hH_le, hH_ge, hH_cover⟩ := PFR_conjecture_improv_aux hA''_nonempty this\n  clear hA'2 hA''_coe hH_le hH_ge hA_pos\n  obtain ⟨H₀, H₁, φ, hH₀H₁, hH₀H₁_card⟩ := goursat H\n\n  have h_le_H₀ : Nat.card A'' ≤ Nat.card c * Nat.card H₀ := by\n    have h_le := Nat.card_mono (Set.toFinite _) (Set.image_subset Prod.fst hH_cover)\n    have h_proj_A'' : Nat.card A'' = Nat.card (Prod.fst '' A'') := Nat.card_congr\n      (Equiv.Set.imageOfInjOn Prod.fst A'' <|\n        Set.InjOn.mono (Set.Finite.subset_toFinset.mp hA') (Set.fst_injOn_graph f))\n    have h_proj_c : Prod.fst '' (c + H : Set (G × G')) = (Prod.fst '' c) + H₀ := by\n      ext x ; constructor <;> intro hx\n      · obtain ⟨x, ⟨⟨c, hc, h, hh, hch⟩, hx⟩⟩ := hx\n        rewrite [← hx]\n        exact ⟨c.1, Set.mem_image_of_mem Prod.fst hc, h.1, ((hH₀H₁ h).mp hh).1, (Prod.ext_iff.mp hch).1⟩\n      · obtain ⟨_, ⟨c, hc⟩, h, hh, hch⟩ := hx\n        refine ⟨c + Prod.mk h (φ h), ⟨⟨c, hc.1, Prod.mk h (φ h), ?_⟩, by rwa [← hc.2] at hch⟩⟩\n        exact ⟨(hH₀H₁ ⟨h, φ h⟩).mpr ⟨hh, by rw [sub_self]; apply zero_mem⟩, rfl⟩\n    rewrite [← h_proj_A'', h_proj_c] at h_le\n    apply (h_le.trans Set.card_add_le).trans\n    gcongr\n    exact Nat.card_image_le c.toFinite\n\n  have hH₀_pos : (0 : ℝ) < Nat.card H₀ := Nat.cast_pos.mpr Nat.card_pos\n  have h_le_H₁ : (Nat.card H₁ : ℝ) ≤ (Nat.card c) * (Nat.card H) / Nat.card A'' := calc\n    _ = (Nat.card H : ℝ) / (Nat.card H₀) :=\n      (eq_div_iff <| ne_of_gt <| hH₀_pos).mpr <| by rw [mul_comm, ← Nat.cast_mul, hH₀H₁_card]\n    _ ≤ (Nat.card c : ℝ) * (Nat.card H) / Nat.card A'' := by\n      nth_rewrite 1 [← mul_one (Nat.card H : ℝ), mul_comm (Nat.card c : ℝ)]\n      repeat rewrite [mul_div_assoc]\n      refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)\n      refine le_of_mul_le_mul_right ?_ hH₀_pos\n      refine le_of_mul_le_mul_right ?_ (Nat.cast_pos.mpr hA''_pos)\n      rewrite [div_mul_cancel 1, mul_right_comm, one_mul,  div_mul_cancel, ← Nat.cast_mul]\n      · exact Nat.cast_le.mpr h_le_H₀\n      · exact ne_of_gt (Nat.cast_pos.mpr hA''_pos)\n      · exact ne_of_gt hH₀_pos\n  clear h_le_H₀ hA''_pos hH₀_pos hH₀H₁_card\n\n  let translate (c : G × G') (h : G') := A'' ∩ ({c} + {(0, h)} + Set.graph φ.toFun)\n  have h_translate (c : G × G') (h : G') :\n      Prod.fst '' translate c h ⊆ { x : G | f x = φ x + (-φ c.1 + c.2 + h) } := by\n    intro x hx\n    obtain ⟨x, ⟨⟨hxA'', ⟨_, ⟨c', hc, h', hh, hch⟩, x', hx, hchx⟩⟩, hxx⟩⟩ := hx\n    show f _ = φ _ + (-φ c.1 + c.2 + h)\n    replace := (Set.mem_graph x).mp <| (Set.graph f).toFinite.mem_toFinset.mp (hA' hxA'')\n    rewrite [← hxx, this, ← hchx, ← hch, hc, hh]\n    show c.2 + h + x'.2 = φ (c.1 + 0 + x'.1) + (-φ c.1 + c.2 + h)\n    replace : φ x'.1 = x'.2 := (Set.mem_graph x').mp hx\n    rw [map_add, map_add, map_zero, add_zero, this, add_comm (φ c.1), add_assoc x'.2,\n      ← add_assoc (φ c.1), ← add_assoc (φ c.1), add_neg_self, zero_add, add_comm]\n  have h_translate_card c h : Nat.card (translate c h) = Nat.card (Prod.fst '' translate c h) :=\n    Nat.card_congr (Equiv.Set.imageOfInjOn Prod.fst (translate c h) <|\n      Set.InjOn.mono (fun _ hx ↦ Set.Finite.subset_toFinset.mp hA' hx.1) (Set.fst_injOn_graph f))\n\n  let cH₁ := (c ×ˢ H₁).toFinite.toFinset\n  haveI A_nonempty : Nonempty A'' := Set.nonempty_coe_sort.mpr hA''_nonempty\n  replace : Nonempty c := by\n    obtain ⟨c, hc, _, _, _⟩ := hH_cover (Classical.choice A_nonempty).property\n    exact ⟨c, hc⟩\n  replace h_nonempty : Set.Nonempty (c ×ˢ H₁) :=\n    Set.Nonempty.prod (Set.nonempty_coe_sort.mp this) (Set.nonempty_coe_sort.mp inferInstance)\n  replace : A' = Finset.biUnion cH₁ fun ch ↦ (translate ch.1 ch.2).toFinite.toFinset := by\n    ext x ; constructor <;> intro hx\n    · obtain ⟨c', hc, h, hh, hch⟩ := hH_cover hx\n      refine Finset.mem_biUnion.mpr ⟨(c', h.2 - φ h.1), ?_⟩\n      refine ⟨(Set.Finite.mem_toFinset _).mpr ⟨hc, ((hH₀H₁ h).mp hh).2⟩, ?_⟩\n      refine (Set.Finite.mem_toFinset _).mpr ⟨hx, c' + (0, h.2 - φ h.1), ?_⟩\n      refine ⟨⟨c', rfl, (0, h.2 - φ h.1), rfl, rfl⟩, (h.1, φ h.1), ⟨h.1, rfl⟩, ?_⟩\n      beta_reduce\n      rewrite [add_assoc]\n      show c' + (0 + h.1, h.2 - φ h.1 + φ h.1) = x\n      rewrite [zero_add, sub_add_cancel]\n      exact hch\n    · obtain ⟨ch, hch⟩ := Finset.mem_biUnion.mp hx\n      exact ((Set.Finite.mem_toFinset _).mp hch.2).1\n\n  replace : ∑ __ in cH₁, ((Finset.card A) / (C₁ * (K ^ 2) ^ C₂) / cH₁.card : ℝ) ≤\n      ∑ ch in cH₁, ((translate ch.1 ch.2).toFinite.toFinset.card : ℝ) := by\n    rewrite [Finset.sum_const, nsmul_eq_mul, ← mul_div_assoc, mul_div_right_comm, div_self, one_mul]\n    · apply hA'1.trans\n      norm_cast\n      exact (congrArg Finset.card this).trans_le Finset.card_biUnion_le\n    · symm\n      refine ne_of_lt <| Nat.cast_zero.symm.trans_lt <| Nat.cast_lt.mpr <| Finset.card_pos.mpr ?_\n      exact (Set.Finite.toFinset_nonempty _).mpr h_nonempty\n  replace : ∃ c' : G × G', ∃ h : G', (Finset.card A) / (C₁ * (K ^ 2) ^ C₂) / cH₁.card ≤\n      Nat.card { x : G | f x = φ x + (-φ c'.1 + c'.2 + h) } := by\n    obtain ⟨ch, hch⟩ :=\n      Finset.exists_le_of_sum_le ((Set.Finite.toFinset_nonempty _).mpr h_nonempty) this\n    refine ⟨ch.1, ch.2, hch.2.trans ?_⟩\n    rewrite [Set.Finite.card_toFinset, ← Nat.card_eq_fintype_card, h_translate_card]\n    exact Nat.cast_le.mpr <| Nat.card_mono (Set.toFinite _) (h_translate ch.1 ch.2)\n  clear hA' hA'1 hH_cover hH₀H₁ translate h_translate h_translate_card\n\n  obtain ⟨c', h, hch⟩ := this\n  use φ, -φ c'.1 + c'.2 + h\n  refine LE.le.trans ?_ hch\n  unfold_let cH₁\n  rewrite [← Nat.card_eq_finsetCard, div_div, hA]\n  apply div_le_div_of_le_left (Nat.cast_nonneg _) <| mul_pos h_pos1 <| Nat.cast_pos.mpr <|\n    Finset.card_pos.mpr <| (Set.Finite.toFinset_nonempty _).mpr h_nonempty\n  rewrite [← c.toFinite.toFinset_prod (H₁ : Set G').toFinite, Finset.card_product]\n  repeat rewrite [Set.Finite.card_toFinset, ← Nat.card_eq_fintype_card]\n  rewrite [Nat.cast_mul, ← mul_assoc _ (Nat.card c : ℝ)]\n  replace := mul_nonneg h_pos1.le (Nat.cast_nonneg (Nat.card c))\n  apply (mul_le_mul_of_nonneg_left h_le_H₁ this).trans\n  rewrite [mul_div_assoc, ← mul_assoc, mul_comm _ (Nat.card c : ℝ), mul_assoc]\n  have hHA := div_nonneg (α := ℝ) (Nat.cast_nonneg (Nat.card H)) <| Nat.cast_nonneg (Nat.card A'')\n  apply (mul_le_mul_of_nonneg_right hc_card <| mul_nonneg this hHA).trans\n  rewrite [mul_comm, mul_assoc, mul_comm _ (Nat.card c : ℝ), mul_assoc]\n  refine (mul_le_mul_of_nonneg_right hc_card ?_).trans_eq ?_\n  · exact mul_nonneg h_pos1.le <| mul_nonneg hHA <| by positivity\n  have h_pos2 : 0 < (C₃ : ℝ) * (K ^ 2) ^ C₄ :=\n    mul_pos (by unfold C₃; norm_num) (pow_pos (pow_pos hK 2) C₄)\n  rewrite [mul_comm, mul_assoc, mul_assoc, mul_assoc, mul_mul_mul_comm,\n    ← Real.rpow_add (Nat.cast_pos.mpr Nat.card_pos), mul_mul_mul_comm,\n    ← Real.rpow_add (Nat.cast_pos.mpr Nat.card_pos), ← Real.rpow_add h_pos2]\n  norm_num\n  rewrite [mul_comm _ (Finset.card A' : ℝ), mul_assoc (Finset.card A' : ℝ),\n    ← mul_assoc _ (Finset.card A' : ℝ), div_mul_cancel _ <|\n    Nat.cast_ne_zero.mpr (Finset.card_pos.mpr hA''_nonempty).ne.symm, Real.rpow_neg_one,\n    mul_comm (Fintype.card H : ℝ), mul_assoc _ _ (Fintype.card H : ℝ),\n    inv_mul_cancel <| NeZero.natCast_ne _ _, mul_one, ← pow_mul,\n    Real.mul_rpow (by norm_num) (pow_nonneg (sq_nonneg K) C₄), ← pow_mul,\n    mul_comm (K ^ _), mul_assoc _ _ (K ^ _)]\n  repeat rewrite [show (12 : ℝ) = ((12 : ℕ) : ℝ) from rfl]\n  repeat rewrite [Real.rpow_nat_cast]\n  rewrite [← pow_mul, ← pow_add, mul_right_comm, ← mul_assoc]\n  norm_num","declId":"PFR.ApproxHomPFR.180_0.N2CNz2HCkx04Gbg","decl":"/-- Let $G, G'$ be finite abelian $2$-groups.\nLet $f: G \\to G'$ be a function, and suppose that there are at least\n$|G|^2 / K$ pairs $(x,y) \\in G^2$ such that $$ f(x+y) = f(x) + f(y).$$\nThen there exists a homomorphism $\\phi: G \\to G'$ and a constant $c \\in G'$ such that\n$f(x) = \\phi(x)+c$ for at least $|G| / C_1 C_3^{12} K^{24C_4 + 2C_2}$ values of $x \\in G$. -/\ntheorem approx_hom_pfr (f : G → G') (K : ℝ) (hK: K > 0)\n    (hf: Nat.card { x : G × G | f (x.1+x.2) = (f x.1) + (f x.2) } ≥ (Nat.card G)^2 / K) :\n    ∃ (φ : G →+ G') (c : G'), Nat.card { x : G | f x = φ x + c } ≥\n    (Nat.card G) / (C₁ * C₃^12 * K^(24 * C₄ + 2 * C₂)) "}
{"srcUpToDecl":"import PFR.HomPFR\nimport Mathlib.Combinatorics.Additive.Energy\nimport Mathlib.Analysis.NormedSpace.PiLp\nimport Mathlib.Analysis.InnerProductSpace.PiL2\n\n/-!\n# The approximate homomorphism form of PFR\n\nHere we apply PFR to show that almost homomorphisms f from a 2-group to a 2-group often coincide with a (shifted) actual homomorphisms.  Here, approximate is in the sense that f(x+y)=f(x)+f(y) is true for a positive proportion of x,y.\n\n## Main result\n\n* `approx_hom_pfr` : If $f: G → G'$ is a map between finite abelian elementary 2-groups such that $f(x+y)=f(x)+f(y)$ for at least $|G|/K$ values, then then there is a homomorphism $\\phi: G \\to G'$ and a constant $c$ such that $f(x)=\\phi(x)+c$ for a substantial set of values.\n\n-/\nopen Pointwise Classical\n\nvariable {G : Type*} [AddCommGroup G] (A : Finset G)\n\n/-- If $G$ is a group, and $A$ is a finite subset of $G$, the \\emph{additive energy} $E(A)$ of $A$ is the number of quadruples $(a_1,a_2,a_3,a_4) \\in A^4$ such that $a_1+a_2 = a_3+a_4$. -/\nnotation3:max \"E[\" A \"]\" => Finset.additiveEnergy A A\n\nlemma nat_cauchy_schwartz {B : Type*} [Fintype B] (v w : B → ℕ) :\n  (Finset.univ.sum (v * w))^2 ≤ Finset.univ.sum (v^2) * Finset.univ.sum (w^2) := by\n  rify\n  let x : EuclideanSpace ℝ B := fun i ↦ (v i : ℝ)\n  let y : EuclideanSpace ℝ B := fun i ↦ (w i : ℝ)\n  have := abs_real_inner_le_norm x y\n  rw [PiLp.inner_apply, ((abs_eq (mul_nonneg (norm_nonneg x) (norm_nonneg y))).mpr\n    (abs_eq_abs.mp rfl)).symm, ← sq_le_sq, mul_pow, EuclideanSpace.norm_eq,EuclideanSpace.norm_eq] at this\n  rw [Real.sq_sqrt, Real.sq_sqrt] at this\n  · simp only [IsROrC.norm_natCast] at this\n    simp only [Real.sq_sqrt, Real.sq_sqrt, IsROrC.norm_natCast, Pi.mul_apply, Nat.cast_mul,\n      Pi.pow_apply, Nat.cast_pow, ge_iff_le]\n    exact this\n  all_goals { apply Finset.sum_nonneg (fun i _ ↦ sq_nonneg _) }\n\nlemma nat_cauchy_schwartz' {X : Type*} (B : Finset X) (v w : X → ℕ) :\n  (B.sum (v * w))^2 ≤ B.sum (v^2) * B.sum (w^2) := by\n  have := nat_cauchy_schwartz (fun b : B => v b) (fun b : B => w b)\n  rwa [← (show Finset.univ.sum (fun b : B => (v * w) b) = B.sum (v * w) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (v^2 : X → ℕ) b) = B.sum (v^2) from Finset.sum_attach ..),\n    ← (show Finset.univ.sum (fun b : B => (w^2 : X → ℕ) b) = B.sum (w^2) from Finset.sum_attach ..)]\n\n/--  If $G$ is a group, $A,B$ are finite subsets of $G$, then\n$$ E(A) \\geq \\frac{|\\{ (a,a') \\in A \\times A: a+a' \\in B \\}|^2}{|B|}.$$ -/\nlemma cauchy_schwarz (A B : Finset G) :\n  ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card^2 ≤ B.card * E[A] := by\n  let r : G → ℕ := fun g => ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd = g)).card\n  let T : Finset G := (A ×ˢ A).image (fun a => a.fst + a.snd)\n  -- This should be a bit easier with a little extra API for additive energy\n  have counting : E[A] = T.sum (fun b => (r b)^2)\n  · let S := ((A ×ˢ A) ×ˢ A ×ˢ A).filter (fun (x : (G × G) × G × G) => x.1.1 + x.2.1 = x.1.2 + x.2.2)\n    have temp : ∀ x : (G × G) × G × G, x ∈ S → x.1.2 + x.2.2 ∈ T\n    · intro x hx\n      rw [Finset.mem_image]\n      use (x.1.2, x.2.2)\n      refine ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp (Finset.mem_product.mp\n        (Finset.mem_filter.mp hx).left).left).right, (Finset.mem_product.mp\n        (Finset.mem_product.mp (Finset.mem_filter.mp hx).left).right).right⟩, rfl⟩\n    rw [(show E[A] = S.card from rfl), Finset.card_eq_sum_card_fiberwise temp]\n    suffices card_fiber : ∀ (g : G), g ∈ T →\n      (S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)).card = (r g)^2\n    · rw [Finset.sum_congr rfl card_fiber]\n    suffices : ∀ (g : G), g ∈ T → S.filter (fun (x : (G × G) × G × G) => x.1.2 + x.2.2 = g)\n      = (((A ×ˢ A).filter (fun x => x.1 + x.2 = g)) ×ˢ ((A ×ˢ A).filter (fun x => x.1 + x.2 = g))).image\n      (fun x => ((x.1.1, x.2.1), x.1.2, x.2.2))\n    · intro g hg\n      rw [this g hg]\n      simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product,\n        Finset.filter_congr_decidable, pow_two]\n      rw [Finset.card_image_of_injective]\n      · simp only [Finset.mem_product, and_imp, Prod.forall, Finset.card_product]\n      · intro x y h\n        simp only [Prod.mk.injEq] at h\n        rw [Prod.ext_iff, Prod.ext_iff, Prod.ext_iff]\n        refine ⟨⟨h.left.left, h.right.left⟩, h.left.right, h.right.right⟩\n    intro g _\n    ext x\n    refine ⟨fun hx => ?_, fun hx => ?_⟩\n    · rw [Finset.mem_image]\n      use ((x.1.1, x.2.1), x.1.2, x.2.2)\n      refine ⟨?_, rfl⟩\n      rw [Finset.mem_product]\n      rw [Finset.mem_filter] at hx ⊢\n      constructor\n      · simp only [Finset.mem_product]\n        constructor\n        · exact ⟨(Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).left,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).left⟩\n        · rw [(Finset.mem_filter.mp hx.left).right, hx.right]\n      · exact Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨(Finset.mem_product.mp\n          (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).left).right,\n          (Finset.mem_product.mp (Finset.mem_product.mp (Finset.mem_filter.mp hx.left).left).right).right⟩, hx.right⟩\n    · obtain ⟨a, ha, rfl⟩ := Finset.mem_image.mp hx\n      rw [Finset.mem_product, Finset.mem_filter, Finset.mem_filter, Finset.mem_product, Finset.mem_product] at ha\n      refine Finset.mem_filter.mpr ⟨Finset.mem_filter.mpr ⟨?_, ?_⟩, ha.right.right⟩\n      · simpa only [Finset.mem_product, Finset.mem_product, Finset.mem_product] using\n          ⟨⟨ha.left.left.left, ha.right.left.left⟩, ha.left.left.right, ha.right.left.right⟩\n      · rw [ha.left.right, ha.right.right]\n  have rhs : ((A ×ˢ A).filter (fun (a : G × G) => a.fst + a.snd ∈ B)).card = B.sum r\n  · rw [Finset.card_eq_sum_card_fiberwise (fun x hx => (Finset.mem_filter.mp hx).right)]\n    apply Finset.sum_congr rfl (fun x hx => ?_)\n    rw [Finset.filter_filter]\n    apply congr_arg _  (Finset.filter_congr (fun u _ => ⟨fun hu' => hu'.2, fun hu' => ⟨by rwa [hu'], hu'⟩⟩))\n  suffices cauchy_schwarz : (B.sum r)^2 ≤ B.card * B.sum (fun b => (r b)^2)\n  · rw [rhs]\n    apply le_trans cauchy_schwarz _\n    calc B.card * B.sum (fun b => (r b)^2) = B.card * (T ∩ B).sum (fun b => (r b)^2) := by\n              suffices : B.sum (fun b => (r b)^2) = (T ∩ B).sum (fun b => (r b)^2)\n              · rw [this]\n              symm\n              rw [Finset.sum_subset ((Finset.inter_subset_right T B))]\n              intro x hx hx'\n              rw [pow_two]\n              have not_in : x ∉ T := fun hx'' => hx' (Finset.mem_inter_of_mem hx'' hx)\n              have : ∀ y : G, y ∉ T → r y = 0\n              · intro y hy\n                rw [Finset.card_eq_zero, Finset.eq_empty_iff_forall_not_mem]\n                intro t ht\n                simp_rw [Finset.mem_filter] at ht hy\n                simp_rw [Finset.mem_image] at hy\n                apply hy ; use t\n              rw [this x not_in, mul_zero]\n        _ ≤ B.card * T.sum (fun b => (r b)^2) := by\n              apply Nat.mul_le_mul_left\n              rw [← Finset.sum_sdiff (Finset.inter_subset_left T B)]\n              apply Nat.le_add_left _ _\n        _ = B.card * E[A] := by rw [counting]\n  have := nat_cauchy_schwartz' B r (fun _ => 1)\n  have simp₁ : B.sum ((fun b => 1)^2) = B.card\n  · simp only [Pi.pow_apply, one_pow, Finset.sum_const, smul_eq_mul, mul_one]\n  have simp₂ : B.sum (r * fun g => 1) = B.sum r\n  · simp only [Finset.mem_product, and_imp, Prod.forall, Pi.mul_apply, mul_one]\n  rwa [simp₁, simp₂, mul_comm] at this\n\n\n-- These are provisional values of constants, subject to change.  May also want to localize these definitions to just this file\n\ndef C₁ := 2^4\ndef C₂ := 1\ndef C₃ := 2^10\ndef C₄ := 4\n\n/-- Let $G$ be an abelian group, and let $A$ be a finite non-empty set with $E(A) \\geq |A|^3 / K$ for some $K \\geq 1$.  Then there is a subset $A'$ of $A$ with $|A'| \\geq |A| / (C_1 K^{C_2})$ and $|A'-A'| \\leq C_3 K^{C_4} |A'|$ -/\nlemma bsg (A : Finset G) (K : ℝ) (hK: 0 < K) (hE: E[A] ≥ (A.card)^3 / K): ∃ A' : Finset G, A' ⊆ A ∧ A'.card ≥ A.card / (C₁ * K^C₂) ∧ (A' - A').card ≤ C₃ * K^C₄ * A'.card := sorry\n\nopen scoped BigOperators\nvariable {G G' : Type*} [AddCommGroup G] [Fintype G] [AddCommGroup G'] [Fintype G']\n  [ElementaryAddCommGroup G 2] [ElementaryAddCommGroup G' 2]\n\nlemma equiv_filter_graph (f : G → G') :\n    let A := (Set.graph f).toFinite.toFinset\n    (A ×ˢ A).filter (fun (a, a') ↦ a + a' ∈ A) ≃\n    { x : G × G | f (x.1 + x.2) = (f x.1) + (f x.2) } where\n  toFun := fun ⟨a, ha⟩ ↦ by\n    let A := (Set.graph f).toFinite.toFinset\n    use (a.1.1, a.2.1)\n    apply Finset.mem_filter.mp at ha\n    have h {a} (h' : a ∈ A) := (Set.mem_graph _).mp <| (Set.graph f).toFinite.mem_toFinset.mp h'\n    show f (a.1.1 + a.2.1) = (f a.1.1) + (f a.2.1)\n    rw [h (Finset.mem_product.mp ha.1).1, h (Finset.mem_product.mp ha.1).2]\n    exact h ha.2\n  invFun := fun ⟨a, ha⟩ ↦ by\n    use ((a.1, f a.1), (a.2, f a.2))\n    refine Finset.mem_filter.mpr ⟨Finset.mem_product.mpr ⟨?_, ?_⟩, ?_⟩\n    <;> apply (Set.graph f).toFinite.mem_toFinset.mpr\n    · exact ⟨a.1, rfl⟩\n    · exact ⟨a.2, rfl⟩\n    · exact (Set.mem_graph _).mpr ha\n  left_inv := fun ⟨x, hx⟩ ↦ by\n    apply Subtype.ext\n    show ((x.1.1, f x.1.1), x.2.1, f x.2.1) = x\n    obtain ⟨hx1, hx2⟩ := Finset.mem_product.mp (Finset.mem_filter.mp hx).1\n    rewrite [(Set.graph f).toFinite.mem_toFinset] at hx1 hx2\n    rw [(Set.mem_graph x.1).mp hx1, (Set.mem_graph x.2).mp hx2]\n  right_inv := fun _ ↦ rfl\n\n","proof":":= by\n  let A := (Set.graph f).toFinite.toFinset\n\n  have h_cs : ((A ×ˢ A).filter (fun (a, a') ↦ a + a' ∈ A) |>.card : ℝ) ^ 2 ≤\n      Finset.card A * E[A] := by norm_cast; convert cauchy_schwarz A A\n  rewrite [← Nat.card_eq_finsetCard, ← Nat.card_eq_finsetCard,\n    Nat.card_congr (equiv_filter_graph f)] at h_cs\n\n  have hA : Nat.card A = Nat.card G := by\n    rewrite [← Set.card_graph f, Nat.card_eq_finsetCard, Set.Finite.card_toFinset]; simp\n  have hA_pos : 0 < (Nat.card A : ℝ) := Nat.cast_pos.mpr <| Nat.card_pos.trans_eq hA.symm\n  have : ((Nat.card G)^2 / K)^2 ≤ Nat.card A * E[A] := LE.le.trans (by gcongr) h_cs\n  rewrite [← hA] at this\n  replace : E[A] ≥ (Finset.card A)^3 / K^2 := calc\n    _ ≥ ((Nat.card A)^2 / K)^2 / Nat.card A := (div_le_iff' <| hA_pos).mpr this\n    _ = ((Nat.card A)^4 / (Nat.card A)) / K^2 := by ring\n    _ = (Finset.card A)^3 / K^2 := by\n      rw [pow_succ, mul_comm, mul_div_assoc, div_self (ne_of_gt hA_pos), mul_one,\n        Nat.card_eq_finsetCard]\n  obtain ⟨A', hA', hA'1, hA'2⟩ := bsg A (K^2) (sq_pos_of_pos hK) (by convert this)\n  clear h_cs hf this\n\n  let A'' := A'.toSet\n  have hA''_coe : Nat.card A'' = Finset.card A' := Nat.card_eq_finsetCard A'\n  have h_pos1 : 0 < (C₁ : ℝ) * (K ^ 2) ^ C₂ :=\n    mul_pos (by unfold C₁; norm_num) (pow_pos (pow_pos hK 2) C₂)\n  have hA''_pos : 0 < Nat.card A'' := by\n    rewrite [hA''_coe, ← Nat.cast_pos (α := ℝ)]\n    exact LT.lt.trans_le (div_pos (by rwa [← Nat.card_eq_finsetCard]) h_pos1) hA'1\n  have hA''_nonempty : Set.Nonempty A'' := nonempty_subtype.mp (Finite.card_pos_iff.mp hA''_pos)\n  have : Finset.card (A' - A') = Nat.card (A'' + A'') := calc\n    _ = Nat.card (A' - A').toSet := (Nat.card_eq_finsetCard _).symm\n    _ = Nat.card (A'' + A'') := by rw [Finset.coe_sub, sumset_eq_sub]\n  replace :  Nat.card (A'' + A'') ≤ C₃ * (K ^ 2) ^ C₄ * (Nat.card A'') := by\n    rewrite [← this, hA''_coe]\n    convert hA'2\n  obtain ⟨H, c, hc_card, hH_le, hH_ge, hH_cover⟩ := PFR_conjecture_improv_aux hA''_nonempty this\n  clear hA'2 hA''_coe hH_le hH_ge hA_pos\n  obtain ⟨H₀, H₁, φ, hH₀H₁, hH₀H₁_card⟩ := goursat H\n\n  have h_le_H₀ : Nat.card A'' ≤ Nat.card c * Nat.card H₀ := by\n    have h_le := Nat.card_mono (Set.toFinite _) (Set.image_subset Prod.fst hH_cover)\n    have h_proj_A'' : Nat.card A'' = Nat.card (Prod.fst '' A'') := Nat.card_congr\n      (Equiv.Set.imageOfInjOn Prod.fst A'' <|\n        Set.InjOn.mono (Set.Finite.subset_toFinset.mp hA') (Set.fst_injOn_graph f))\n    have h_proj_c : Prod.fst '' (c + H : Set (G × G')) = (Prod.fst '' c) + H₀ := by\n      ext x ; constructor <;> intro hx\n      · obtain ⟨x, ⟨⟨c, hc, h, hh, hch⟩, hx⟩⟩ := hx\n        rewrite [← hx]\n        exact ⟨c.1, Set.mem_image_of_mem Prod.fst hc, h.1, ((hH₀H₁ h).mp hh).1, (Prod.ext_iff.mp hch).1⟩\n      · obtain ⟨_, ⟨c, hc⟩, h, hh, hch⟩ := hx\n        refine ⟨c + Prod.mk h (φ h), ⟨⟨c, hc.1, Prod.mk h (φ h), ?_⟩, by rwa [← hc.2] at hch⟩⟩\n        exact ⟨(hH₀H₁ ⟨h, φ h⟩).mpr ⟨hh, by rw [sub_self]; apply zero_mem⟩, rfl⟩\n    rewrite [← h_proj_A'', h_proj_c] at h_le\n    apply (h_le.trans Set.card_add_le).trans\n    gcongr\n    exact Nat.card_image_le c.toFinite\n\n  have hH₀_pos : (0 : ℝ) < Nat.card H₀ := Nat.cast_pos.mpr Nat.card_pos\n  have h_le_H₁ : (Nat.card H₁ : ℝ) ≤ (Nat.card c) * (Nat.card H) / Nat.card A'' := calc\n    _ = (Nat.card H : ℝ) / (Nat.card H₀) :=\n      (eq_div_iff <| ne_of_gt <| hH₀_pos).mpr <| by rw [mul_comm, ← Nat.cast_mul, hH₀H₁_card]\n    _ ≤ (Nat.card c : ℝ) * (Nat.card H) / Nat.card A'' := by\n      nth_rewrite 1 [← mul_one (Nat.card H : ℝ), mul_comm (Nat.card c : ℝ)]\n      repeat rewrite [mul_div_assoc]\n      refine mul_le_mul_of_nonneg_left ?_ (Nat.cast_nonneg _)\n      refine le_of_mul_le_mul_right ?_ hH₀_pos\n      refine le_of_mul_le_mul_right ?_ (Nat.cast_pos.mpr hA''_pos)\n      rewrite [div_mul_cancel 1, mul_right_comm, one_mul,  div_mul_cancel, ← Nat.cast_mul]\n      · exact Nat.cast_le.mpr h_le_H₀\n      · exact ne_of_gt (Nat.cast_pos.mpr hA''_pos)\n      · exact ne_of_gt hH₀_pos\n  clear h_le_H₀ hA''_pos hH₀_pos hH₀H₁_card\n\n  let translate (c : G × G') (h : G') := A'' ∩ ({c} + {(0, h)} + Set.graph φ.toFun)\n  have h_translate (c : G × G') (h : G') :\n      Prod.fst '' translate c h ⊆ { x : G | f x = φ x + (-φ c.1 + c.2 + h) } := by\n    intro x hx\n    obtain ⟨x, ⟨⟨hxA'', ⟨_, ⟨c', hc, h', hh, hch⟩, x', hx, hchx⟩⟩, hxx⟩⟩ := hx\n    show f _ = φ _ + (-φ c.1 + c.2 + h)\n    replace := (Set.mem_graph x).mp <| (Set.graph f).toFinite.mem_toFinset.mp (hA' hxA'')\n    rewrite [← hxx, this, ← hchx, ← hch, hc, hh]\n    show c.2 + h + x'.2 = φ (c.1 + 0 + x'.1) + (-φ c.1 + c.2 + h)\n    replace : φ x'.1 = x'.2 := (Set.mem_graph x').mp hx\n    rw [map_add, map_add, map_zero, add_zero, this, add_comm (φ c.1), add_assoc x'.2,\n      ← add_assoc (φ c.1), ← add_assoc (φ c.1), add_neg_self, zero_add, add_comm]\n  have h_translate_card c h : Nat.card (translate c h) = Nat.card (Prod.fst '' translate c h) :=\n    Nat.card_congr (Equiv.Set.imageOfInjOn Prod.fst (translate c h) <|\n      Set.InjOn.mono (fun _ hx ↦ Set.Finite.subset_toFinset.mp hA' hx.1) (Set.fst_injOn_graph f))\n\n  let cH₁ := (c ×ˢ H₁).toFinite.toFinset\n  haveI A_nonempty : Nonempty A'' := Set.nonempty_coe_sort.mpr hA''_nonempty\n  replace : Nonempty c := by\n    obtain ⟨c, hc, _, _, _⟩ := hH_cover (Classical.choice A_nonempty).property\n    exact ⟨c, hc⟩\n  replace h_nonempty : Set.Nonempty (c ×ˢ H₁) :=\n    Set.Nonempty.prod (Set.nonempty_coe_sort.mp this) (Set.nonempty_coe_sort.mp inferInstance)\n  replace : A' = Finset.biUnion cH₁ fun ch ↦ (translate ch.1 ch.2).toFinite.toFinset := by\n    ext x ; constructor <;> intro hx\n    · obtain ⟨c', hc, h, hh, hch⟩ := hH_cover hx\n      refine Finset.mem_biUnion.mpr ⟨(c', h.2 - φ h.1), ?_⟩\n      refine ⟨(Set.Finite.mem_toFinset _).mpr ⟨hc, ((hH₀H₁ h).mp hh).2⟩, ?_⟩\n      refine (Set.Finite.mem_toFinset _).mpr ⟨hx, c' + (0, h.2 - φ h.1), ?_⟩\n      refine ⟨⟨c', rfl, (0, h.2 - φ h.1), rfl, rfl⟩, (h.1, φ h.1), ⟨h.1, rfl⟩, ?_⟩\n      beta_reduce\n      rewrite [add_assoc]\n      show c' + (0 + h.1, h.2 - φ h.1 + φ h.1) = x\n      rewrite [zero_add, sub_add_cancel]\n      exact hch\n    · obtain ⟨ch, hch⟩ := Finset.mem_biUnion.mp hx\n      exact ((Set.Finite.mem_toFinset _).mp hch.2).1\n\n  replace : ∑ __ in cH₁, ((Finset.card A) / (C₁ * (K ^ 2) ^ C₂) / cH₁.card : ℝ) ≤\n      ∑ ch in cH₁, ((translate ch.1 ch.2).toFinite.toFinset.card : ℝ) := by\n    rewrite [Finset.sum_const, nsmul_eq_mul, ← mul_div_assoc, mul_div_right_comm, div_self, one_mul]\n    · apply hA'1.trans\n      norm_cast\n      exact (congrArg Finset.card this).trans_le Finset.card_biUnion_le\n    · symm\n      refine ne_of_lt <| Nat.cast_zero.symm.trans_lt <| Nat.cast_lt.mpr <| Finset.card_pos.mpr ?_\n      exact (Set.Finite.toFinset_nonempty _).mpr h_nonempty\n  replace : ∃ c' : G × G', ∃ h : G', (Finset.card A) / (C₁ * (K ^ 2) ^ C₂) / cH₁.card ≤\n      Nat.card { x : G | f x = φ x + (-φ c'.1 + c'.2 + h) } := by\n    obtain ⟨ch, hch⟩ :=\n      Finset.exists_le_of_sum_le ((Set.Finite.toFinset_nonempty _).mpr h_nonempty) this\n    refine ⟨ch.1, ch.2, hch.2.trans ?_⟩\n    rewrite [Set.Finite.card_toFinset, ← Nat.card_eq_fintype_card, h_translate_card]\n    exact Nat.cast_le.mpr <| Nat.card_mono (Set.toFinite _) (h_translate ch.1 ch.2)\n  clear hA' hA'1 hH_cover hH₀H₁ translate h_translate h_translate_card\n\n  obtain ⟨c', h, hch⟩ := this\n  use φ, -φ c'.1 + c'.2 + h\n  refine LE.le.trans ?_ hch\n  unfold_let cH₁\n  rewrite [← Nat.card_eq_finsetCard, div_div, hA]\n  apply div_le_div_of_le_left (Nat.cast_nonneg _) <| mul_pos h_pos1 <| Nat.cast_pos.mpr <|\n    Finset.card_pos.mpr <| (Set.Finite.toFinset_nonempty _).mpr h_nonempty\n  rewrite [← c.toFinite.toFinset_prod (H₁ : Set G').toFinite, Finset.card_product]\n  repeat rewrite [Set.Finite.card_toFinset, ← Nat.card_eq_fintype_card]\n  rewrite [Nat.cast_mul, ← mul_assoc _ (Nat.card c : ℝ)]\n  replace := mul_nonneg h_pos1.le (Nat.cast_nonneg (Nat.card c))\n  apply (mul_le_mul_of_nonneg_left h_le_H₁ this).trans\n  rewrite [mul_div_assoc, ← mul_assoc, mul_comm _ (Nat.card c : ℝ), mul_assoc]\n  have hHA := div_nonneg (α := ℝ) (Nat.cast_nonneg (Nat.card H)) <| Nat.cast_nonneg (Nat.card A'')\n  apply (mul_le_mul_of_nonneg_right hc_card <| mul_nonneg this hHA).trans\n  rewrite [mul_comm, mul_assoc, mul_comm _ (Nat.card c : ℝ), mul_assoc]\n  refine (mul_le_mul_of_nonneg_right hc_card ?_).trans_eq ?_\n  · exact mul_nonneg h_pos1.le <| mul_nonneg hHA <| by positivity\n  have h_pos2 : 0 < (C₃ : ℝ) * (K ^ 2) ^ C₄ :=\n    mul_pos (by unfold C₃; norm_num) (pow_pos (pow_pos hK 2) C₄)\n  rewrite [mul_comm, mul_assoc, mul_assoc, mul_assoc, mul_mul_mul_comm,\n    ← Real.rpow_add (Nat.cast_pos.mpr Nat.card_pos), mul_mul_mul_comm,\n    ← Real.rpow_add (Nat.cast_pos.mpr Nat.card_pos), ← Real.rpow_add h_pos2]\n  norm_num\n  rewrite [mul_comm _ (Finset.card A' : ℝ), mul_assoc (Finset.card A' : ℝ),\n    ← mul_assoc _ (Finset.card A' : ℝ), div_mul_cancel _ <|\n    Nat.cast_ne_zero.mpr (Finset.card_pos.mpr hA''_nonempty).ne.symm, Real.rpow_neg_one,\n    mul_comm (Fintype.card H : ℝ), mul_assoc _ _ (Fintype.card H : ℝ),\n    inv_mul_cancel <| NeZero.natCast_ne _ _, mul_one, ← pow_mul,\n    Real.mul_rpow (by norm_num) (pow_nonneg (sq_nonneg K) C₄), ← pow_mul,\n    mul_comm (K ^ _), mul_assoc _ _ (K ^ _)]\n  repeat rewrite [show (12 : ℝ) = ((12 : ℕ) : ℝ) from rfl]\n  repeat rewrite [Real.rpow_nat_cast]\n  rewrite [← pow_mul, ← pow_add, mul_right_comm, ← mul_assoc]\n  norm_num","declId":"PFR.ApproxHomPFR.179_0.N2CNz2HCkx04Gbg","decl":"set_option maxHeartbeats 400000 in\n/-- Let $G, G'$ be finite abelian $2$-groups.\nLet $f: G \\to G'$ be a function, and suppose that there are at least\n$|G|^2 / K$ pairs $(x,y) \\in G^2$ such that $$ f(x+y) = f(x) + f(y).$$\nThen there exists a homomorphism $\\phi: G \\to G'$ and a constant $c \\in G'$ such that\n$f(x) = \\phi(x)+c$ for at least $|G| / C_1 C_3^{12} K^{24C_4 + 2C_2}$ values of $x \\in G$. -/\ntheorem approx_hom_pfr (f : G → G') (K : ℝ) (hK: K > 0)\n    (hf: Nat.card { x : G × G | f (x.1+x.2) = (f x.1) + (f x.2) } ≥ (Nat.card G)^2 / K) :\n    ∃ (φ : G →+ G') (c : G'), Nat.card { x : G | f x = φ x + c } ≥\n    (Nat.card G) / (C₁ * C₃^12 * K^(24 * C₄ + 2 * C₂)) "}
