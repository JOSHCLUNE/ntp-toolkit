{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Pi\n\nopen Function Set\nopen scoped BigOperators\n\nnamespace MeasureTheory.Measure\nvariable {ι : Type*} {α : ι → Type*} [Fintype ι] [∀ i, MeasurableSpace (α i)]\n  (μ : ∀ i, Measure (α i)) [∀ i, IsProbabilityMeasure (μ i)]\n\n","proof":":=\n  ⟨by simp_rw [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩","declId":"PFR.Mathlib.MeasureTheory.Constructions.Pi.10_0.hBXfdbXFtNqQpxu","decl":"instance : IsProbabilityMeasure (.pi μ) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Pi\n\nopen Function Set\nopen scoped BigOperators\n\nnamespace MeasureTheory.Measure\nvariable {ι : Type*} {α : ι → Type*} [Fintype ι] [∀ i, MeasurableSpace (α i)]\n  (μ : ∀ i, Measure (α i)) [∀ i, IsProbabilityMeasure (μ i)]\n\ninstance : IsProbabilityMeasure (.pi μ) :=\n  ⟨by simp_rw [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩\n\n","proof":":= by\n  classical\n  simp (config := {singlePass := true}) only [← pi_univ_ite]\n  simp_rw [pi_pi, apply_ite, measure_univ,\n    Finset.prod_ite, Finset.prod_const_one, mul_one]","declId":"PFR.Mathlib.MeasureTheory.Constructions.Pi.13_0.hBXfdbXFtNqQpxu","decl":"@[simp]\nlemma pi_pi_set (t : Set ι) [DecidablePred (· ∈ t)] (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in Finset.univ.filter (· ∈ t), μ i (s i) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Pi\n\nopen Function Set\nopen scoped BigOperators\n\nnamespace MeasureTheory.Measure\nvariable {ι : Type*} {α : ι → Type*} [Fintype ι] [∀ i, MeasurableSpace (α i)]\n  (μ : ∀ i, Measure (α i)) [∀ i, IsProbabilityMeasure (μ i)]\n\ninstance : IsProbabilityMeasure (.pi μ) :=\n  ⟨by simp_rw [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩\n\n@[simp]\nlemma pi_pi_set (t : Set ι) [DecidablePred (· ∈ t)] (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in Finset.univ.filter (· ∈ t), μ i (s i) := by\n  classical\n  simp (config := {singlePass := true}) only [← pi_univ_ite]\n  simp_rw [pi_pi, apply_ite, measure_univ,\n    Finset.prod_ite, Finset.prod_const_one, mul_one]\n\n","proof":":= by\n  classical\n  rw [pi_pi_set]\n  congr; ext x; simp","declId":"PFR.Mathlib.MeasureTheory.Constructions.Pi.21_0.hBXfdbXFtNqQpxu","decl":"@[simp]\nlemma pi_pi_finset (t : Finset ι) (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in t, μ i (s i) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Pi\n\nopen Function Set\nopen scoped BigOperators\n\nnamespace MeasureTheory.Measure\nvariable {ι : Type*} {α : ι → Type*} [Fintype ι] [∀ i, MeasurableSpace (α i)]\n  (μ : ∀ i, Measure (α i)) [∀ i, IsProbabilityMeasure (μ i)]\n\ninstance : IsProbabilityMeasure (.pi μ) :=\n  ⟨by simp_rw [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩\n\n@[simp]\nlemma pi_pi_set (t : Set ι) [DecidablePred (· ∈ t)] (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in Finset.univ.filter (· ∈ t), μ i (s i) := by\n  classical\n  simp (config := {singlePass := true}) only [← pi_univ_ite]\n  simp_rw [pi_pi, apply_ite, measure_univ,\n    Finset.prod_ite, Finset.prod_const_one, mul_one]\n\n@[simp]\nlemma pi_pi_finset (t : Finset ι) (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in t, μ i (s i) := by\n  classical\n  rw [pi_pi_set]\n  congr; ext x; simp\n\n","proof":":= by\n  classical\n  simp_rw [eval_preimage, pi_pi, apply_update (fun i ↦ μ i), measure_univ,\n    Finset.prod_update_of_mem (Finset.mem_univ _), Finset.prod_const_one, mul_one]","declId":"PFR.Mathlib.MeasureTheory.Constructions.Pi.28_0.hBXfdbXFtNqQpxu","decl":"@[simp]\nlemma pi_eval_preimage (i : ι) (s : Set (α i)) :\n    Measure.pi μ (eval i ⁻¹' s) = μ i s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Pi\n\nopen Function Set\nopen scoped BigOperators\n\nnamespace MeasureTheory.Measure\nvariable {ι : Type*} {α : ι → Type*} [Fintype ι] [∀ i, MeasurableSpace (α i)]\n  (μ : ∀ i, Measure (α i)) [∀ i, IsProbabilityMeasure (μ i)]\n\ninstance : IsProbabilityMeasure (.pi μ) :=\n  ⟨by simp_rw [Measure.pi_univ, measure_univ, Finset.prod_const_one]⟩\n\n@[simp]\nlemma pi_pi_set (t : Set ι) [DecidablePred (· ∈ t)] (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in Finset.univ.filter (· ∈ t), μ i (s i) := by\n  classical\n  simp (config := {singlePass := true}) only [← pi_univ_ite]\n  simp_rw [pi_pi, apply_ite, measure_univ,\n    Finset.prod_ite, Finset.prod_const_one, mul_one]\n\n@[simp]\nlemma pi_pi_finset (t : Finset ι) (s : ∀ i, Set (α i)) :\n    Measure.pi μ (pi t s) = ∏ i in t, μ i (s i) := by\n  classical\n  rw [pi_pi_set]\n  congr; ext x; simp\n\n@[simp]\nlemma pi_eval_preimage (i : ι) (s : Set (α i)) :\n    Measure.pi μ (eval i ⁻¹' s) = μ i s := by\n  classical\n  simp_rw [eval_preimage, pi_pi, apply_update (fun i ↦ μ i), measure_univ,\n    Finset.prod_update_of_mem (Finset.mem_univ _), Finset.prod_const_one, mul_one]\n\n","proof":":= by\n  ext s hs\n  simp_rw [Measure.map_apply (measurable_pi_apply i) hs, pi_eval_preimage]","declId":"PFR.Mathlib.MeasureTheory.Constructions.Pi.35_0.hBXfdbXFtNqQpxu","decl":"lemma map_eval_pi (i : ι) : Measure.map (eval i) (Measure.pi μ) = μ i "}
