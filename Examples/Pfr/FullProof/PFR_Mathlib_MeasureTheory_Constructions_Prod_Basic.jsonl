{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\n\nopen Function\nopen scoped ENNReal NNReal\n\nnamespace MeasureTheory.Measure\nvariable {Ω α β γ : Type*} [MeasurableSpace Ω]\n  [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ] {X : Ω → α} {Y : Ω → β} {Z : Ω → γ}\n\n","proof":":= by\n  ext s hs\n  rw [Measure.map_apply (hZ.prod_mk hX) hs, Measure.comap_apply _ Prod.swap_injective _ _ hs]\n  · rw [Measure.map_apply (hX.prod_mk hZ)]\n    · congr with ω\n      simp only [Set.image_swap_eq_preimage_swap, Set.mem_preimage, Prod.swap_prod_mk]\n    · exact MeasurableEquiv.prodComm.measurableEmbedding.measurableSet_image' hs\n  · exact fun t ht ↦ MeasurableEquiv.prodComm.measurableEmbedding.measurableSet_image' ht","declId":"PFR.Mathlib.MeasureTheory.Constructions.Prod.Basic.10_0.cTHqAOY2V3GeK0M","decl":"/-- The law of $(X, Z)$ is the image of the law of $(Z,X)$.-/\nlemma map_prod_comap_swap (hX : Measurable X) (hZ : Measurable Z) (μ : Measure Ω) :\n    (μ.map (fun ω ↦ (X ω, Z ω))).comap Prod.swap = μ.map (fun ω ↦ (Z ω, X ω)) "}
