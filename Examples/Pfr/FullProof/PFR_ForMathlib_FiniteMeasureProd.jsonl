{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n","proof":":=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩","declId":"PFR.ForMathlib.FiniteMeasureProd.18_0.ifI7fmS9pHEbI3Z","decl":"/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n","proof":":= rfl","declId":"PFR.ForMathlib.FiniteMeasureProd.24_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\n","proof":":= by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.26_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\n","proof":":= by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.30_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\n","proof":":= by simp","declId":"PFR.ForMathlib.FiniteMeasureProd.34_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\n","proof":":= by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)","declId":"PFR.ForMathlib.FiniteMeasureProd.36_0.ifI7fmS9pHEbI3Z","decl":"lemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\n","proof":":= by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]","declId":"PFR.ForMathlib.FiniteMeasureProd.41_0.ifI7fmS9pHEbI3Z","decl":"lemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\n","proof":":= by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]","declId":"PFR.ForMathlib.FiniteMeasureProd.44_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm","declId":"PFR.ForMathlib.FiniteMeasureProd.47_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm","declId":"PFR.ForMathlib.FiniteMeasureProd.55_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.64_0.ifI7fmS9pHEbI3Z","decl":"lemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\n","proof":":= by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)","declId":"PFR.ForMathlib.FiniteMeasureProd.71_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\n","proof":":= by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con","declId":"PFR.ForMathlib.FiniteMeasureProd.87_0.ifI7fmS9pHEbI3Z","decl":"lemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\n","proof":":= by\n  apply Subtype.ext\n  simp [Measure.prod_swap]","declId":"PFR.ForMathlib.FiniteMeasureProd.104_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n","proof":":=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩","declId":"PFR.ForMathlib.FiniteMeasureProd.118_0.ifI7fmS9pHEbI3Z","decl":"/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n","proof":":= rfl","declId":"PFR.ForMathlib.FiniteMeasureProd.125_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\n","proof":":= by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.127_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\n","proof":":= by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.131_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\n","proof":":= by simp","declId":"PFR.ForMathlib.FiniteMeasureProd.135_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\n","proof":":= by\n  exact measurable_fst","declId":"PFR.ForMathlib.FiniteMeasureProd.137_0.ifI7fmS9pHEbI3Z","decl":"example : Measurable (Prod.fst : α × β → α) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]","declId":"PFR.ForMathlib.FiniteMeasureProd.140_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_snd_prod,\n             measure_univ, one_smul]","declId":"PFR.ForMathlib.FiniteMeasureProd.145_0.ifI7fmS9pHEbI3Z","decl":"@[simp] lemma map_snd_prod : (μ.prod ν).map measurable_snd.aemeasurable = ν "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map measurable_snd.aemeasurable = ν := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_snd_prod,\n             measure_univ, one_smul]\n\n","proof":":= by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]","declId":"PFR.ForMathlib.FiniteMeasureProd.150_0.ifI7fmS9pHEbI3Z","decl":"lemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g) :\n    (μ.map f_mble.aemeasurable).prod (ν.map g_mble.aemeasurable)\n      = (μ.prod ν).map (f_mble.prod_map g_mble).aemeasurable "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map measurable_snd.aemeasurable = ν := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_snd_prod,\n             measure_univ, one_smul]\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g) :\n    (μ.map f_mble.aemeasurable).prod (ν.map g_mble.aemeasurable)\n      = (μ.prod ν).map (f_mble.prod_map g_mble).aemeasurable := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\n","proof":":= by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)","declId":"PFR.ForMathlib.FiniteMeasureProd.158_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map measurable_snd.aemeasurable = ν := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_snd_prod,\n             measure_univ, one_smul]\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g) :\n    (μ.map f_mble.aemeasurable).prod (ν.map g_mble.aemeasurable)\n      = (μ.prod ν).map (f_mble.prod_map g_mble).aemeasurable := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\n","proof":":= by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con","declId":"PFR.ForMathlib.FiniteMeasureProd.174_0.ifI7fmS9pHEbI3Z","decl":"lemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Measure.ProbabilityMeasure\nimport Mathlib.MeasureTheory.Constructions.Prod.Basic\n\n/-!\n# Products of finite measures and probability measures\n\n-/\n\nopen MeasureTheory Topology Metric Filter Set ENNReal NNReal\n\nopen scoped Topology ENNReal NNReal BoundedContinuousFunction BigOperators\n\nnamespace MeasureTheory\nsection FiniteMeasure_product\nnamespace FiniteMeasure\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of finite measures. -/\nnoncomputable def prod (μ : FiniteMeasure α) (ν : FiniteMeasure β) : FiniteMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsFiniteMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : FiniteMeasure α) (ν : FiniteMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nlemma mass_prod : (μ.prod ν).mass = μ.mass * ν.mass := by\n  simp only [mass, univ_prod_univ.symm, toMeasure_prod]\n  rw [← ENNReal.toNNReal_mul]\n  exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)\n\nlemma zero_prod : (0 : FiniteMeasure α).prod ν = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, zero_mul]\n\nlemma prod_zero : μ.prod (0 : FiniteMeasure β) = 0 := by\n  rw [← mass_zero_iff, mass_prod, zero_mass, mul_zero]\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map Prod.fst = (ν univ) • μ := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply α _ ℝ≥0 _ _ _ _ _ (ν univ) μ s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map Prod.snd = (μ univ) • ν := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod]\n  ext s _\n  simp only [Measure.map_snd_prod, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n    Pi.smul_apply, smul_eq_mul]\n  have aux := @coeFn_smul_apply β _ ℝ≥0 _ _ _ _ _ (μ univ) ν s\n  simpa using congr_arg ENNReal.ofNNReal aux.symm\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g):\n    (μ.map f).prod (ν.map g) = (μ.prod ν).map (Prod.map f g) := by\n  apply Subtype.ext\n  simp only [val_eq_toMeasure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\nlemma prod_swap : (μ.prod ν).map Prod.swap = ν.prod μ := by\n  apply Subtype.ext\n  simp [Measure.prod_swap]\n\nend FiniteMeasure -- namespace\n\nend FiniteMeasure_product -- section\n\nsection ProbabilityMeasure_product\n\nnamespace ProbabilityMeasure\n\nvariable {α : Type*} [MeasurableSpace α] {β : Type*} [MeasurableSpace β]\n\n/-- The binary product of probability measures. -/\nnoncomputable def prod (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β) :\n    ProbabilityMeasure (α × β) :=\n  ⟨μ.toMeasure.prod ν.toMeasure, Measure.prod.instIsProbabilityMeasure μ.toMeasure ν.toMeasure⟩\n\nvariable (μ : ProbabilityMeasure α) (ν : ProbabilityMeasure β)\n\n@[simp] lemma toMeasure_prod : (μ.prod ν).toMeasure = μ.toMeasure.prod ν.toMeasure := rfl\n\nlemma prod_apply (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ x, ν.toMeasure (Prod.mk x ⁻¹' s) ∂μ) := by\n  simp [@Measure.prod_apply α β _ _ μ ν _ s s_mble]\n\nlemma prod_apply_symm (s : Set (α × β)) (s_mble : MeasurableSet s) :\n    μ.prod ν s = ENNReal.toNNReal (∫⁻ y, μ.toMeasure ((fun x ↦ ⟨x, y⟩) ⁻¹' s) ∂ν) := by\n  simp [@Measure.prod_apply_symm α β _ _ μ ν _ _ s s_mble]\n\nlemma prod_prod (s : Set α) (t : Set β) : μ.prod ν (s ×ˢ t) = μ s * ν t := by simp\n\nexample : Measurable (Prod.fst : α × β → α) := by\n  exact measurable_fst\n\n@[simp] lemma map_fst_prod : (μ.prod ν).map measurable_fst.aemeasurable = μ := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_fst_prod,\n             measure_univ, one_smul]\n\n@[simp] lemma map_snd_prod : (μ.prod ν).map measurable_snd.aemeasurable = ν := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_map, toMeasure_prod, Measure.map_snd_prod,\n             measure_univ, one_smul]\n\nlemma map_prod_map {α' : Type*} [MeasurableSpace α'] {β' : Type*} [MeasurableSpace β']\n    {f : α → α'} {g : β → β'} (f_mble : Measurable f) (g_mble : Measurable g) :\n    (μ.map f_mble.aemeasurable).prod (ν.map g_mble.aemeasurable)\n      = (μ.prod ν).map (f_mble.prod_map g_mble).aemeasurable := by\n  apply Subtype.ext\n  simp only [val_eq_to_measure, toMeasure_prod, toMeasure_map]\n  rw [Measure.map_prod_map _ _ f_mble g_mble]\n\nlemma prod_apply_null {s : Set (α × β)} (hs : MeasurableSet s) :\n    μ.prod ν s = 0 ↔ (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) hs\n  · simp only [toMeasure_prod, toNNReal_eq_zero_iff, or_iff_left_iff_imp]\n    intro con\n    by_contra\n    exact measure_ne_top _ _ con\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n\nlemma measure_ae_null_of_prod_null {s : Set (α × β)} (h : μ.prod ν s = 0) :\n    (fun x ↦ ν (Prod.mk x ⁻¹' s)) =ᵐ[μ] 0 := by\n  convert Measure.measure_ae_null_of_prod_null (μ := μ.toMeasure) (ν := ν.toMeasure) (s := s) ?_\n  · constructor <;> intro h <;> filter_upwards [h] with p hp\n    · simp only [Pi.zero_apply] at *\n      rcases (ENNReal.toNNReal_eq_zero_iff _).mp hp with (h'|con)\n      · exact h'\n      · by_contra\n        exact measure_ne_top _ _ con\n    · simp only [Pi.zero_apply] at *\n      exact (ENNReal.toNNReal_eq_zero_iff _).mpr (Or.inl hp)\n  · simp [toNNReal_eq_zero_iff] at h\n    rcases h with (h'|con)\n    · exact h'\n    · by_contra\n      exact measure_ne_top _ _ con\n\n","proof":":= by\n  apply Subtype.ext\n  simp [Measure.prod_swap]","declId":"PFR.ForMathlib.FiniteMeasureProd.191_0.ifI7fmS9pHEbI3Z","decl":"lemma prod_swap : (μ.prod ν).map measurable_swap.aemeasurable = ν.prod μ "}
