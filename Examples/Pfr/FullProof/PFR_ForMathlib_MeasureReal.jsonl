{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n","proof":":= by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/","declId":"PFR.ForMathlib.MeasureReal.5_0.TFMIpVlQgElPqSx","decl":"/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n","proof":":= by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp","declId":"PFR.ForMathlib.MeasureReal.31_0.TFMIpVlQgElPqSx","decl":"@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n","proof":":= by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp","declId":"PFR.ForMathlib.MeasureReal.40_0.TFMIpVlQgElPqSx","decl":"@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\n","proof":":= by\n  simp","declId":"PFR.ForMathlib.MeasureReal.49_0.TFMIpVlQgElPqSx","decl":"lemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\n","proof":":= by\n  simp","declId":"PFR.ForMathlib.MeasureReal.56_0.TFMIpVlQgElPqSx","decl":"lemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n","proof":":= by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]","declId":"PFR.ForMathlib.MeasureReal.63_0.TFMIpVlQgElPqSx","decl":"/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n","proof":":=\n  (μ s).toReal","declId":"PFR.ForMathlib.MeasureReal.77_0.TFMIpVlQgElPqSx","decl":"/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\n","proof":":= rfl","declId":"PFR.ForMathlib.MeasureReal.82_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\n","proof":":=\n  (measure_lt_top_of_subset h ht).ne","declId":"PFR.ForMathlib.MeasureReal.89_0.TFMIpVlQgElPqSx","decl":"theorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\n","proof":":= by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩","declId":"PFR.ForMathlib.MeasureReal.92_0.TFMIpVlQgElPqSx","decl":"theorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\n","proof":":=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)","declId":"PFR.ForMathlib.MeasureReal.98_0.TFMIpVlQgElPqSx","decl":"theorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\n","proof":":= by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]","declId":"PFR.ForMathlib.MeasureReal.103_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_eq_zero_iff (h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n","proof":":= by\n  simp [measureReal_def]","declId":"PFR.ForMathlib.MeasureReal.108_0.TFMIpVlQgElPqSx","decl":"@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n","proof":":= ENNReal.toReal_nonneg","declId":"PFR.ForMathlib.MeasureReal.111_0.TFMIpVlQgElPqSx","decl":"@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n","proof":":=\n  by simp [Measure.real]","declId":"PFR.ForMathlib.MeasureReal.113_0.TFMIpVlQgElPqSx","decl":"@[simp] theorem measureReal_empty : μ.real ∅ = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n","proof":":= by\n  simp [Measure.real]","declId":"PFR.ForMathlib.MeasureReal.116_0.TFMIpVlQgElPqSx","decl":"@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\n","proof":":= by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness","declId":"PFR.ForMathlib.MeasureReal.120_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\n","proof":":=\n  measureReal_univ_pos.ne'","declId":"PFR.ForMathlib.MeasureReal.126_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\n","proof":":=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty","declId":"PFR.ForMathlib.MeasureReal.129_0.TFMIpVlQgElPqSx","decl":"theorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n","proof":":= by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl","declId":"PFR.ForMathlib.MeasureReal.132_0.TFMIpVlQgElPqSx","decl":"@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\n","proof":":= by\n  rw [measureReal_def, map_apply hf hs]\n  rfl","declId":"PFR.ForMathlib.MeasureReal.136_0.TFMIpVlQgElPqSx","decl":"theorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n","proof":":= by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)","declId":"PFR.ForMathlib.MeasureReal.141_0.TFMIpVlQgElPqSx","decl":"@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\n","proof":":= by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]","declId":"PFR.ForMathlib.MeasureReal.145_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\n","proof":":= by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne","declId":"PFR.ForMathlib.MeasureReal.150_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\n","proof":":= by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h","declId":"PFR.ForMathlib.MeasureReal.156_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\n","proof":":= by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)","declId":"PFR.ForMathlib.MeasureReal.161_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\n","proof":":= by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)","declId":"PFR.ForMathlib.MeasureReal.170_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\n","proof":":= by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp","declId":"PFR.ForMathlib.MeasureReal.179_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\n","proof":":= by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl","declId":"PFR.ForMathlib.MeasureReal.184_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\n","proof":":= by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])","declId":"PFR.ForMathlib.MeasureReal.190_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n","proof":":= by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this","declId":"PFR.ForMathlib.MeasureReal.195_0.TFMIpVlQgElPqSx","decl":"@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n","proof":":= by\n  simp [Measure.real, measure_congr H]","declId":"PFR.ForMathlib.MeasureReal.204_0.TFMIpVlQgElPqSx","decl":"/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\n","proof":":= by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h","declId":"PFR.ForMathlib.MeasureReal.208_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl","declId":"PFR.ForMathlib.MeasureReal.216_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]","declId":"PFR.ForMathlib.MeasureReal.225_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]","declId":"PFR.ForMathlib.MeasureReal.230_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]","declId":"PFR.ForMathlib.MeasureReal.236_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\n","proof":":= by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]","declId":"PFR.ForMathlib.MeasureReal.241_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\n","proof":":= by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂","declId":"PFR.ForMathlib.MeasureReal.246_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\n","proof":":= by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂","declId":"PFR.ForMathlib.MeasureReal.251_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\n","proof":":= by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h","declId":"PFR.ForMathlib.MeasureReal.256_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\n","proof":":= by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)","declId":"PFR.ForMathlib.MeasureReal.264_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂","declId":"PFR.ForMathlib.MeasureReal.269_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂","declId":"PFR.ForMathlib.MeasureReal.274_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂","declId":"PFR.ForMathlib.MeasureReal.279_0.TFMIpVlQgElPqSx","decl":"lemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)","declId":"PFR.ForMathlib.MeasureReal.287_0.TFMIpVlQgElPqSx","decl":"lemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\n","proof":":=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet","declId":"PFR.ForMathlib.MeasureReal.298_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\n","proof":":= by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]","declId":"PFR.ForMathlib.MeasureReal.302_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\n","proof":":= by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h","declId":"PFR.ForMathlib.MeasureReal.308_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n","proof":":= by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]","declId":"PFR.ForMathlib.MeasureReal.313_0.TFMIpVlQgElPqSx","decl":"/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n","proof":":=\n  Finset.sum_toReal_measure_singleton ..","declId":"PFR.ForMathlib.MeasureReal.320_0.TFMIpVlQgElPqSx","decl":"/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\n","proof":":= by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'","declId":"PFR.ForMathlib.MeasureReal.327_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\n","proof":":= by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne","declId":"PFR.ForMathlib.MeasureReal.334_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]","declId":"PFR.ForMathlib.MeasureReal.340_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\n","proof":":= by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring","declId":"PFR.ForMathlib.MeasureReal.346_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\n","proof":":= by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]","declId":"PFR.ForMathlib.MeasureReal.352_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\n","proof":":= by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _","declId":"PFR.ForMathlib.MeasureReal.357_0.TFMIpVlQgElPqSx","decl":"theorem le_measureReal_diff (h : μ s₂ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\n","proof":":= by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith","declId":"PFR.ForMathlib.MeasureReal.365_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\n","proof":":= by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]","declId":"PFR.ForMathlib.MeasureReal.370_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\n","proof":":= by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]","declId":"PFR.ForMathlib.MeasureReal.375_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\n","proof":":= by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]","declId":"PFR.ForMathlib.MeasureReal.381_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\n","proof":":= by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1","declId":"PFR.ForMathlib.MeasureReal.389_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\n","proof":":= by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2","declId":"PFR.ForMathlib.MeasureReal.395_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\n","proof":":= by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁","declId":"PFR.ForMathlib.MeasureReal.400_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\n","proof":":= by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ","declId":"PFR.ForMathlib.MeasureReal.405_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\n","proof":":= by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H","declId":"PFR.ForMathlib.MeasureReal.414_0.TFMIpVlQgElPqSx","decl":"theorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n","proof":":= by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne","declId":"PFR.ForMathlib.MeasureReal.422_0.TFMIpVlQgElPqSx","decl":"/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n","proof":":= by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩","declId":"PFR.ForMathlib.MeasureReal.436_0.TFMIpVlQgElPqSx","decl":"/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n","proof":":= by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu","declId":"PFR.ForMathlib.MeasureReal.449_0.TFMIpVlQgElPqSx","decl":"/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\n","proof":":= by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]","declId":"PFR.ForMathlib.MeasureReal.460_0.TFMIpVlQgElPqSx","decl":"theorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\ntheorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t := by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]\n\n-- find this in library?  generalize?\n","proof":":= by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    ext s\n    have hs : Set.Finite s := Set.toFinite s\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]","declId":"PFR.ForMathlib.MeasureReal.466_0.TFMIpVlQgElPqSx","decl":"/-- Generalized in Measure.ext_iff_singleton_finiteSupport at Entropy.Measure -/\ntheorem Measure.ext_iff_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\ntheorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t := by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]\n\n-- find this in library?  generalize?\n/-- Generalized in Measure.ext_iff_singleton_finiteSupport at Entropy.Measure -/\ntheorem Measure.ext_iff_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    ext s\n    have hs : Set.Finite s := Set.toFinite s\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\n","proof":":= by\n  rw [Measure.ext_iff_singleton]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]","declId":"PFR.ForMathlib.MeasureReal.480_0.TFMIpVlQgElPqSx","decl":"theorem ext_iff_measureReal_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\ntheorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t := by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]\n\n-- find this in library?  generalize?\n/-- Generalized in Measure.ext_iff_singleton_finiteSupport at Entropy.Measure -/\ntheorem Measure.ext_iff_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    ext s\n    have hs : Set.Finite s := Set.toFinite s\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem ext_iff_measureReal_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nend MeasureTheory\n\nnamespace Mathlib.Meta.Positivity\n\nopen Lean Meta Qq Function\n\n","proof":":= do\n  let .app (.app _ a) b ← whnfR e | throwError \"not measureReal\"\n  let p ← mkAppOptM ``MeasureTheory.measureReal_nonneg #[none, none, a, b]\n  pure (.nonnegative p)","declId":"PFR.ForMathlib.MeasureReal.496_0.TFMIpVlQgElPqSx","decl":"/-- Extension for the `positivity` tactic: applications of `μ.real` are nonnegative. -/\n@[positivity MeasureTheory.Measure.real _ _]\ndef evalMeasureReal : PositivityExt where eval {_ _} _zα _pα e "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\ntheorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t := by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]\n\n-- find this in library?  generalize?\n/-- Generalized in Measure.ext_iff_singleton_finiteSupport at Entropy.Measure -/\ntheorem Measure.ext_iff_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    ext s\n    have hs : Set.Finite s := Set.toFinite s\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem ext_iff_measureReal_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nend MeasureTheory\n\nnamespace Mathlib.Meta.Positivity\n\nopen Lean Meta Qq Function\n\n/-- Extension for the `positivity` tactic: applications of `μ.real` are nonnegative. -/\n@[positivity MeasureTheory.Measure.real _ _]\ndef evalMeasureReal : PositivityExt where eval {_ _} _zα _pα e := do\n  let .app (.app _ a) b ← whnfR e | throwError \"not measureReal\"\n  let p ← mkAppOptM ``MeasureTheory.measureReal_nonneg #[none, none, a, b]\n  pure (.nonnegative p)\n\nend Mathlib.Meta.Positivity\nsection aux_lemmas\n\n","proof":":= by\n  rw [measureReal_def, measure_preimage_fst_singleton_eq_sum, ENNReal.toReal_sum]\n  · rfl\n  intros\n  finiteness","declId":"PFR.ForMathlib.MeasureReal.506_0.TFMIpVlQgElPqSx","decl":"lemma measureReal_preimage_fst_singleton_eq_sum {S T : Type*} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] [Fintype T] {_ : MeasurableSpace T}\n    [MeasurableSingletonClass T] (μ : Measure (S × T)) [IsFiniteMeasure μ] (x : S) :\n    μ.real (Prod.fst ⁻¹' {x}) = ∑ y : T, μ.real {(x, y)} "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Basic\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Tactic.Finiteness\n\n/-!\n# Measures as real valued-functions\n\nGiven a measure `μ`, we define `μ.real` as the function sending a set `s` to `(μ s).toReal`, and\ndevelop a basic API around this.\n\nWe essentially copy relevant lemmas from the files `MeasureSpaceDef.lean`, `NullMeasurable.lean` and\n`MeasureSpace.lean`, and adapt them by replacing in their name `measure` with `measureReal`.\n\nMany lemmas require an assumption that some set has finite measure. These assumptions are written\nin the form `(h : μ s ≠ ∞ := by finiteness)`, where `finiteness` is a new tactic (still in prototype\nform) for goals of the form `≠ ∞`.\n\nThere are certainly many missing lemmas. The idea is to add the missing ones as we notice that they\nwould be useful while doing the project.\n\nI haven't transferred any lemma involving infinite sums, as summability issues are really\nmore painful with reals than nonnegative extended reals. I don't expect we will need them in the\nproject, but we should probably add them back in the long run if they turn out to be useful.\n-/\n\nopen MeasureTheory Measure Set\nopen scoped ENNReal NNReal BigOperators\n\nsection aux_lemmas\n\n@[simp]\nlemma Finset.sum_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x in s, μ {x} = μ s := by\n  change ∑ x in s, μ (id ⁻¹' {x}) = _\n  rw [sum_measure_preimage_singleton]\n  · simp\n  · simp\n\n@[simp]\nlemma Finset.sum_toReal_measure_singleton {S : Type*} {s : Finset S} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x in s, (μ {x}).toReal = (μ s).toReal := by\n  rw [← ENNReal.toReal_sum (fun _ _ ↦ measure_ne_top _ _)]\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) :\n    ∑ x, μ {x} = μ Set.univ := by\n  simp\n\n-- probably don't need this version but it was stated previously and will need to search for and\n-- eliminate any explicit uses\nlemma sum_toReal_measure_singleton {S : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] (μ : Measure S) [IsFiniteMeasure μ] :\n    ∑ x : S, (μ {x}).toReal = (μ Set.univ).toReal := by\n  simp\n\nvariable [MeasurableSpace Ω]\n\n/-- Variant of `sum_measure_preimage_singleton` using real numbers rather than extended nonnegative\nreals. -/\nlemma sum_measure_preimage_singleton' (μ : Measure Ω) [IsProbabilityMeasure μ] {T : Type u}\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T] {Y : Ω → T} (hY : Measurable Y) :\n    ∑ y : T, (μ (Y ⁻¹' {y})).toReal = 1 := by\n  rw [← ENNReal.toReal_sum, sum_measure_preimage_singleton] <;>\n    simp [hY $ measurableSet_discrete _, measure_ne_top]\n\nend aux_lemmas\n\nnamespace MeasureTheory\n\nvariable {α : Type*} {β : Type*} {_ : MeasurableSpace α} [MeasurableSpace β] (μ : Measure α)\n\n/-- The real-valued version of a measure. Maps infinite measure sets to zero. Use as `μ.real s`. -/\n@[pp_dot]\nprotected def Measure.real (s : Set α) : ℝ :=\n  (μ s).toReal\n\ntheorem measureReal_def (s : Set α) : μ.real s = (μ s).toReal := rfl\n\nvariable {μ}\nvariable {s s₁ s₂ t : Set α}\n\nsection move_to_MeasureSpace.lean\n\ntheorem measure_ne_top_of_subset (h : s ⊆ t) (ht : μ t ≠ ∞) : μ s ≠ ∞ :=\n  (measure_lt_top_of_subset h ht).ne\n\ntheorem measure_diff_eq_top (hs : μ s = ∞) (ht : μ t ≠ ∞) : μ (s \\ t) = ∞ := by\n  contrapose! hs\n  apply ((measure_mono (subset_diff_union s t)).trans_lt _).ne\n  apply (measure_union_le _ _).trans_lt\n  exact ENNReal.add_lt_top.2 ⟨hs.lt_top, ht.lt_top⟩\n\ntheorem measure_symmDiff_eq_top (hs : μ s ≠ ∞) (ht : μ t = ∞) : μ (s ∆ t) = ∞ :=\n  measure_mono_top (subset_union_right _ _) (measure_diff_eq_top ht hs)\n\nend move_to_MeasureSpace.lean\n\ntheorem measureReal_eq_zero_iff (h : μ s ≠ ∞ := by finiteness) :\n    μ.real s = 0 ↔ μ s = 0 := by\n  rw [Measure.real, ENNReal.toReal_eq_zero_iff]\n  simp [h]\n\n@[simp] theorem measureReal_zero (s : Set α) : (0 : Measure α).real s = 0 := by\n  simp [measureReal_def]\n\n@[simp] theorem measureReal_nonneg : 0 ≤ μ.real s := ENNReal.toReal_nonneg\n\n@[simp] theorem measureReal_empty : μ.real ∅ = 0 :=\n  by simp [Measure.real]\n\n@[simp] theorem IsProbabilityMeasure.measureReal_univ [IsProbabilityMeasure μ] :\n    μ.real Set.univ = 1 := by\n  simp [Measure.real]\n\ntheorem measureReal_univ_pos [IsFiniteMeasure μ] [NeZero μ] : 0 < μ.real Set.univ := by\n  rw [measureReal_def]\n  apply ENNReal.toReal_pos\n  exact NeZero.ne (μ Set.univ)\n  finiteness\n\ntheorem measureReal_univ_ne_zero [IsFiniteMeasure μ] [NeZero μ] : μ.real Set.univ ≠ 0 :=\n  measureReal_univ_pos.ne'\n\ntheorem nonempty_of_measureReal_ne_zero (h : μ.real s ≠ 0) : s.Nonempty :=\n  nonempty_iff_ne_empty.2 fun h' => h <| h'.symm ▸ measureReal_empty\n\n@[simp] theorem measureReal_smul_apply (c : ℝ≥0∞) : (c • μ).real s = c.toReal • μ.real s := by\n  rw [measureReal_def, smul_apply, smul_eq_mul, ENNReal.toReal_mul]\n  rfl\n\ntheorem map_measureReal_apply {f : α → β} (hf : Measurable f) {s : Set β} (hs : MeasurableSet s) :\n    (μ.map f).real s = μ.real (f ⁻¹' s) := by\n  rw [measureReal_def, map_apply hf hs]\n  rfl\n\n@[gcongr] theorem measureReal_mono (h : s₁ ⊆ s₂) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ ≤ μ.real s₂ :=\n  ENNReal.toReal_mono h₂ (measure_mono h)\n\ntheorem measureReal_mono_null (h : s₁ ⊆ s₂) (h₂ : μ.real s₂ = 0) (h'₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ = 0 := by\n  rw [measureReal_eq_zero_iff h'₂] at h₂\n  simp [Measure.real, measure_mono_null h h₂]\n\ntheorem measureReal_le_measureReal_union_left (h : μ t ≠ ∞ := by finiteness) :\n    μ.real s ≤ μ.real (s ∪ t) := by\n  rcases eq_top_or_lt_top (μ s) with hs|hs\n  · simp [Measure.real, hs]\n  · exact measureReal_mono (subset_union_left _ _) (measure_union_lt_top hs h.lt_top).ne\n\ntheorem measureReal_le_measureReal_union_right (h : μ s ≠ ∞ := by finiteness) :\n    μ.real t ≤ μ.real (s ∪ t) := by\n  rw [union_comm]\n  exact measureReal_le_measureReal_union_left h\n\ntheorem measureReal_union_le (s₁ s₂ : Set α) : μ.real (s₁ ∪ s₂) ≤ μ.real s₁ + μ.real s₂ := by\n  rcases eq_top_or_lt_top (μ (s₁ ∪ s₂)) with h|h\n  · simp only [Measure.real, h, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · have A : μ s₁ ≠ ∞ := measure_ne_top_of_subset (subset_union_left _ _) h.ne\n    have B : μ s₂ ≠ ∞ := measure_ne_top_of_subset (subset_union_right _ _) h.ne\n    simp only [Measure.real, ← ENNReal.toReal_add A B]\n    exact ENNReal.toReal_mono (by simp [A, B]) (measure_union_le _ _)\n\ntheorem measureReal_biUnion_finset_le (s : Finset β) (f : β → Set α) :\n    μ.real (⋃ b ∈ s, f b) ≤ ∑ p in s, μ.real (f p) := by\n  classical\n  induction' s using Finset.induction_on with x s hx IH\n  · simp\n  · simp only [hx, Finset.mem_insert, iUnion_iUnion_eq_or_left, not_false_eq_true,\n      Finset.sum_insert]\n    exact (measureReal_union_le _ _).trans (by gcongr)\n\ntheorem measureReal_iUnion_fintype_le [Fintype β] (f : β → Set α) :\n    μ.real (⋃ b, f b) ≤ ∑ p, μ.real (f p) := by\n  convert measureReal_biUnion_finset_le Finset.univ f\n  simp\n\ntheorem measureReal_iUnion_fintype [Fintype β] {f : β → Set α} (hn : Pairwise (Disjoint on f))\n    (h : ∀ i, MeasurableSet (f i)) (h' : ∀ i, μ (f i) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b, f b) = ∑ p, μ.real (f p) := by\n  rw [measureReal_def, measure_iUnion hn h, tsum_fintype, ENNReal.toReal_sum (fun i _hi ↦ h' i)]\n  rfl\n\ntheorem measureReal_union_null (h₁ : μ.real s₁ = 0) (h₂ : μ.real s₂ = 0) :\n    μ.real (s₁ ∪ s₂) = 0 := by\n  apply le_antisymm _ measureReal_nonneg\n  exact (measureReal_union_le s₁ s₂).trans (by simp [h₁, h₂])\n\n@[simp]\ntheorem measureReal_union_null_iff\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = 0 ↔ μ.real s₁ = 0 ∧ μ.real s₂ = 0 := by\n  have : μ (s₁ ∪ s₂) ≠ ∞ := measure_union_ne_top h₁ h₂\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => measureReal_union_null h.1 h.2⟩\n  · exact measureReal_mono_null (subset_union_left _ _) h this\n  · exact measureReal_mono_null (subset_union_right _ _) h this\n\n/-- If two sets are equal modulo a set of measure zero, then `μ.real s = μ.real t`. -/\ntheorem measureReal_congr (H : s =ᵐ[μ] t) : μ.real s = μ.real t := by\n  simp [Measure.real, measure_congr H]\n\ntheorem measureReal_inter_add_diff₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff₀ s ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_union_add_inter₀ (s : Set α) (ht : NullMeasurableSet t μ)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  have : μ (s ∪ t) ≠ ∞ :=\n    ((measure_union_le _ _).trans_lt (ENNReal.add_lt_top.2 ⟨h₁.lt_top, h₂.lt_top⟩ )).ne\n  rw [← measureReal_inter_add_diff₀ (s ∪ t) ht this, Set.union_inter_cancel_right, union_diff_right,\n    ← measureReal_inter_add_diff₀ s ht h₁]\n  ac_rfl\n\ntheorem measureReal_union_add_inter₀' (hs : NullMeasurableSet s μ) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t := by\n  rw [union_comm, inter_comm, measureReal_union_add_inter₀ t hs h₂ h₁, add_comm]\n\ntheorem measureReal_union₀ (ht : NullMeasurableSet t μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  simp only [Measure.real]\n  rw [measure_union₀ ht hd, ENNReal.toReal_add h₁ h₂]\n\ntheorem measureReal_union₀' (hs : NullMeasurableSet s μ) (hd : AEDisjoint μ s t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) = μ.real s + μ.real t := by\n  rw [union_comm, measureReal_union₀ hs (AEDisjoint.symm hd) h₂ h₁, add_comm]\n\ntheorem measureReal_add_measureReal_compl₀ [IsFiniteMeasure μ] {s : Set α}\n    (hs : NullMeasurableSet s μ) :\n    μ.real s + μ.real sᶜ = μ.real univ := by\n  rw [← measureReal_union₀' hs aedisjoint_compl_right, union_compl_self]\n\ntheorem measureReal_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀ h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) (h₂ : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ s₂) = μ.real s₁ + μ.real s₂ :=\n  measureReal_union₀' h.nullMeasurableSet hd.aedisjoint h₁ h₂\n\ntheorem measureReal_inter_add_diff (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s ∩ t) + μ.real (s \\ t) = μ.real s := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_inter_add_diff _ ht]\n  · exact measure_ne_top_of_subset (inter_subset_left _ _) h\n  · exact measure_ne_top_of_subset (diff_subset _ _) h\n\ntheorem measureReal_diff_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h : μ s ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) + μ.real (s ∩ t) = μ.real s :=\n  (add_comm _ _).trans (measureReal_inter_add_diff s ht h)\n\ntheorem measureReal_union_add_inter (s : Set α) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀ s ht.nullMeasurableSet h₁ h₂\n\ntheorem measureReal_union_add_inter' (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∪ t) + μ.real (s ∩ t) = μ.real s + μ.real t :=\n  measureReal_union_add_inter₀' hs.nullMeasurableSet t h₁ h₂\n\nlemma measureReal_symmDiff_eq (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ t) = μ.real (s \\ t) + μ.real (t \\ s) := by\n  simp only [Measure.real]\n  rw [← ENNReal.toReal_add, measure_symmDiff_eq hs ht]\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₁\n  · exact measure_ne_top_of_subset (diff_subset _ _) h₂\n\nlemma measureReal_symmDiff_le (s t u : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s ∆ u) ≤ μ.real (s ∆ t) + μ.real (t ∆ u) := by\n  rcases eq_top_or_lt_top (μ u) with hu|hu\n  · have : μ (s ∆ u) = ∞ := measure_symmDiff_eq_top h₁ hu\n    simp only [measureReal_def, this, ENNReal.top_toReal]\n    exact add_nonneg ENNReal.toReal_nonneg ENNReal.toReal_nonneg\n  · apply le_trans _ (measureReal_union_le (s ∆ t) (t ∆ u))\n    apply measureReal_mono (symmDiff_triangle s t u) ?_\n    exact measure_union_ne_top (measure_symmDiff_ne_top h₁ h₂) (measure_symmDiff_ne_top h₂ hu.ne)\n\ntheorem measureReal_add_measureReal_compl [IsFiniteMeasure μ] (h : MeasurableSet s) :\n    μ.real s + μ.real sᶜ = μ.real univ :=\n  measureReal_add_measureReal_compl₀ h.nullMeasurableSet\n\ntheorem measureReal_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ)\n    (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) := by\n  simp only [measureReal_def, measure_biUnion_finset₀ hd hm, ENNReal.toReal_sum h]\n\ntheorem measureReal_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) (h : ∀ b ∈ s, μ (f b) ≠ ∞ := by finiteness) :\n    μ.real (⋃ b ∈ s, f b) = ∑ p in s, μ.real (f p) :=\n  measureReal_biUnion_finset₀ hd.aedisjoint (fun b hb ↦ (hm b hb).nullMeasurableSet) h\n\n/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measureReal_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) (h : ∀ a ∈ s, μ (f ⁻¹' {a}) ≠ ∞ := by finiteness) :\n    (∑ b in s, μ.real (f ⁻¹' {b})) = μ.real (f ⁻¹' ↑s) := by\n  simp only [measureReal_def, ← sum_measure_preimage_singleton s hf, ENNReal.toReal_sum h]\n\n/-- If `s` is a `Finset`, then the sums of the real measures of the singletons in the set is the\nreal measure of the set. -/\n@[simp] theorem Finset.sum_realMeasure_singleton [MeasurableSingletonClass α] [IsFiniteMeasure μ]\n    (s : Finset α) :\n    (∑ b in s, μ.real {b}) = μ.real s :=\n  Finset.sum_toReal_measure_singleton ..\n\ntheorem measureReal_diff_null' (h : μ.real (s₁ ∩ s₂) = 0) (h' : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  simp only [measureReal_def]\n  rw [measure_diff_null']\n  apply (measureReal_eq_zero_iff _).1 h\n  exact measure_ne_top_of_subset (inter_subset_left _ _) h'\n\ntheorem measureReal_diff_null (h : μ.real s₂ = 0) (h' : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ := by\n  rcases eq_top_or_lt_top (μ s₁) with H|H\n  · simp [measureReal_def, H, measure_diff_eq_top H h']\n  · exact measureReal_diff_null' (measureReal_mono_null (inter_subset_right _ _) h h') H.ne\n\ntheorem measureReal_add_diff (hs : MeasurableSet s) (t : Set α)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real s + μ.real (t \\ s) = μ.real (s ∪ t) := by\n  rw [← measureReal_union' (@disjoint_sdiff_right _ s t) hs h₁\n    (measure_ne_top_of_subset (diff_subset _ _) h₂), union_diff_self]\n\ntheorem measureReal_diff' (s : Set α) (hm : MeasurableSet t)\n    (h₁ : μ s ≠ ∞ := by finiteness) (h₂ : μ t ≠ ∞ := by finiteness) :\n    μ.real (s \\ t) = μ.real (s ∪ t) - μ.real t := by\n  rw [union_comm, ← measureReal_add_diff hm s h₂ h₁]\n  ring\n\ntheorem measureReal_diff (h : s₂ ⊆ s₁) (h₂ : MeasurableSet s₂)\n    (h₁ : μ s₁ ≠ ∞ := by finiteness) :\n    μ.real (s₁ \\ s₂) = μ.real s₁ - μ.real s₂ := by\n  rw [measureReal_diff' _ h₂ h₁ (measure_ne_top_of_subset h h₁), union_eq_self_of_subset_right h]\n\ntheorem le_measureReal_diff (h : μ s₂ ≠ ∞ := by finiteness) :\n    μ.real s₁ - μ.real s₂ ≤ μ.real (s₁ \\ s₂) := by\n  simp only [tsub_le_iff_left]\n  calc\n    μ.real s₁ ≤ μ.real (s₂ ∪ s₁) := measureReal_le_measureReal_union_right h\n    _ = μ.real (s₂ ∪ s₁ \\ s₂) := congr_arg μ.real union_diff_self.symm\n    _ ≤ μ.real s₂ + μ.real (s₁ \\ s₂) := measureReal_union_le _ _\n\ntheorem measureReal_diff_lt_of_lt_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (h : μ.real t < μ.real s + ε) (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) < ε := by\n  rw [measureReal_diff hst hs ht']; linarith\n\ntheorem measureReal_diff_le_iff_le_add (hs : MeasurableSet s) (hst : s ⊆ t) (ε : ℝ)\n    (ht' : μ t ≠ ∞ := by finiteness) :\n    μ.real (t \\ s) ≤ ε ↔ μ.real t ≤ μ.real s + ε := by\n  rw [measureReal_diff hst hs ht', tsub_le_iff_left]\n\ntheorem measureReal_eq_measureReal_of_null_diff {s t : Set α} (hst : s ⊆ t)\n    (h_nulldiff : μ.real (t \\ s) = 0) (h : μ (t \\ s) ≠ ∞ := by finiteness) :\n    μ.real s = μ.real t := by\n  rw [measureReal_eq_zero_iff h] at h_nulldiff\n  simp [measureReal_def, measure_eq_measure_of_null_diff hst h_nulldiff]\n\ntheorem measureReal_eq_measureReal_of_between_null_diff {s₁ s₂ s₃ : Set α}\n    (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ ∧ μ.real s₂ = μ.real s₃ := by\n  have A : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ :=\n    measure_eq_measure_of_between_null_diff h12 h23 ((measureReal_eq_zero_iff h').1 h_nulldiff)\n  simp [measureReal_def, A.1, A.2]\n\ntheorem measureReal_eq_measureReal_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0)\n    (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₁ = μ.real s₂ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').1\n\ntheorem measureReal_eq_measureReal_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ.real (s₃ \\ s₁) = 0) (h' : μ (s₃ \\ s₁) ≠ ∞ := by finiteness) :\n    μ.real s₂ = μ.real s₃ :=\n  (measureReal_eq_measureReal_of_between_null_diff h12 h23 h_nulldiff h').2\n\ntheorem measureReal_compl [IsFiniteMeasure μ] (h₁ : MeasurableSet s) :\n    μ.real sᶜ = μ.real univ - μ.real s := by\n  rw [compl_eq_univ_diff]\n  exact measureReal_diff (subset_univ s) h₁\n\ntheorem measureReal_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂)\n    (hsμ : μ.real s₂ ≤ μ.real s₁) (ht : t₁ ⊆ t₂) (htμ : μ.real t₂ ≤ μ.real t₁)\n    (h₁ : μ s₂ ≠ ∞ := by finiteness) (h₂ : μ t₂ ≠ ∞ := by finiteness) :\n    μ.real (s₁ ∪ t₁) = μ.real (s₂ ∪ t₂) := by\n  simp [measureReal_def]\n  rw [measure_union_congr_of_subset hs _ ht]\n  · exact (ENNReal.toReal_le_toReal h₂ (measure_ne_top_of_subset ht h₂)).1 htμ\n  · exact (ENNReal.toReal_le_toReal h₁ (measure_ne_top_of_subset hs h₁)).1 hsμ\n\ntheorem sum_measureReal_le_measureReal_univ [IsFiniteMeasure μ] {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, MeasurableSet (t i)) (H : Set.PairwiseDisjoint (↑s) t) :\n    (∑ i in s, μ.real (t i)) ≤ μ.real (univ : Set α) := by\n  simp only [measureReal_def]\n  rw [← ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n  apply ENNReal.toReal_mono (measure_ne_top _ _)\n  exact sum_measure_le_measure_univ h H\n\n/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i in s, μ.real (t i) > μ.real univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measureReal_univ_lt_sum_measureReal\n    {m : MeasurableSpace α} (μ : Measure α) [IsFiniteMeasure μ]\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, MeasurableSet (t i))\n    (H : μ.real (univ : Set α) < ∑ i in s, μ.real (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  apply exists_nonempty_inter_of_measure_univ_lt_sum_measure μ h\n  apply (ENNReal.toReal_lt_toReal (measure_ne_top _ _) _).1\n  · convert H\n    rw [ENNReal.toReal_sum (fun i hi ↦ measure_ne_top _ _)]\n    rfl\n  · exact (ENNReal.sum_lt_top (fun i hi ↦ measure_ne_top _ _)).ne\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  apply nonempty_inter_of_measure_lt_add μ ht h's h't\n  apply (ENNReal.toReal_lt_toReal hu _).1\n  · rw [ENNReal.toReal_add (measure_ne_top_of_subset h's hu) (measure_ne_top_of_subset h't hu)]\n    exact h\n  · exact ENNReal.add_ne_top.2 ⟨measure_ne_top_of_subset h's hu, measure_ne_top_of_subset h't hu⟩\n\n/-- If two sets `s` and `t` are included in a set `u` of finite measure,\nand `μ.real s + μ.real t > μ.real u`, then `s` intersects `t`.\nVersion assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measureReal_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ.real u < μ.real s + μ.real t)\n    (hu : μ u ≠ ∞ := by finiteness) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measureReal_lt_add μ hs h't h's h hu\n\ntheorem measureReal_prod_prod {μ : Measure α} {ν : Measure β} [SigmaFinite ν] (s : Set α)\n    (t : Set β) :\n    (μ.prod ν).real (s ×ˢ t) = μ.real s * ν.real t := by\n  simp only [measureReal_def, prod_prod, ENNReal.toReal_mul]\n\n-- find this in library?  generalize?\n/-- Generalized in Measure.ext_iff_singleton_finiteSupport at Entropy.Measure -/\ntheorem Measure.ext_iff_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · intro h\n    ext s\n    have hs : Set.Finite s := Set.toFinite s\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem ext_iff_measureReal_singleton [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nend MeasureTheory\n\nnamespace Mathlib.Meta.Positivity\n\nopen Lean Meta Qq Function\n\n/-- Extension for the `positivity` tactic: applications of `μ.real` are nonnegative. -/\n@[positivity MeasureTheory.Measure.real _ _]\ndef evalMeasureReal : PositivityExt where eval {_ _} _zα _pα e := do\n  let .app (.app _ a) b ← whnfR e | throwError \"not measureReal\"\n  let p ← mkAppOptM ``MeasureTheory.measureReal_nonneg #[none, none, a, b]\n  pure (.nonnegative p)\n\nend Mathlib.Meta.Positivity\nsection aux_lemmas\n\nlemma measureReal_preimage_fst_singleton_eq_sum {S T : Type*} {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] [Fintype T] {_ : MeasurableSpace T}\n    [MeasurableSingletonClass T] (μ : Measure (S × T)) [IsFiniteMeasure μ] (x : S) :\n    μ.real (Prod.fst ⁻¹' {x}) = ∑ y : T, μ.real {(x, y)} := by\n  rw [measureReal_def, measure_preimage_fst_singleton_eq_sum, ENNReal.toReal_sum]\n  · rfl\n  intros\n  finiteness\n\n","proof":":= by\n  rw [measureReal_def, measure_preimage_snd_singleton_eq_sum, ENNReal.toReal_sum]\n  · rfl\n  intros\n  finiteness","declId":"PFR.ForMathlib.MeasureReal.515_0.TFMIpVlQgElPqSx","decl":"lemma measureReal_preimage_snd_singleton_eq_sum {S T : Type*} [Fintype S] {_ : MeasurableSpace S}\n    [MeasurableSingletonClass S] {_ : MeasurableSpace T}\n    [MeasurableSingletonClass T] (μ : Measure (S × T)) [IsFiniteMeasure μ] (y : T) :\n    μ.real (Prod.snd ⁻¹' {y}) = ∑ x : S, μ.real {(x, y)} "}
