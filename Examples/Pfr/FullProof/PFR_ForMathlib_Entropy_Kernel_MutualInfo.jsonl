{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n","proof":":=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.36_0.m3CYvRpZsymY1yj","decl":"/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.44_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n","proof":":= by\n  simp [mutualInfo]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.47_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n","proof":":= by\n  simp [mutualInfo]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.51_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\n","proof":":= by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.55_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\n","proof":":= by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.66_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\n","proof":":= by\n  rw [mutualInfo, chain_rule hκ]\n  ring","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.72_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\n","proof":":= by\n  rw [mutualInfo, chain_rule' hκ]\n  ring","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.79_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n","proof":":= by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.86_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n","proof":":= by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.93_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\n","proof":":= by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.99_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\n","proof":":= by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.114_0.m3CYvRpZsymY1yj","decl":"lemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\n","proof":":= by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.120_0.m3CYvRpZsymY1yj","decl":"lemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n","proof":":= by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.127_0.m3CYvRpZsymY1yj","decl":"lemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\n","proof":":= by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.135_0.m3CYvRpZsymY1yj","decl":"lemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n","proof":":= fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.164_0.m3CYvRpZsymY1yj","decl":"/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\n","proof":":= by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.181_0.m3CYvRpZsymY1yj","decl":"lemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n","proof":":= by\n  ext x s _\n  rw [map_apply]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.186_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\n","proof":":= by\n  rw [swapRight, map_map]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.192_0.m3CYvRpZsymY1yj","decl":"lemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n","proof":":=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.196_0.m3CYvRpZsymY1yj","decl":"/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\n","proof":":= by\n  rw [deleteMiddle]\n  infer_instance","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.202_0.m3CYvRpZsymY1yj","decl":"instance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n","proof":":= by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.207_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n","proof":":= by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.213_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n","proof":":= by\n  simp only [deleteMiddle, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.220_0.m3CYvRpZsymY1yj","decl":"@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n","proof":":= by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.228_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n","proof":":=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.241_0.m3CYvRpZsymY1yj","decl":"/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\n","proof":":= by\n  rw [deleteRight]; infer_instance","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.246_0.m3CYvRpZsymY1yj","decl":"instance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n","proof":":= by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.250_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n","proof":":= by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.256_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n","proof":":= by\n  simp only [deleteRight, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.263_0.m3CYvRpZsymY1yj","decl":"@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n","proof":":=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.271_0.m3CYvRpZsymY1yj","decl":"/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n","proof":":=\n  finiteKernelSupport_of_map hκ _","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.278_0.m3CYvRpZsymY1yj","decl":"/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\n","proof":":=\n  hκ.map _","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.283_0.m3CYvRpZsymY1yj","decl":"lemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n","proof":":= by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.288_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\n","proof":":= by\n  rw [reverse]\n  infer_instance","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.295_0.m3CYvRpZsymY1yj","decl":"instance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n","proof":":= by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.300_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n","proof":":= by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.306_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n","proof":":= by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.312_0.m3CYvRpZsymY1yj","decl":"@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\n","proof":":= by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.320_0.m3CYvRpZsymY1yj","decl":"lemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n","proof":":= by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.333_0.m3CYvRpZsymY1yj","decl":"lemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\n","proof":":= by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.345_0.m3CYvRpZsymY1yj","decl":"lemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\n","proof":":= by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.350_0.m3CYvRpZsymY1yj","decl":"lemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\n","proof":":= by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.360_0.m3CYvRpZsymY1yj","decl":"lemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\nlemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] := by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n\n","proof":":=\n  entropy_congr (condKernel_compProd_ae_eq (ξ ⊗ₖ κ) η μ)","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.383_0.m3CYvRpZsymY1yj","decl":"lemma entropy_condKernel_compProd_triple (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] :\n    Hk[condKernel (ξ ⊗ₖ κ ⊗ₖ η) , μ ⊗ₘ (ξ ⊗ₖ κ)] = Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\nlemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] := by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n\nlemma entropy_condKernel_compProd_triple (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] :\n    Hk[condKernel (ξ ⊗ₖ κ ⊗ₖ η) , μ ⊗ₘ (ξ ⊗ₖ κ)] = Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)] :=\n  entropy_congr (condKernel_compProd_ae_eq (ξ ⊗ₖ κ) η μ)\n\n/- $$ H[X,Y,Z] + H[X] \\leq H[Z,X] + H[Y,X].$$ -/\n","proof":":= by\n  rw [chain_rule,\n    chain_rule (κ := ξ ⊗ₖ snd (κ ⊗ₖ comap η ↑assocEquiv.symm assocEquiv.symm.measurable))]\n  simp only [fst_compProd, entropy_condKernel_compProd_triple, fst_deleteMiddle]\n  . calc Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] + Hk[ξ , μ]\n      = Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] := by abel\n    _ ≤ Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ]\n      + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] := by\n        refine add_le_add le_rfl ?_\n        refine (entropy_submodular_compProd hκ hη hξ).trans_eq ?_\n        refine entropy_congr ?_\n        exact (condKernel_compProd_ae_eq _ _ _).symm\n    _ = Hk[ξ , μ] + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] + Hk[ξ ⊗ₖ κ , μ] := by abel\n  . refine hξ.compProd ?_\n    refine AEFiniteKernelSupport.snd ?_\n    refine hκ.compProd ?_\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n  · exact (hξ.compProd hκ).compProd hη","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.390_0.m3CYvRpZsymY1yj","decl":"lemma entropy_compProd_triple_add_entropy_le {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[(ξ ⊗ₖ κ) ⊗ₖ η, μ] + Hk[ξ, μ]\n      ≤ Hk[ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable), μ]\n       + Hk[ξ ⊗ₖ κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\nlemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] := by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n\nlemma entropy_condKernel_compProd_triple (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] :\n    Hk[condKernel (ξ ⊗ₖ κ ⊗ₖ η) , μ ⊗ₘ (ξ ⊗ₖ κ)] = Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)] :=\n  entropy_congr (condKernel_compProd_ae_eq (ξ ⊗ₖ κ) η μ)\n\n/- $$ H[X,Y,Z] + H[X] \\leq H[Z,X] + H[Y,X].$$ -/\nlemma entropy_compProd_triple_add_entropy_le {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[(ξ ⊗ₖ κ) ⊗ₖ η, μ] + Hk[ξ, μ]\n      ≤ Hk[ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable), μ]\n       + Hk[ξ ⊗ₖ κ, μ] := by\n  rw [chain_rule,\n    chain_rule (κ := ξ ⊗ₖ snd (κ ⊗ₖ comap η ↑assocEquiv.symm assocEquiv.symm.measurable))]\n  simp only [fst_compProd, entropy_condKernel_compProd_triple, fst_deleteMiddle]\n  . calc Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] + Hk[ξ , μ]\n      = Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] := by abel\n    _ ≤ Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ]\n      + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] := by\n        refine add_le_add le_rfl ?_\n        refine (entropy_submodular_compProd hκ hη hξ).trans_eq ?_\n        refine entropy_congr ?_\n        exact (condKernel_compProd_ae_eq _ _ _).symm\n    _ = Hk[ξ , μ] + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] + Hk[ξ ⊗ₖ κ , μ] := by abel\n  . refine hξ.compProd ?_\n    refine AEFiniteKernelSupport.snd ?_\n    refine hκ.compProd ?_\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n  · exact (hξ.compProd hκ).compProd hη\n\n","proof":":= by\n  set κ' := map κ assocEquiv assocEquiv.measurable with hκ'_def\n  let ξ := fst (fst κ')\n  let κ'' := condKernel (fst κ')\n  let η := condKernel κ'\n  have hξ_eq : ξ = fst κ := by\n    simp only [fst._eq_1, assocEquiv, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, map_map]\n    congr\n  have h_compProd_eq : ξ ⊗ₖ κ'' = fst κ' := (disintegration (fst κ')).symm\n  have h_compProd_triple_eq : (ξ ⊗ₖ κ'') ⊗ₖ η = κ' := by\n    rw [h_compProd_eq]\n    exact (disintegration κ').symm\n  have h_compProd_triple_eq' : ξ ⊗ₖ (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable)\n      = κ := by\n    rw [← compProd_assoc, h_compProd_triple_eq,hκ'_def, map_map]\n    simp\n  have h := entropy_compProd_triple_add_entropy_le (ξ := ξ) (κ := κ'') (η := η) (μ := μ) ?_ ?_ ?_\n  rotate_left\n  . exact aefiniteKernelSupport_of_cond _ (hκ.map _).fst\n  . rw [h_compProd_eq]\n    apply aefiniteKernelSupport_of_cond\n    exact hκ.map _\n  · exact (hκ.map _).fst.fst\n  rw [← hξ_eq]\n  have h_right : deleteRight κ = fst κ' := by\n    simp only [κ', deleteRight, fst, map_map]\n    congr\n  have h_middle : deleteMiddle κ\n      = ξ ⊗ₖ snd (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable) := by\n    rw [← deleteMiddle_compProd, h_compProd_triple_eq']\n  have hκ : Hk[κ, μ] = Hk[κ', μ] := by\n    rw [hκ'_def, entropy_map_of_injective]\n    exact assocEquiv.injective\n  rw [h_right, h_middle, hκ, ← h_compProd_triple_eq, fst_compProd]\n  . exact h","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.417_0.m3CYvRpZsymY1yj","decl":"/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[X] \\leq H[X,Z] + H[X,Y].$$ -/\nlemma entropy_triple_add_entropy_le' {κ : kernel T (S × U × V)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] + Hk[fst κ, μ] ≤ Hk[deleteMiddle κ, μ] + Hk[deleteRight κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\nlemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] := by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n\nlemma entropy_condKernel_compProd_triple (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] :\n    Hk[condKernel (ξ ⊗ₖ κ ⊗ₖ η) , μ ⊗ₘ (ξ ⊗ₖ κ)] = Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)] :=\n  entropy_congr (condKernel_compProd_ae_eq (ξ ⊗ₖ κ) η μ)\n\n/- $$ H[X,Y,Z] + H[X] \\leq H[Z,X] + H[Y,X].$$ -/\nlemma entropy_compProd_triple_add_entropy_le {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[(ξ ⊗ₖ κ) ⊗ₖ η, μ] + Hk[ξ, μ]\n      ≤ Hk[ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable), μ]\n       + Hk[ξ ⊗ₖ κ, μ] := by\n  rw [chain_rule,\n    chain_rule (κ := ξ ⊗ₖ snd (κ ⊗ₖ comap η ↑assocEquiv.symm assocEquiv.symm.measurable))]\n  simp only [fst_compProd, entropy_condKernel_compProd_triple, fst_deleteMiddle]\n  . calc Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] + Hk[ξ , μ]\n      = Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] := by abel\n    _ ≤ Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ]\n      + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] := by\n        refine add_le_add le_rfl ?_\n        refine (entropy_submodular_compProd hκ hη hξ).trans_eq ?_\n        refine entropy_congr ?_\n        exact (condKernel_compProd_ae_eq _ _ _).symm\n    _ = Hk[ξ , μ] + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] + Hk[ξ ⊗ₖ κ , μ] := by abel\n  . refine hξ.compProd ?_\n    refine AEFiniteKernelSupport.snd ?_\n    refine hκ.compProd ?_\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n  · exact (hξ.compProd hκ).compProd hη\n\n/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[X] \\leq H[X,Z] + H[X,Y].$$ -/\nlemma entropy_triple_add_entropy_le' {κ : kernel T (S × U × V)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] + Hk[fst κ, μ] ≤ Hk[deleteMiddle κ, μ] + Hk[deleteRight κ, μ] := by\n  set κ' := map κ assocEquiv assocEquiv.measurable with hκ'_def\n  let ξ := fst (fst κ')\n  let κ'' := condKernel (fst κ')\n  let η := condKernel κ'\n  have hξ_eq : ξ = fst κ := by\n    simp only [fst._eq_1, assocEquiv, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, map_map]\n    congr\n  have h_compProd_eq : ξ ⊗ₖ κ'' = fst κ' := (disintegration (fst κ')).symm\n  have h_compProd_triple_eq : (ξ ⊗ₖ κ'') ⊗ₖ η = κ' := by\n    rw [h_compProd_eq]\n    exact (disintegration κ').symm\n  have h_compProd_triple_eq' : ξ ⊗ₖ (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable)\n      = κ := by\n    rw [← compProd_assoc, h_compProd_triple_eq,hκ'_def, map_map]\n    simp\n  have h := entropy_compProd_triple_add_entropy_le (ξ := ξ) (κ := κ'') (η := η) (μ := μ) ?_ ?_ ?_\n  rotate_left\n  . exact aefiniteKernelSupport_of_cond _ (hκ.map _).fst\n  . rw [h_compProd_eq]\n    apply aefiniteKernelSupport_of_cond\n    exact hκ.map _\n  · exact (hκ.map _).fst.fst\n  rw [← hξ_eq]\n  have h_right : deleteRight κ = fst κ' := by\n    simp only [κ', deleteRight, fst, map_map]\n    congr\n  have h_middle : deleteMiddle κ\n      = ξ ⊗ₖ snd (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable) := by\n    rw [← deleteMiddle_compProd, h_compProd_triple_eq']\n  have hκ : Hk[κ, μ] = Hk[κ', μ] := by\n    rw [hκ'_def, entropy_map_of_injective]\n    exact assocEquiv.injective\n  rw [h_right, h_middle, hκ, ← h_compProd_triple_eq, fst_compProd]\n  . exact h\n\n","proof":":= by\n  refine le_antisymm ?_ ?_\n  · convert entropy_map_le (fun p ↦ (p.2.2, p.2.1, p.1)) hκ\n  · conv_lhs => rw [← reverse_reverse κ]\n    convert entropy_map_le (κ := reverse κ) (fun p ↦ (p.2.2, p.2.1, p.1)) hκ.reverse","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.458_0.m3CYvRpZsymY1yj","decl":"lemma entropy_reverse {κ : kernel T (S × U × V)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[reverse κ, μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Basic\n\n/-!\n# Mutual Information of kernels\n\n## Main definitions\n\n* `mutualInfo`: Mutual information of a kernel `κ` into a product space with respect to a\n  measure `μ`. This is denoted by `Ik[κ, μ]` and is equal to\n  `Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]`.\n\n## Main statements\n\n* `mutualInfo_nonneg`: `Ik[κ, μ]` is nonnegative\n* `entropy_condKernel_le_entropy_fst` and `entropy_condKernel_le_entropy_snd`: conditioning\n  reduces entropy.\n\n## Notations\n\n* `Ik[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Function MeasureTheory Real\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Nonempty S] [Countable S] [MeasurableSpace S] [MeasurableSingletonClass S]\n  [Nonempty T] [Countable T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Nonempty U] [Countable U] [MeasurableSpace U] [MeasurableSingletonClass U]\n  [Nonempty V] [Countable V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {κ : kernel T S} {μ : Measure T} {X : Ω → S} {Y : Ω → U}\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnoncomputable\ndef mutualInfo (κ : kernel T (S × U)) (μ : Measure T) : ℝ :=\n  Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ]\n\n/-- Mutual information of a kernel into a product space with respect to a measure. -/\nnotation3:100 \"Ik[\" κ \" , \" μ \"]\" => kernel.mutualInfo κ μ\n\nlemma mutualInfo_def (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[κ, μ] = Hk[fst κ, μ] + Hk[snd κ, μ] - Hk[κ, μ] := rfl\n\n@[simp]\nlemma mutualInfo_zero_measure (κ : kernel T (S × U)) : Ik[κ, (0 : Measure T)] = 0 := by\n  simp [mutualInfo]\n\n@[simp]\nlemma mutualInfo_zero_kernel (μ : Measure T) : Ik[(0 : kernel T (S × U)), μ] = 0 := by\n  simp [mutualInfo]\n\nlemma mutualInfo_congr {κ η : kernel T (S × U)} {μ : Measure T} (h : κ =ᵐ[μ] η) :\n    Ik[κ, μ] = Ik[η, μ] := by\n  rw [mutualInfo, mutualInfo]\n  have h1 : fst κ =ᵐ[μ] fst η := by\n    filter_upwards [h] with t ht\n    rw [fst_apply, ht, fst_apply]\n  have h2 : snd κ =ᵐ[μ] snd η := by\n    filter_upwards [h] with t ht\n    rw [snd_apply, ht, snd_apply]\n  rw [entropy_congr h1, entropy_congr h2, entropy_congr h]\n\nlemma mutualInfo_compProd {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)):\n    Ik[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[snd (κ ⊗ₖ η), μ] - Hk[κ ⊗ₖ η, μ] := by\n  rw [mutualInfo, entropy_compProd hκ hη, fst_compProd]\n\nlemma mutualInfo_eq_snd_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[snd κ, μ] - Hk[condKernel κ, μ ⊗ₘ (fst κ)]  := by\n  rw [mutualInfo, chain_rule hκ]\n  ring\n\nlemma mutualInfo_eq_fst_sub {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) :\n    Ik[κ, μ] = Hk[fst κ, μ] - Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [mutualInfo, chain_rule' hκ]\n  ring\n\n@[simp]\nlemma mutualInfo_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ: AEFiniteKernelSupport κ μ) (hη: AEFiniteKernelSupport η μ) :\n    Ik[κ ×ₖ η, μ] = 0 := by\n  rw [mutualInfo, snd_prod, fst_prod, entropy_prod hκ hη, sub_self]\n\n@[simp]\nlemma mutualInfo_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Ik[swapRight κ, μ] = Ik[κ, μ] := by\n  rw [mutualInfo, fst_swapRight, snd_swapRight, entropy_swapRight, add_comm]\n  rfl\n\nlemma mutualInfo_nonneg' {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    0 ≤ Ik[κ, μ] := by\n  simp_rw [mutualInfo, entropy, integral_eq_sum' _ (measure_compl_support μ),\n    smul_eq_mul]\n  rw [← Finset.sum_add_distrib, ← Finset.sum_sub_distrib]\n  refine Finset.sum_nonneg (fun x _ ↦ ?_)\n  by_cases hx : μ {x} = 0\n  · simp [hx]\n  rw [← mul_add, ← mul_sub]\n  refine mul_nonneg ENNReal.toReal_nonneg ?_\n  rw [fst_apply, snd_apply]\n  have : FiniteSupport (κ x) := ⟨hκ x⟩\n  exact measureMutualInfo_nonneg\n\nlemma mutualInfo_nonneg {κ : kernel T (S × U)} {μ : Measure T} [IsFiniteMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    0 ≤ Ik[κ, μ] := by\n  rw [mutualInfo_congr hκ.ae_eq_mk]\n  exact mutualInfo_nonneg' hκ.finiteKernelSupport_mk\n\nlemma entropy_condKernel_le_entropy_fst (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] ≤ Hk[fst κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_fst_sub hκ]\n  exact mutualInfo_nonneg hκ\n\nlemma entropy_condKernel_le_entropy_snd {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[condKernel κ, μ ⊗ₘ (fst κ)] ≤ Hk[snd κ, μ] := by\n  rw [← sub_nonneg, ← mutualInfo_eq_snd_sub hκ]\n  exact mutualInfo_nonneg hκ\n\n-- TODO: extract lemma(s) from this:\nlemma entropy_snd_sub_mutualInfo_le_entropy_map_of_injective {V : Type*} [Nonempty V] [Countable V]\n    [MeasurableSpace V] [MeasurableSingletonClass V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsProbabilityMeasure μ]\n    (f : S × U → V) (hfi : ∀ x, Injective (fun y ↦ f (x, y))) [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] - Ik[κ, μ] ≤ Hk[map κ f (measurable_of_countable f), μ] := by\n  rw [mutualInfo_eq_snd_sub hκ]\n  have hf : Measurable f := measurable_of_countable f\n  ring_nf\n  calc\n    Hk[condKernel κ, μ ⊗ₘ fst κ] = Hk[snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2)) (measurable_of_countable _))), μ ⊗ₘ fst κ] := by\n      symm\n      apply entropy_snd_compProd_deterministic_of_injective\n      simpa\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst κ] := entropy_congr (condKernel_map_prod_mk_left κ μ f).symm\n    _ = Hk[condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)),\n      μ ⊗ₘ fst (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf))] := by\n        congr 2 with x\n        rw [fst_map_prod _ measurable_fst hf, fst_apply, map_apply]\n    _ ≤ Hk[snd (map κ (fun p ↦ (p.1, f p)) (measurable_fst.prod_mk hf)), μ] :=\n      entropy_condKernel_le_entropy_snd (hκ.map _)\n    _ = Hk[map κ f hf, μ] := by rw [snd_map_prod _ measurable_fst]\n\nsection measurableEquiv\n\nvariable {α β γ δ : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ}\n\n/-- Canonical bijection between `α × β × γ` and `(α × β) × γ`. -/\ndef assocEquiv : α × β × γ ≃ᵐ (α × β) × γ where\n  toFun := fun p ↦ ((p.1, p.2.1), p.2.2)\n  invFun := fun p ↦ (p.1.1, (p.1.2, p.2))\n  left_inv := fun p ↦ by simp\n  right_inv := fun p ↦ by simp\n  measurable_toFun := (measurable_fst.prod_mk (measurable_fst.comp measurable_snd)).prod_mk\n    (measurable_snd.comp measurable_snd)\n  measurable_invFun := (measurable_fst.comp measurable_fst).prod_mk\n    ((measurable_snd.comp measurable_fst).prod_mk measurable_snd)\n\nend measurableEquiv\n\nsection\nvariable {α β γ δ ε : Type*} {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {_ : MeasurableSpace δ} {_ : MeasurableSpace ε}\n\nlemma map_map (κ : kernel α β) {f : β → γ} (hf : Measurable f) {g : γ → δ} (hg : Measurable g) :\n    map (map κ f hf) g hg = map κ (g ∘ f) (hg.comp hf) := by\n  ext x s _\n  rw [map_apply, map_apply, map_apply, Measure.map_map hg hf]\n\n@[simp]\nlemma map_id (κ : kernel α β) : map κ id measurable_id = κ := by\n  ext x s _\n  rw [map_apply]\n  simp\n\nlemma map_swapRight (κ : kernel α (β × γ)) {f : (γ × β) → δ} (hf : Measurable f) :\n    map (swapRight κ) f hf = map κ (f ∘ Prod.swap) (hf.comp measurable_swap) := by\n  rw [swapRight, map_map]\n\n/-- Given a kernel taking values in a product of three spaces, forget the middle one. -/\nnoncomputable\ndef deleteMiddle (κ : kernel α (β × γ × δ)) :\n    kernel α (β × δ) :=\n  map κ (fun p ↦ (p.1, p.2.2)) (measurable_fst.prod_mk (measurable_snd.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteMiddle κ) := by\n  rw [deleteMiddle]\n  infer_instance\n\n@[simp]\nlemma fst_deleteMiddle (κ : kernel α (β × γ × δ)) : fst (deleteMiddle κ) = fst κ := by\n  rw [deleteMiddle, fst_map_prod]\n  · rfl\n  · exact measurable_snd.comp measurable_snd\n\n@[simp]\nlemma snd_deleteMiddle (κ : kernel α (β × γ × δ)) : snd (deleteMiddle κ) = snd (snd κ) := by\n  rw [deleteMiddle, snd_map_prod]\n  · rw [snd, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteMiddle_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteMiddle (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g' b)) (hf.prod_mk hg') := by\n  simp only [deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma deleteMiddle_compProd (ξ : kernel α β) [IsSFiniteKernel ξ]\n    (κ : kernel (α × β) (γ × δ)) [IsSFiniteKernel κ] :\n    deleteMiddle (ξ ⊗ₖ κ) = ξ ⊗ₖ snd κ := by\n  ext x s hs\n  rw [deleteMiddle, map_apply' _ _ _ hs, compProd_apply _ _ _ hs, compProd_apply]\n  swap; · exact measurable_fst.prod_mk measurable_snd.snd hs\n  congr with b\n  simp only [Set.mem_preimage]\n  rw [snd_apply']\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, forget the last variable. -/\nnoncomputable\ndef deleteRight (κ : kernel α (β × γ × δ)) : kernel α (β × γ) :=\n  map κ (fun p ↦ (p.1, p.2.1)) (measurable_fst.prod_mk (measurable_fst.comp measurable_snd))\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (deleteRight κ) := by\n  rw [deleteRight]; infer_instance\n\n@[simp]\nlemma fst_deleteRight (κ : kernel α (β × γ × δ)) : fst (deleteRight κ) = fst κ := by\n  rw [deleteRight, fst_map_prod]\n  · rfl\n  · exact measurable_fst.comp measurable_snd\n\n@[simp]\nlemma snd_deleteRight (κ : kernel α (β × γ × δ)) : snd (deleteRight κ) = fst (snd κ) := by\n  rw [deleteRight, snd_map_prod]\n  · rw [fst, snd, map_map]\n    rfl\n  · exact measurable_fst\n\n@[simp, nolint simpNF]\nlemma deleteRight_map_prod (κ : kernel α β) {f : β → γ} {g : β → δ} {g' : β → ε}\n    (hf : Measurable f) (hg : Measurable g) (hg' : Measurable g') :\n    deleteRight (map κ (fun b ↦ (f b, g b, g' b)) (hf.prod_mk (hg.prod_mk hg')))\n      = map κ (fun b ↦ (f b, g b)) (hf.prod_mk hg) := by\n  simp only [deleteRight, map_map]\n  congr\n\n/-- Given a kernel taking values in a product of three spaces, reverse the order of the spaces. -/\nnoncomputable\ndef reverse (κ : kernel α (β × γ × δ)) : kernel α (δ × γ × β) :=\n  map κ (fun p ↦ (p.2.2, (p.2.1, p.1)))\n    ((measurable_snd.comp measurable_snd).prod_mk\n      ((measurable_fst.comp measurable_snd).prod_mk measurable_fst))\n\n/-- Reversing preserves finite kernel support -/\nlemma finiteKernelSupport_of_reverse {κ : kernel T (S × U × V)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (reverse κ) :=\n  finiteKernelSupport_of_map hκ _\n\nlemma AEFiniteKernelSupport.reverse {κ : kernel T (S × U × V)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (reverse κ) μ :=\n  hκ.map _\n\n@[simp]\nlemma reverse_reverse (κ : kernel α (β × γ × δ)) :\n    reverse (reverse κ) = κ := by\n  have : ((fun p : δ × γ × β ↦ (p.2.2, p.2.1, p.1)) ∘ fun p ↦ (p.2.2, p.2.1, p.1)) = id := by\n    ext1; simp\n  simp [reverse, map_map, this]\n\ninstance (κ : kernel α (β × γ × δ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (reverse κ) := by\n  rw [reverse]\n  infer_instance\n\n@[simp]\nlemma swapRight_deleteMiddle_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteMiddle (reverse κ)) = deleteMiddle κ := by\n  simp only [swapRight, reverse, deleteMiddle, map_map]\n  congr\n\n@[simp]\nlemma swapRight_snd_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (snd (reverse κ)) = deleteRight κ := by\n  simp only [swapRight, reverse, deleteMiddle, snd, map_map]\n  congr\n\n@[simp]\nlemma swapRight_deleteRight_reverse (κ : kernel α (β × γ × δ)) :\n    swapRight (deleteRight (reverse κ)) = snd κ := by\n  simp only [swapRight, reverse, deleteRight, snd, map_map]\n  congr\n\nend\n\nlemma compProd_assoc (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η] :\n    map ((ξ ⊗ₖ κ) ⊗ₖ η) assocEquiv.symm assocEquiv.symm.measurable\n      = ξ ⊗ₖ (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)) := by\n  ext x s hs\n  rw [map_apply' _ _ _ hs, compProd_apply _ _ _ (assocEquiv.symm.measurable hs),\n    compProd_apply _ _ _ hs, lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left' (assocEquiv.symm.measurable hs) _\n  congr with a\n  rw [compProd_apply]\n  swap; · exact measurable_prod_mk_left hs\n  congr\n\nlemma Measure.compProd_compProd (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = (μ ⊗ₘ ξ ⊗ₘ κ).map assocEquiv.symm := by\n  ext s hs\n  rw [Measure.compProd_apply hs, Measure.map_apply assocEquiv.symm.measurable hs,\n    Measure.compProd_apply (assocEquiv.symm.measurable hs),\n    Measure.lintegral_compProd]\n  swap; · exact measurable_kernel_prod_mk_left (assocEquiv.symm.measurable hs)\n  congr with a\n  rw [compProd_apply _ _ _ (measurable_prod_mk_left hs)]\n  congr\n\nlemma Measure.compProd_compProd' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ (ξ ⊗ₖ κ) = Measure.comap (assocEquiv : T × S × U ≃ᵐ (T × S) × U) (μ ⊗ₘ ξ ⊗ₘ κ) := by\n  rw [← MeasurableEquiv.map_symm, Measure.compProd_compProd]\n\nlemma Measure.compProd_compProd'' (μ : Measure T) [IsProbabilityMeasure μ]\n    (ξ : kernel T S) [IsMarkovKernel ξ] (κ : kernel (T × S) U) [IsMarkovKernel κ] :\n    μ ⊗ₘ ξ ⊗ₘ κ = Measure.comap assocEquiv.symm (μ ⊗ₘ (ξ ⊗ₖ κ)) := by\n  rw [Measure.compProd_compProd, MeasurableEquiv.comap_symm, Measure.map_map]\n  · simp\n  · exact assocEquiv.measurable\n  · exact assocEquiv.symm.measurable\n\n-- from kernel (T × S × U) V ; Measure (T × S × U)\n-- to kernel (T × S) V ; Measure (T × S)\nlemma entropy_submodular_compProd {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)]\n      ≤ Hk[snd (κ ⊗ₖ (comap η assocEquiv.symm assocEquiv.symm.measurable)), μ ⊗ₘ ξ] := by\n  have h_meas := (assocEquiv : T × S × U ≃ᵐ (T × S) × U).symm.measurable\n  have : FiniteSupport (μ ⊗ₘ ξ) := finiteSupport_of_compProd hξ\n  have : FiniteSupport (μ ⊗ₘ (ξ ⊗ₖ κ)) := finiteSupport_of_compProd (hξ.compProd hκ)\n  have h := entropy_condKernel_le_entropy_snd\n    (κ := κ ⊗ₖ (comap η assocEquiv.symm h_meas)) (μ := μ ⊗ₘ ξ) ?_\n  simp only [fst_compProd] at h\n  have : condKernel (κ ⊗ₖ comap η ↑assocEquiv.symm h_meas)\n      =ᵐ[μ ⊗ₘ ξ ⊗ₘ κ] comap η ↑assocEquiv.symm h_meas := by\n    exact condKernel_compProd_ae_eq κ (comap η ↑assocEquiv.symm assocEquiv.symm.measurable)\n      (μ ⊗ₘ ξ)\n  rw [entropy_congr this, Measure.compProd_compProd'', entropy_comap_equiv] at h\n  . exact h\n  · refine (hκ.compProd ?_)\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n\nlemma entropy_condKernel_compProd_triple (ξ : kernel T S) [IsMarkovKernel ξ]\n    (κ : kernel (T × S) U) [IsMarkovKernel κ] (η : kernel (T × S × U) V) [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] :\n    Hk[condKernel (ξ ⊗ₖ κ ⊗ₖ η) , μ ⊗ₘ (ξ ⊗ₖ κ)] = Hk[η, μ ⊗ₘ (ξ ⊗ₖ κ)] :=\n  entropy_congr (condKernel_compProd_ae_eq (ξ ⊗ₖ κ) η μ)\n\n/- $$ H[X,Y,Z] + H[X] \\leq H[Z,X] + H[Y,X].$$ -/\nlemma entropy_compProd_triple_add_entropy_le {ξ : kernel T S} [IsMarkovKernel ξ]\n    {κ : kernel (T × S) U} [IsMarkovKernel κ] {η : kernel (T × S × U) V} [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ (μ ⊗ₘ ξ))\n    (hη : AEFiniteKernelSupport η (μ ⊗ₘ (ξ ⊗ₖ κ))) (hξ : AEFiniteKernelSupport ξ μ) :\n    Hk[(ξ ⊗ₖ κ) ⊗ₖ η, μ] + Hk[ξ, μ]\n      ≤ Hk[ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable), μ]\n       + Hk[ξ ⊗ₖ κ, μ] := by\n  rw [chain_rule,\n    chain_rule (κ := ξ ⊗ₖ snd (κ ⊗ₖ comap η ↑assocEquiv.symm assocEquiv.symm.measurable))]\n  simp only [fst_compProd, entropy_condKernel_compProd_triple, fst_deleteMiddle]\n  . calc Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] + Hk[ξ , μ]\n      = Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ] + Hk[η , μ ⊗ₘ (ξ ⊗ₖ κ)] := by abel\n    _ ≤ Hk[ξ , μ] + Hk[ξ ⊗ₖ κ , μ]\n      + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] := by\n        refine add_le_add le_rfl ?_\n        refine (entropy_submodular_compProd hκ hη hξ).trans_eq ?_\n        refine entropy_congr ?_\n        exact (condKernel_compProd_ae_eq _ _ _).symm\n    _ = Hk[ξ , μ] + Hk[condKernel (ξ ⊗ₖ snd (κ ⊗ₖ comap η assocEquiv.symm _)) , μ ⊗ₘ ξ] + Hk[ξ ⊗ₖ κ , μ] := by abel\n  . refine hξ.compProd ?_\n    refine AEFiniteKernelSupport.snd ?_\n    refine hκ.compProd ?_\n    convert hη.comap_equiv assocEquiv.symm\n    exact Measure.compProd_compProd'' _ _ _\n  · exact (hξ.compProd hκ).compProd hη\n\n/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[X] \\leq H[X,Z] + H[X,Y].$$ -/\nlemma entropy_triple_add_entropy_le' {κ : kernel T (S × U × V)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] + Hk[fst κ, μ] ≤ Hk[deleteMiddle κ, μ] + Hk[deleteRight κ, μ] := by\n  set κ' := map κ assocEquiv assocEquiv.measurable with hκ'_def\n  let ξ := fst (fst κ')\n  let κ'' := condKernel (fst κ')\n  let η := condKernel κ'\n  have hξ_eq : ξ = fst κ := by\n    simp only [fst._eq_1, assocEquiv, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, map_map]\n    congr\n  have h_compProd_eq : ξ ⊗ₖ κ'' = fst κ' := (disintegration (fst κ')).symm\n  have h_compProd_triple_eq : (ξ ⊗ₖ κ'') ⊗ₖ η = κ' := by\n    rw [h_compProd_eq]\n    exact (disintegration κ').symm\n  have h_compProd_triple_eq' : ξ ⊗ₖ (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable)\n      = κ := by\n    rw [← compProd_assoc, h_compProd_triple_eq,hκ'_def, map_map]\n    simp\n  have h := entropy_compProd_triple_add_entropy_le (ξ := ξ) (κ := κ'') (η := η) (μ := μ) ?_ ?_ ?_\n  rotate_left\n  . exact aefiniteKernelSupport_of_cond _ (hκ.map _).fst\n  . rw [h_compProd_eq]\n    apply aefiniteKernelSupport_of_cond\n    exact hκ.map _\n  · exact (hκ.map _).fst.fst\n  rw [← hξ_eq]\n  have h_right : deleteRight κ = fst κ' := by\n    simp only [κ', deleteRight, fst, map_map]\n    congr\n  have h_middle : deleteMiddle κ\n      = ξ ⊗ₖ snd (κ'' ⊗ₖ comap η assocEquiv.symm assocEquiv.symm.measurable) := by\n    rw [← deleteMiddle_compProd, h_compProd_triple_eq']\n  have hκ : Hk[κ, μ] = Hk[κ', μ] := by\n    rw [hκ'_def, entropy_map_of_injective]\n    exact assocEquiv.injective\n  rw [h_right, h_middle, hκ, ← h_compProd_triple_eq, fst_compProd]\n  . exact h\n\nlemma entropy_reverse {κ : kernel T (S × U × V)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[reverse κ, μ] = Hk[κ, μ] := by\n  refine le_antisymm ?_ ?_\n  · convert entropy_map_le (fun p ↦ (p.2.2, p.2.1, p.1)) hκ\n  · conv_lhs => rw [← reverse_reverse κ]\n    convert entropy_map_le (κ := reverse κ) (fun p ↦ (p.2.2, p.2.1, p.1)) hκ.reverse\n\n","proof":":= by\n  have h2 : fst (reverse κ) = snd (snd κ) := by\n    simp only [fst, reverse, snd, map_map]\n    congr\n  rw [← entropy_reverse hκ, ← h2]\n  refine (entropy_triple_add_entropy_le' (κ := reverse κ) (μ:= μ) hκ.reverse).trans ?_\n  refine add_le_add ?_ ?_\n  · rw [← entropy_swapRight]\n    simp\n  · rw [← entropy_swapRight]\n    simp","declId":"PFR.ForMathlib.Entropy.Kernel.MutualInfo.467_0.m3CYvRpZsymY1yj","decl":"/-- The submodularity inequality:\n$$ H[X,Y,Z] + H[Z] \\leq H[X,Z] + H[Y,Z].$$ -/\nlemma entropy_triple_add_entropy_le (κ : kernel T (S × U × V)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] + Hk[snd (snd κ), μ] ≤ Hk[deleteMiddle κ, μ] + Hk[snd κ, μ] "}
