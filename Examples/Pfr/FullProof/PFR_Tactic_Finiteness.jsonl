{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\n","proof":":=\n  ENNReal.nat_ne_top n","declId":"PFR.Tactic.Finiteness.26_0.gum9eYJh1s7bDtx","decl":"theorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\n","proof":":= ENNReal.inv_ne_top.2 h","declId":"PFR.Tactic.Finiteness.29_0.gum9eYJh1s7bDtx","decl":"theorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\n","proof":":=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩","declId":"PFR.Tactic.Finiteness.31_0.gum9eYJh1s7bDtx","decl":"theorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n","proof":":=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []","declId":"PFR.Tactic.Finiteness.51_0.gum9eYJh1s7bDtx","decl":"/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\n","proof":":=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []","declId":"PFR.Tactic.Finiteness.50_0.gum9eYJh1s7bDtx","decl":"open Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n","proof":":= finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))","declId":"PFR.Tactic.Finiteness.56_0.gum9eYJh1s7bDtx","decl":"/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\n","proof":":= finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))","declId":"PFR.Tactic.Finiteness.58_0.gum9eYJh1s7bDtx","decl":"macro (name "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.67_0.gum9eYJh1s7bDtx","decl":"example : (1:ℝ≥0∞) < ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.68_0.gum9eYJh1s7bDtx","decl":"example : (3:ℝ≥0∞) ≠ ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\nexample : (3:ℝ≥0∞) ≠ ∞ := by finiteness\n\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.70_0.gum9eYJh1s7bDtx","decl":"example (a : ℝ) (b : ℕ) : ENNReal.ofReal a + b < ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\nexample : (3:ℝ≥0∞) ≠ ∞ := by finiteness\n\nexample (a : ℝ) (b : ℕ) : ENNReal.ofReal a + b < ∞ := by finiteness\n\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.72_0.gum9eYJh1s7bDtx","decl":"example {a : ℝ≥0∞} (ha : a ≠ ∞) : a + 3 < ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\nexample : (3:ℝ≥0∞) ≠ ∞ := by finiteness\n\nexample (a : ℝ) (b : ℕ) : ENNReal.ofReal a + b < ∞ := by finiteness\n\nexample {a : ℝ≥0∞} (ha : a ≠ ∞) : a + 3 < ∞ := by finiteness\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.73_0.gum9eYJh1s7bDtx","decl":"example {a : ℝ≥0∞} (ha : a < ∞) : a + 3 < ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\nexample : (3:ℝ≥0∞) ≠ ∞ := by finiteness\n\nexample (a : ℝ) (b : ℕ) : ENNReal.ofReal a + b < ∞ := by finiteness\n\nexample {a : ℝ≥0∞} (ha : a ≠ ∞) : a + 3 < ∞ := by finiteness\nexample {a : ℝ≥0∞} (ha : a < ∞) : a + 3 < ∞ := by finiteness\n\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.75_0.gum9eYJh1s7bDtx","decl":"example (a : ℝ) : (ENNReal.ofReal (1 + a ^ 2))⁻¹ < ∞ "}
{"srcUpToDecl":"/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport PFR.Tactic.Finiteness.Attr\nimport Mathlib.MeasureTheory.Measure.Typeclasses\n\n/-! # Finiteness tactic\n\nThis file implements a basic `finiteness` tactic, designed to solve goals of the form `*** < ∞` and\n(equivalently) `*** ≠ ∞` in the extended nonnegative reals (`ENNReal`, aka `ℝ≥0∞`).\n\nIt works recursively according to the syntax of the expression. It is implemented as an `aesop` rule\nset.\n\nTODO: improve `finiteness` to also deal with other situations, such as balls in proper spaces with\na locally finite measure.\n\n-/\n\nopen ENNReal\n\n/-! ## Lemmas -/\n\ntheorem ENNReal.ofNat_ne_top (n : ℕ) [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) ≠ ∞ :=\n  ENNReal.nat_ne_top n\n\ntheorem ENNReal.inv_ne_top' (h : a ≠ 0) : a⁻¹ ≠ ∞ := ENNReal.inv_ne_top.2 h\n\ntheorem ENNReal.add_ne_top' {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n/-! ## Tactic implementation -/\n\nattribute [aesop (rule_sets [Finiteness]) unsafe 20%] ne_top_of_lt\n-- would have been better to implement this as a \"safe\" \"forward\" rule, why doesn't this work?\n-- attribute [aesop (rule_sets [Finiteness]) safe forward] ne_top_of_lt\n\nattribute [aesop (rule_sets [Finiteness]) safe apply]\n  Ne.lt_top\n  ENNReal.ofReal_ne_top ENNReal.coe_ne_top ENNReal.nat_ne_top\n  ENNReal.zero_ne_top ENNReal.one_ne_top ENNReal.ofNat_ne_top\n  ENNReal.mul_ne_top ENNReal.add_ne_top' ENNReal.sub_ne_top ENNReal.inv_ne_top'\n  MeasureTheory.measure_ne_top\n\nopen Aesop.BuiltinRules in\nattribute [aesop (rule_sets [Finiteness]) safe -50] assumption intros\n\nopen Lean Elab Tactic in\n/-- A version of the positivity tactic for use by `aesop`. -/\n@[aesop safe tactic (rule_sets [Finiteness])]\ndef PositivityForAesop : TacticM Unit :=\n  liftMetaTactic fun g => do Mathlib.Meta.Positivity.positivity g; pure []\n\n/-- Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). -/\nmacro (name := finiteness) \"finiteness\" c:Aesop.tactic_clause* : tactic =>\n`(tactic|\n  aesop $c*\n    (options := { introsTransparency? := some .reducible, terminal := true })\n    (simp_options := { enabled := false })\n    (rule_sets [$(Lean.mkIdent `Finiteness):ident, -default, -builtin]))\n\n/-! ## Tests -/\n\nexample : (1:ℝ≥0∞) < ∞ := by finiteness\nexample : (3:ℝ≥0∞) ≠ ∞ := by finiteness\n\nexample (a : ℝ) (b : ℕ) : ENNReal.ofReal a + b < ∞ := by finiteness\n\nexample {a : ℝ≥0∞} (ha : a ≠ ∞) : a + 3 < ∞ := by finiteness\nexample {a : ℝ≥0∞} (ha : a < ∞) : a + 3 < ∞ := by finiteness\n\nexample (a : ℝ) : (ENNReal.ofReal (1 + a ^ 2))⁻¹ < ∞ := by finiteness\n\n","proof":":= by finiteness","declId":"PFR.Tactic.Finiteness.77_0.gum9eYJh1s7bDtx","decl":"example (f : α → ℕ) : ∀ i, (f i : ℝ≥0∞) ≠ ∞ "}
