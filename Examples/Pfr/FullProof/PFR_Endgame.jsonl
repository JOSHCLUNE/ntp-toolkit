{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n","proof":":= X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/","declId":"PFR.Endgame.5_0.rp2YyFquz9NknDI","decl":"/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n","proof":":= d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]","declId":"PFR.Endgame.55_0.rp2YyFquz9NknDI","decl":"/-- `k "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n","proof":":= X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂","declId":"PFR.Endgame.58_0.rp2YyFquz9NknDI","decl":"/-- `U "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n","proof":":= X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂","declId":"PFR.Endgame.61_0.rp2YyFquz9NknDI","decl":"/-- `V "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n","proof":":= X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁","declId":"PFR.Endgame.64_0.rp2YyFquz9NknDI","decl":"/-- `W "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n","proof":":= X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'","declId":"PFR.Endgame.67_0.rp2YyFquz9NknDI","decl":"/-- `S "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n","proof":":= I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]","declId":"PFR.Endgame.70_0.rp2YyFquz9NknDI","decl":"/-- `I₁ "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n","proof":":= I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]","declId":"PFR.Endgame.74_0.rp2YyFquz9NknDI","decl":"/-- `I₂ "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\n","proof":":= by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply","declId":"PFR.Endgame.79_0.rp2YyFquz9NknDI","decl":"private lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n","proof":":= by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)","declId":"PFR.Endgame.91_0.rp2YyFquz9NknDI","decl":"/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n","proof":":= by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }","declId":"PFR.Endgame.146_0.rp2YyFquz9NknDI","decl":"/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\n","proof":":=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))","declId":"PFR.Endgame.175_0.rp2YyFquz9NknDI","decl":"lemma hU : H[U] = H[X₁' + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add","declId":"PFR.Endgame.181_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\n","proof":":=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add","declId":"PFR.Endgame.180_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\n","proof":":=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))","declId":"PFR.Endgame.184_0.rp2YyFquz9NknDI","decl":"lemma hV : H[V] = H[X₁ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd","declId":"PFR.Endgame.190_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\n","proof":":=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd","declId":"PFR.Endgame.189_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad","declId":"PFR.Endgame.194_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\n","proof":":=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad","declId":"PFR.Endgame.193_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad","declId":"PFR.Endgame.198_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\n","proof":":=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad","declId":"PFR.Endgame.197_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd","declId":"PFR.Endgame.202_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\n","proof":":=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd","declId":"PFR.Endgame.201_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\n","proof":":=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca","declId":"PFR.Endgame.206_0.rp2YyFquz9NknDI","decl":"lemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\n","proof":":=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca","declId":"PFR.Endgame.205_0.rp2YyFquz9NknDI","decl":"variable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n","proof":":= by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring","declId":"PFR.Endgame.210_0.rp2YyFquz9NknDI","decl":"/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\n","proof":":= by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring","declId":"PFR.Endgame.209_0.rp2YyFquz9NknDI","decl":"set_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n","proof":":= by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]","declId":"PFR.Endgame.328_0.rp2YyFquz9NknDI","decl":"/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n","proof":":= \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4","declId":"PFR.Endgame.345_0.rp2YyFquz9NknDI","decl":"/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n","proof":":= \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith","declId":"PFR.Endgame.410_0.rp2YyFquz9NknDI","decl":"/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith\n\n","proof":":= by\n  letI : MeasureSpace Ω' := ⟨μ⟩\n  apply construct_good p X₁ X₂ h_min hT hT₁ hT₂ hT₃","declId":"PFR.Endgame.431_0.rp2YyFquz9NknDI","decl":"lemma construct_good' (μ : Measure Ω') [IsProbabilityMeasure μ]:\n    k ≤ δ[μ] + (p.η/3) * (δ[μ] + c[T₁ ; μ # T₁ ; μ] + c[T₂ ; μ # T₂ ; μ] + c[T₃ ; μ # T₃ ; μ]) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith\n\nlemma construct_good' (μ : Measure Ω') [IsProbabilityMeasure μ]:\n    k ≤ δ[μ] + (p.η/3) * (δ[μ] + c[T₁ ; μ # T₁ ; μ] + c[T₂ ; μ # T₂ ; μ] + c[T₃ ; μ # T₃ ; μ]) := by\n  letI : MeasureSpace Ω' := ⟨μ⟩\n  apply construct_good p X₁ X₂ h_min hT hT₁ hT₂ hT₃\n\n","proof":":= by\n  simp only [integral_eq_sum, smul_sub, smul_add, smul_sub, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib]\n  simp_rw [← integral_eq_sum]\n  rw [← condRuzsaDist'_eq_integral _ hY hZ, ← condRuzsaDist'_eq_integral _ hY hZ, integral_const,\n    integral_const]\n  have : IsProbabilityMeasure (Measure.map Z ℙ) := isProbabilityMeasure_map hZ.aemeasurable\n  simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]","declId":"PFR.Endgame.436_0.rp2YyFquz9NknDI","decl":"lemma cond_c_eq_integral {Y Z : Ω' → G} (hY : Measurable Y) (hZ : Measurable Z) : c[Y | Z # Y | Z] =\n    (Measure.map Z ℙ)[fun z => c[Y ; ℙ[|Z ← z] # Y ; ℙ[|Z ← z]]] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith\n\nlemma construct_good' (μ : Measure Ω') [IsProbabilityMeasure μ]:\n    k ≤ δ[μ] + (p.η/3) * (δ[μ] + c[T₁ ; μ # T₁ ; μ] + c[T₂ ; μ # T₂ ; μ] + c[T₃ ; μ # T₃ ; μ]) := by\n  letI : MeasureSpace Ω' := ⟨μ⟩\n  apply construct_good p X₁ X₂ h_min hT hT₁ hT₂ hT₃\n\nlemma cond_c_eq_integral {Y Z : Ω' → G} (hY : Measurable Y) (hZ : Measurable Z) : c[Y | Z # Y | Z] =\n    (Measure.map Z ℙ)[fun z => c[Y ; ℙ[|Z ← z] # Y ; ℙ[|Z ← z]]] := by\n  simp only [integral_eq_sum, smul_sub, smul_add, smul_sub, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib]\n  simp_rw [← integral_eq_sum]\n  rw [← condRuzsaDist'_eq_integral _ hY hZ, ← condRuzsaDist'_eq_integral _ hY hZ, integral_const,\n    integral_const]\n  have : IsProbabilityMeasure (Measure.map Z ℙ) := isProbabilityMeasure_map hZ.aemeasurable\n  simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n\nvariable {R : Ω' → G} (hR : Measurable R)\nlocal notation3:max \"δ'\" => I[T₁ : T₂|R] + I[T₂ : T₃|R] + I[T₃ : T₁|R]\n\n","proof":":= by\n  simp_rw [condMutualInfo_eq_integral_mutualInfo, integral_eq_sum, smul_add,\n    Finset.sum_add_distrib]","declId":"PFR.Endgame.449_0.rp2YyFquz9NknDI","decl":"lemma delta'_eq_integral : δ' = (Measure.map R ℙ)[fun r => δ[ℙ[|R⁻¹' {r}]]] "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith\n\nlemma construct_good' (μ : Measure Ω') [IsProbabilityMeasure μ]:\n    k ≤ δ[μ] + (p.η/3) * (δ[μ] + c[T₁ ; μ # T₁ ; μ] + c[T₂ ; μ # T₂ ; μ] + c[T₃ ; μ # T₃ ; μ]) := by\n  letI : MeasureSpace Ω' := ⟨μ⟩\n  apply construct_good p X₁ X₂ h_min hT hT₁ hT₂ hT₃\n\nlemma cond_c_eq_integral {Y Z : Ω' → G} (hY : Measurable Y) (hZ : Measurable Z) : c[Y | Z # Y | Z] =\n    (Measure.map Z ℙ)[fun z => c[Y ; ℙ[|Z ← z] # Y ; ℙ[|Z ← z]]] := by\n  simp only [integral_eq_sum, smul_sub, smul_add, smul_sub, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib]\n  simp_rw [← integral_eq_sum]\n  rw [← condRuzsaDist'_eq_integral _ hY hZ, ← condRuzsaDist'_eq_integral _ hY hZ, integral_const,\n    integral_const]\n  have : IsProbabilityMeasure (Measure.map Z ℙ) := isProbabilityMeasure_map hZ.aemeasurable\n  simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n\nvariable {R : Ω' → G} (hR : Measurable R)\nlocal notation3:max \"δ'\" => I[T₁ : T₂|R] + I[T₂ : T₃|R] + I[T₃ : T₁|R]\n\nlemma delta'_eq_integral : δ' = (Measure.map R ℙ)[fun r => δ[ℙ[|R⁻¹' {r}]]] := by\n  simp_rw [condMutualInfo_eq_integral_mutualInfo, integral_eq_sum, smul_add,\n    Finset.sum_add_distrib]\n\n","proof":":= by\n  rw [delta'_eq_integral, cond_c_eq_integral _ _ _ hT₁ hR, cond_c_eq_integral _ _ _ hT₂ hR,\n    cond_c_eq_integral _ _ _ hT₃ hR]\n  simp_rw [integral_eq_sum, ← Finset.sum_add_distrib, ← smul_add, Finset.mul_sum, mul_smul_comm,\n    ← Finset.sum_add_distrib, ← smul_add]\n  simp_rw [← integral_eq_sum]\n  have : IsProbabilityMeasure (Measure.map R ℙ) := isProbabilityMeasure_map (by measurability)\n  calc\n    k = (Measure.map R ℙ)[fun _r => k] := by\n      rw [integral_const]; simp\n    _ ≤ _ := ?_\n  simp_rw [integral_eq_sum]\n  apply Finset.sum_le_sum\n  intro r _\n  by_cases hr : ℙ (R⁻¹' {r}) = 0\n  · rw [Measure.map_apply hR (MeasurableSet.singleton r), hr]\n    simp\n  simp_rw [smul_eq_mul]\n  gcongr (?_ * ?_)\n  · apply rdist_nonneg hX₁ hX₂\n  · rfl\n  have : IsProbabilityMeasure (ℙ[|R ⁻¹' {r}])\n  · refine cond_isProbabilityMeasure ℙ hr\n  apply construct_good' p X₁ X₂ h_min hT hT₁ hT₂ hT₃","declId":"PFR.Endgame.453_0.rp2YyFquz9NknDI","decl":"lemma cond_construct_good :\n    k ≤ δ' + (p.η/3) * (δ' + c[T₁ | R # T₁ | R] + c[T₂ | R # T₂ | R] + c[T₃ | R # T₃ | R]) "}
{"srcUpToDecl":"import PFR.FirstEstimate\nimport PFR.SecondEstimate\nimport PFR.ForMathlib.Elementary\n\n/-!\n# Endgame\n\nThe endgame on tau-minimizers.\n\nAssumptions:\n\n* $X_1, X_2$ are tau-minimizers\n* $X_1, X_2, \\tilde X_1, \\tilde X_2$ be independent random variables, with $X_1,\\tilde X_1$ copies\n    of $X_1$ and $X_2,\\tilde X_2$ copies of $X_2$.\n* $d[X_1;X_2] = k$\n* $U := X_1 + X_2$\n* $V := \\tilde X_1 + X_2$\n* $W := X_1 + \\tilde X_1$\n* $S := X_1 + X_2 + \\tilde X_1 + \\tilde X_2$.\n* $I_1 := I[U : V | S]$\n* $I_2 := I[U : W | S]$\n* $I_3 := I[V : W | S]$ (not explicitly defined in Lean)\n\n# Main results:\n\n* `sum_condMutual_le` : An upper bound on the total conditional mutual information $I_1+I_2+I_3$.\n* `sum_dist_diff_le`: A sum of the \"costs\" of $U$, $V$, $W$.\n* `construct_good`: A construction of two random variables with small Ruzsa distance between them\n  given some random variables with control on total cost, as well as total mutual information.\n-/\n\nopen MeasureTheory ProbabilityTheory\nopen scoped BigOperators\n\n\nvariable {G : Type*} [AddCommGroup G] [Fintype G] [hG : MeasurableSpace G]\n  [MeasurableSingletonClass G] [elem: ElementaryAddCommGroup G 2] [MeasurableAdd₂ G]\n\nvariable {Ω₀₁ Ω₀₂ : Type*} [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\n\nvariable {Ω : Type*} [mΩ : MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n\nvariable (X₁ X₂ X₁' X₂' : Ω → G)\n  (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₁' : Measurable X₁') (hX₂' : Measurable X₂')\n\nvariable (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂')\n\nvariable (h_indep : iIndepFun (fun _i => hG) ![X₁, X₂, X₁', X₂'])\n\nvariable (h_min: tau_minimizes p X₁ X₂)\n\n/-- `k := d[X₁ # X₂]`, the Ruzsa distance `rdist` between X₁ and X₂. -/\nlocal notation3 \"k\" => d[X₁ # X₂]\n\n/-- `U := X₁ + X₂` -/\nlocal notation3 \"U\" => X₁ + X₂\n\n/-- `V := X₁' + X₂` -/\nlocal notation3 \"V\" => X₁' + X₂\n\n/-- `W := X₁' + X₁` -/\nlocal notation3 \"W\" => X₁' + X₁\n\n/-- `S := X₁ + X₂ + X₁' + X₂'` -/\nlocal notation3 \"S\" => X₁ + X₂ + X₁' + X₂'\n\n/-- `I₁ := I[U : V | S]`, the conditional mutual information of `U = X₁ + X₂` and `V = X₁' + X₂`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₁\" => I[U : V | S]\n\n/-- `I₂ := I[U : W | S]`, the conditional mutual information of `U = X₁ + X₂` and `W = X₁' + X₁`\ngiven the quadruple sum `S = X₁ + X₂ + X₁' + X₂'`. -/\nlocal notation3 \"I₂\" => I[U : W | S]\n\n--(Mantas) this times out in the proof below\nprivate lemma hmeas2 :\n    Measurable fun p : Fin 4 → G => ((p 0 + p 1, p 0 + p 2), p 0 + p 1 + p 2 + p 3) := by\n  apply Measurable.prod\n  · apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n  · apply Measurable.add\n    · apply Measurable.add\n      · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n      · apply measurable_pi_apply\n    · apply measurable_pi_apply\n\n/-- The quantity $I_3 = I[V:W|S]$ is equal to $I_2$. -/\nlemma I₃_eq : I[V : W | S] = I₂ := by\n  have h_indep2 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁, X₂'] := by\n    exact h_indep.reindex_four_cbad\n  have hident : IdentDistrib (fun a (i : Fin 4) => ![X₁, X₂, X₁', X₂'] i a)\n    (fun a (j : Fin 4) => ![X₁', X₂, X₁, X₂'] j a) := by\n    exact { aemeasurable_fst := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            aemeasurable_snd := by\n              apply Measurable.aemeasurable\n              rw [measurable_pi_iff]\n              intro x\n              fin_cases x;\n              all_goals aesop\n            map_eq := by\n              rw [← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁, X₂, X₁', X₂'])\n                (Fin.cases hX₁ <| Fin.cases hX₂ <| Fin.cases hX₁' <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep,\n              ← (ProbabilityTheory.iIndepFun_iff_pi_map_eq_map (![X₁', X₂, X₁, X₂'])\n                (Fin.cases hX₁' <| Fin.cases hX₂ <| Fin.cases hX₁ <|\n              Fin.cases hX₂' Fin.rec0)).mp h_indep2]\n              congr\n              ext i\n              fin_cases i\n              all_goals simp [h₁.map_eq] }\n  have hmeas1 : Measurable (fun p : Fin 4 → G => (p 0 + p 1, p 0 + p 1 + p 2 + p 3)) := by\n    simp_all only [Matrix.cons_val', Matrix.empty_val', Matrix.cons_val_fin_one]\n    apply Measurable.prod\n    · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n    · apply Measurable.add\n      · apply Measurable.add\n        · exact (measurable_pi_apply _).add (measurable_pi_apply _)\n        · apply measurable_pi_apply\n      · apply measurable_pi_apply\n  have hUVS : IdentDistrib (prod U S) (prod V S)\n  · convert (IdentDistrib.comp hident hmeas1)\n    all_goals {simp; abel}\n  have hUVWS : IdentDistrib (prod (prod U W) S) (prod (prod V W) S)\n  · convert (IdentDistrib.comp hident hmeas2)\n    all_goals {simp; abel}\n  have hU : Measurable U := Measurable.add hX₁ hX₂\n  have hV : Measurable V := Measurable.add hX₁' hX₂\n  have hW : Measurable W := Measurable.add hX₁' hX₁\n  have hS : Measurable S := by measurability\n  rw [condMutualInfo_eq hV hW hS, condMutualInfo_eq hU hW hS, chain_rule'' ℙ hU hS,\n    chain_rule'' ℙ hV hS, chain_rule'' ℙ hW hS, chain_rule'' ℙ _ hS, chain_rule'' ℙ _ hS,\n    IdentDistrib.entropy_eq hUVS, IdentDistrib.entropy_eq hUVWS]\n  · exact Measurable.prod (by exact hU) (by exact hW)\n  · exact Measurable.prod (by exact hV) (by exact hW)\n\n\n/--\n$$ I(U : V | S) + I(V : W | S) + I(W : U | S) $$\nis less than or equal to\n$$ 6 \\eta k - \\frac{1 - 5 \\eta}{1-\\eta} (2 \\eta k - I_1).$$\n-/\nlemma sum_condMutual_le :\n    I[U : V | S] + I[V : W | S] + I[W : U | S]\n      ≤ 6 * p.η * k - (1 - 5 * p.η) / (1 - p.η) * (2 * p.η * k - I₁) := by\n  have : I[W:U|S] = I₂ := by\n    rw [condMutualInfo_comm]\n    · exact Measurable.add' hX₁' hX₁\n    · exact Measurable.add' hX₁ hX₂\n  rw [I₃_eq, this]\n  have h₂ := second_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h := add_le_add (add_le_add_left h₂ I₁) h₂\n  convert h using 1\n  have : 1 - p.η > 0 := by linarith [p.hη']\n  field_simp [this]\n  ring\n  all_goals { simpa }\n\nlocal notation3:max \"c[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[p.X₀₁; ℙ # A; μ] - d[p.X₀₁ # X₁] + (d[p.X₀₂; ℙ # B; μ'] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" # \" B \"]\" =>\n  d[p.X₀₁ # A] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # B] - d[p.X₀₂ # X₂])\n\nlocal notation3:max \"c[\" A \" | \" B \" # \" C \" | \" D \"]\" => d[p.X₀₁ # A|B] - d[p.X₀₁ # X₁] + (d[p.X₀₂ # C|D] - d[p.X₀₂ # X₂])\n\nlemma hU : H[U] = H[X₁' + X₂'] :=\n  IdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁ h₂\n    (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 1 by norm_cast))\n     (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition1 : iIndepFun (fun _ ↦ hG) ![X₁, X₂, X₁' + X₂'] :=\n  h_indep.apply_two_last hX₁ hX₂ hX₁' hX₂' measurable_add\n\nlemma hV : H[V] = H[X₁ + X₂'] :=\nIdentDistrib.entropy_eq (ProbabilityTheory.IdentDistrib.add h₁.symm h₂\n  (iIndepFun.indepFun h_indep (show (2 : Fin 4) ≠ 1 by norm_cast))\n  (iIndepFun.indepFun h_indep (show (0 : Fin 4) ≠ 3 by norm_cast)))\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition2 : iIndepFun (fun _ ↦ hG) ![X₂, X₁, X₁' + X₂'] :=\n  independenceCondition1 hX₂ hX₁ hX₁' hX₂' h_indep.reindex_four_bacd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition3 : iIndepFun (fun _ ↦ hG) ![X₁', X₂, X₁ + X₂'] :=\n  independenceCondition1 hX₁' hX₂ hX₁ hX₂' h_indep.reindex_four_cbad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition4 : iIndepFun (fun _ ↦ hG) ![X₂, X₁', X₁ + X₂'] :=\n  independenceCondition1 hX₂ hX₁' hX₁ hX₂' h_indep.reindex_four_bcad\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition5 : iIndepFun (fun _ ↦ hG) ![X₁, X₁', X₂ + X₂'] :=\n  independenceCondition1 hX₁ hX₁' hX₂ hX₂' h_indep.reindex_four_acbd\n\nvariable {X₁ X₂ X₁' X₂'} in\nlemma independenceCondition6 : iIndepFun (fun _ ↦ hG) ![X₂, X₂', X₁' + X₁] :=\n  independenceCondition1 hX₂ hX₂' hX₁' hX₁ h_indep.reindex_four_bdca\n\nset_option maxHeartbeats 400000 in\n/--\n$$ \\sum_{i=1}^2 \\sum_{A\\in\\{U,V,W\\}} \\big(d[X^0_i;A|S] - d[X^0_i;X_i]\\big)$$\nis less than or equal to\n$$ \\leq (6 - 3\\eta) k + 3(2 \\eta k - I_1).$$\n-/\nlemma sum_dist_diff_le :\n  c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by\n  let X₀₁ := p.X₀₁\n  let X₀₂ := p.X₀₂\n\n  have ineq1 : d[X₀₁ # U | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₁] - H[X₁' + X₂'] = H[S] - H[X₁]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₁ # U | U + (X₁' + X₂')] - d[X₀₁ # X₁]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₁] - H[X₁' + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (hX := p.hmeas1) (hY := hX₁) (hZ := hX₂)\n      (Measurable.add hX₁' hX₂') (independenceCondition1 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have ineq2 : d[X₀₂ # U | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux1 : H[S] + H[U] - H[X₂] - H[X₁' + X₂'] = H[S] - H[X₂]\n    · rw [hU X₁ X₂ X₁' X₂' h₁ h₂ h_indep] ; ring\n    have aux2 : d[X₀₂ # U | U + (X₁' + X₂')] - d[X₀₂ # X₂]\n            ≤ (H[U + (X₁' + X₂')] + H[U] - H[X₂] - H[X₁' + X₂']) / 2\n    · rw [(show U = X₂ + X₁ from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁)\n        (Measurable.add hX₁' hX₂') (independenceCondition2 hX₁ hX₂ hX₁' hX₂' h_indep)\n    rw [← add_assoc, aux1] at aux2\n    linarith [aux2]\n\n  have V_add_eq : V + (X₁ + X₂') = S := by abel\n\n  have ineq3 : d[X₀₁ # V | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2\n  · have aux2 : d[p.X₀₁ # V | V + (X₁ + X₂')] - d[p.X₀₁ # X₁']\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₁'] - H[X₁ + X₂']) / 2 :=\n      condRuzsaDist_diff_ofsum_le ℙ (p.hmeas1) (hX₁') (hX₂) (Measurable.add hX₁ hX₂')\n      (independenceCondition3 hX₁ hX₂ hX₁' hX₂' h_indep)\n\n    have aux1 : H[S] + H[V] - H[X₁'] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₁ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep, h₁.entropy_eq]; ring\n    rw [← ProbabilityTheory.IdentDistrib.rdist_eq (IdentDistrib.refl p.hmeas1.aemeasurable) h₁,\n      V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  have ineq4 : d[X₀₂ # V | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] - H[X₂ ; ℙ])/2\n  · have aux2 : d[p.X₀₂ # V | V + (X₁ + X₂')] - d[p.X₀₂ # X₂]\n            ≤ (H[V + (X₁ + X₂')] + H[V] - H[X₂] - H[X₁ + X₂']) / 2\n    · rw [(show V = X₂ + X₁' from add_comm _ _)]\n      apply condRuzsaDist_diff_ofsum_le ℙ (p.hmeas2) (hX₂) (hX₁') (Measurable.add hX₁ hX₂')\n        (independenceCondition4 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have aux1 : H[S] + H[V] - H[X₂] - H[X₁ + X₂'] = H[S ; ℙ] - H[X₂ ; ℙ]\n    · rw [hV X₁ X₂ X₁' X₂' h₁ h₂ h_indep]; ring\n    rw [V_add_eq, aux1] at aux2\n    linarith [aux2]\n\n  let W' := X₂ + X₂'\n  have ineq5 : d[X₀₁ # W | S] - d[X₀₁ # X₁] ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas1 hX₁ hX₁' (Measurable.add hX₂ hX₂')\n      (independenceCondition5 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₁ + X₁' + (fun a ↦ X₂ a + X₂' a) = S\n    · rw [(show (fun a ↦ X₂ a + X₂' a) = X₂ + X₂' by rfl), ← add_assoc, add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq, add_comm X₁ X₁'] at this\n\n  have ineq6 : d[X₀₂ # W' | S] - d[X₀₂ # X₂] ≤ (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n  · have := condRuzsaDist_diff_ofsum_le ℙ p.hmeas2 hX₂ hX₂' (Measurable.add hX₁' hX₁)\n      (independenceCondition6 hX₁ hX₂ hX₁' hX₂' h_indep)\n    have S_eq : X₂ + X₂' + (fun a ↦ X₁' a + X₁ a) = S\n    · rw [(show (fun a ↦ X₁' a + X₁ a) = X₁' + X₁ by rfl), add_comm, ← add_assoc, add_comm X₁',\n      add_assoc X₁, add_comm X₁', ← add_assoc]\n    rwa [S_eq] at this\n\n  have dist_eq : d[X₀₂ # W' | S] = d[X₀₂ # W | S]\n  · have S_eq : S = (X₂ + X₂') + (X₁' + X₁)\n    · rw [add_comm X₁' X₁, add_assoc _ X₂', add_comm X₂', ← add_assoc X₂, ← add_assoc X₂, add_comm X₂]\n    rw [S_eq]\n    apply  condRuzsaDist'_of_inj_map' p.hmeas2 (hX₂.add hX₂') (hX₁'.add hX₁)\n\n  -- Put everything together to bound the sum of the `c` terms\n  have ineq7 : c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ]\n  · have step₁ : c[U|S # U|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[U|S # U|S] = (d[p.X₀₁ # U|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # U|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq1 ineq2\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₂ : c[V|S # V|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[V|S # V|S] =(d[p.X₀₁ # V|S] - d[p.X₀₁ # X₁]) + (d[p.X₀₂ # V|S] - d[p.X₀₂ # X₂]) := by ring\n        _ ≤ (H[S ; ℙ] - H[X₁ ; ℙ])/2 + (H[S ; ℙ] - H[X₂ ; ℙ])/2 := add_le_add ineq3 ineq4\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    have step₃ : c[W|S # W|S] ≤ H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2\n    · calc c[W|S # W|S] = (d[X₀₁ # W | S] - d[X₀₁ # X₁]) + (d[X₀₂ # W' | S] - d[X₀₂ # X₂]) :=\n          by rw [dist_eq]\n        _ ≤ (H[S ; ℙ] + H[W ; ℙ] - H[X₁ ; ℙ] - H[W' ; ℙ])/2 + (H[S ; ℙ] + H[W' ; ℙ] - H[X₂ ; ℙ] - H[W ; ℙ])/2\n          := add_le_add ineq5 ineq6\n        _ = H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2 := by ring\n    calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) +\n      (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) + (H[S ; ℙ] - (H[X₁ ; ℙ] + H[X₂ ; ℙ])/2) :=\n        add_le_add (add_le_add step₁ step₂) step₃\n    _ = 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := by ring\n\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁']\n  · apply ProbabilityTheory.iIndepFun.reindex (Equiv.swap (2 : Fin 4) 3)\n    convert h_indep using 1\n    ext x\n    fin_cases x ; all_goals { aesop }\n\n  have ineq8 : 3 * H[S ; ℙ] ≤ 3/2 * (H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁\n  · calc 3 * H[S ; ℙ] ≤ 3 * (H[X₁ ; ℙ] / 2 + H[X₂ ; ℙ] / 2 + (2+p.η)*k - I₁) := by\n          apply (mul_le_mul_left (zero_lt_three' ℝ)).mpr\n            (ent_ofsum_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min)\n      _ =  3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁ := by ring\n\n  -- Final computation\n  calc c[U|S # U|S] + c[V|S # V|S] + c[W|S # W|S] ≤ 3 * H[S ; ℙ] - 3/2 * H[X₁ ; ℙ] -3/2 * H[X₂ ; ℙ] := ineq7\n     _ = 3 * H[S ; ℙ] - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) := by ring\n     _ ≤ (3/2 * ( H[X₁ ; ℙ] + H[X₂ ; ℙ]) + 3*(2+p.η)*k - 3*I₁) - (3/2 *(H[X₁ ; ℙ] + H[X₂ ; ℙ])) :=\n        sub_le_sub_right ineq8 _\n     _ = (6 - 3 * p.η)*k + 3 * (2*p.η*k - I₁) := by ring\n\n/-- $U+V+W=0$. -/\nlemma sum_uvw_eq_zero : U+V+W = 0 := by\n  rw [add_comm X₁' X₂, ElementaryAddCommGroup.sum_add_sum_add_sum_eq_zero]\n\nsection construct_good\nvariable {Ω' : Type*} [MeasureSpace Ω'] [IsProbabilityMeasure (ℙ : Measure Ω')]\nvariable {T₁ T₂ T₃ : Ω' → G} (hT : T₁+T₂+T₃ = 0)\nvariable (hT₁ : Measurable T₁) (hT₂ : Measurable T₂) (hT₃ : Measurable T₃)\n\n\nlocal notation3:max \"δ[\" μ \"]\" => I[T₁ : T₂ ; μ] + I[T₂ : T₃ ; μ] + I[T₃ : T₁ ; μ]\nlocal notation3:max \"δ\" => I[T₁ : T₂] + I[T₂ : T₃] + I[T₃ : T₁]\n\nlocal notation3:max \"ψ[\" A \" # \" B \"]\" => d[A # B] + p.η * (c[A # B])\nlocal notation3:max \"ψ[\" A \"; \" μ \" # \" B \" ; \" μ' \"]\" =>\n  d[A ; μ # B ; μ'] + p.η * c[A ; μ # B ; μ']\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\nThen there exist random variables $T'_1, T'_2$ such that\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X_1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2]) $$\nis at most\n$$ \\delta + \\eta ( d[X^0_1;T_1]-d[X^0_1;X_1]) + \\eta (d[X^0_2;T_2]-d[X^0_2;X_2]) $$\n$$ + \\tfrac12 \\eta I[T_1: T_3] + \\tfrac12 \\eta I[T_2: T_3].$$\n-/\nlemma construct_good_prelim :\n    k ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁: T₃] + I[T₂ : T₃])/2 := by\n  let sum1 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n  let sum2 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₁; ℙ # T₁; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₁ # X₁]]\n  let sum3 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ d[p.X₀₂; ℙ # T₂; ℙ[|T₃ ⁻¹' {t}]] - d[p.X₀₂ # X₂]]\n  let sum4 : ℝ := (Measure.map T₃ ℙ)[fun t ↦ ψ[T₁; ℙ[|T₃ ⁻¹' {t}] # T₂; ℙ[|T₃ ⁻¹' {t}]]]\n\n  have hp.η : 0 ≤ p.η := by linarith [p.hη]\n  have hP : IsProbabilityMeasure (Measure.map T₃ ℙ) := isProbabilityMeasure_map hT₃.aemeasurable\n  have h2T₃ : T₃ = T₁ + T₂\n  · calc T₃ = T₁ + T₂ + T₃ - T₃ := by rw [hT, zero_sub]; simp\n      _ = T₁ + T₂ := by rw [add_sub_cancel]\n  have h2T₁ : T₁ = T₂ + T₃ := by simp [h2T₃, add_left_comm]\n  have h2T₂ : T₂ = T₃ + T₁ := by simp [h2T₁, add_left_comm]\n\n  have h1 : sum1 ≤ δ\n  · have h1 : sum1 ≤ 3 * I[T₁ : T₂] + 2 * H[T₃] - H[T₁] - H[T₂] := by\n      subst h2T₃; exact ent_bsg hT₁ hT₂\n    have h2 : H[⟨T₂, T₃⟩] = H[⟨T₁, T₂⟩]\n    · rw [h2T₃, entropy_add_right', entropy_comm] <;> assumption\n    have h3 : H[⟨T₁, T₂⟩] = H[⟨T₃, T₁⟩]\n    · rw [h2T₃, entropy_add_left, entropy_comm] <;> assumption\n    simp_rw [mutualInfo_def] at h1 ⊢; linarith\n\n  have h2 : p.η * sum2 ≤ p.η * (d[p.X₀₁ # T₁] - d[p.X₀₁ # X₁] + I[T₁ : T₃] / 2)\n  · have : sum2 = d[p.X₀₁ # T₁ | T₃] - d[p.X₀₁ # X₁]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₁ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas1 hT₁ hT₃]\n\n  have h3 : p.η * sum3 ≤ p.η * (d[p.X₀₂ # T₂] - d[p.X₀₂ # X₂] + I[T₂ : T₃] / 2)\n  · have : sum3 = d[p.X₀₂ # T₂ | T₃] - d[p.X₀₂ # X₂]\n    · simp [integral_sub (integrable_of_fintype _ _) (integrable_of_fintype _ _)]\n      simp_rw [condRuzsaDist'_eq_sum hT₂ hT₃, integral_eq_sum' _ (FiniteRange.null_of_compl _ T₃),\n        Measure.map_apply hT₃ (measurableSet_singleton _), smul_eq_mul]\n    gcongr\n    linarith [condRuzsaDist_le' ℙ ℙ p.hmeas2 hT₂ hT₃]\n\n  have h4 : sum4 ≤ δ + p.η * c[T₁ # T₂] + p.η * (I[T₁ : T₃] + I[T₂ : T₃]) / 2\n  · have : sum4 = sum1 + p.η * (sum2 + sum3)\n    · simp only [integral_add (integrable_of_fintype _ _) (integrable_of_fintype _ _),\n        integral_mul_left]\n    linarith\n\n  have hk : k ≤ sum4\n  · suffices (Measure.map T₃ ℙ)[fun _ ↦ k] ≤ sum4 by simpa using this\n    refine integral_mono_ae (integrable_of_fintype _ _) (integrable_of_fintype _ _) $\n      ae_iff_of_countable.2 fun t ht ↦ ?_\n    have : IsProbabilityMeasure (ℙ[|T₃ ⁻¹' {t}]) :=\n      cond_isProbabilityMeasure ℙ (by simpa [hT₃] using ht)\n    dsimp only\n    linarith only [distance_ge_of_min' (μ := ℙ[|T₃ ⁻¹' {t}]) (μ' := ℙ[|T₃ ⁻¹' {t}]) p h_min hT₁ hT₂]\n  exact hk.trans h4\n\n/-- If $T_1, T_2, T_3$ are $G$-valued random variables with $T_1+T_2+T_3=0$ holds identically and\n-\n$$ \\delta := \\sum_{1 \\leq i < j \\leq 3} I[T_i;T_j]$$\n\nThen there exist random variables $T'_1, T'_2$ such that\n\n$$ d[T'_1;T'_2] + \\eta (d[X_1^0;T'_1] - d[X_1^0;X _1]) + \\eta(d[X_2^0;T'_2] - d[X_2^0;X_2])$$\n\nis at most\n\n$$\\delta + \\frac{\\eta}{3} \\biggl( \\delta + \\sum_{i=1}^2 \\sum_{j = 1}^3\n    (d[X^0_i;T_j] - d[X^0_i; X_i]) \\biggr).$$\n-/\nlemma construct_good : k ≤ δ + (p.η/3) * (δ + c[T₁ # T₁] + c[T₂ # T₂] + c[T₃ # T₃]) := by\n  have v2 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₁ hT₃ hT₂\n  have v3 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₂ hT₁ hT₃\n  have v6 := construct_good_prelim p X₁ X₂ h_min (by rw [← hT]; abel) hT₃ hT₂ hT₁\n  simp only [mutualInfo, entropy_comm hT₂ hT₁, entropy_comm hT₃ hT₁, entropy_comm hT₃ hT₂]\n    at *\n  linarith\n\nlemma construct_good' (μ : Measure Ω') [IsProbabilityMeasure μ]:\n    k ≤ δ[μ] + (p.η/3) * (δ[μ] + c[T₁ ; μ # T₁ ; μ] + c[T₂ ; μ # T₂ ; μ] + c[T₃ ; μ # T₃ ; μ]) := by\n  letI : MeasureSpace Ω' := ⟨μ⟩\n  apply construct_good p X₁ X₂ h_min hT hT₁ hT₂ hT₃\n\nlemma cond_c_eq_integral {Y Z : Ω' → G} (hY : Measurable Y) (hZ : Measurable Z) : c[Y | Z # Y | Z] =\n    (Measure.map Z ℙ)[fun z => c[Y ; ℙ[|Z ← z] # Y ; ℙ[|Z ← z]]] := by\n  simp only [integral_eq_sum, smul_sub, smul_add, smul_sub, Finset.sum_sub_distrib,\n    Finset.sum_add_distrib]\n  simp_rw [← integral_eq_sum]\n  rw [← condRuzsaDist'_eq_integral _ hY hZ, ← condRuzsaDist'_eq_integral _ hY hZ, integral_const,\n    integral_const]\n  have : IsProbabilityMeasure (Measure.map Z ℙ) := isProbabilityMeasure_map hZ.aemeasurable\n  simp only [measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n\nvariable {R : Ω' → G} (hR : Measurable R)\nlocal notation3:max \"δ'\" => I[T₁ : T₂|R] + I[T₂ : T₃|R] + I[T₃ : T₁|R]\n\nlemma delta'_eq_integral : δ' = (Measure.map R ℙ)[fun r => δ[ℙ[|R⁻¹' {r}]]] := by\n  simp_rw [condMutualInfo_eq_integral_mutualInfo, integral_eq_sum, smul_add,\n    Finset.sum_add_distrib]\n\nlemma cond_construct_good :\n    k ≤ δ' + (p.η/3) * (δ' + c[T₁ | R # T₁ | R] + c[T₂ | R # T₂ | R] + c[T₃ | R # T₃ | R]) := by\n  rw [delta'_eq_integral, cond_c_eq_integral _ _ _ hT₁ hR, cond_c_eq_integral _ _ _ hT₂ hR,\n    cond_c_eq_integral _ _ _ hT₃ hR]\n  simp_rw [integral_eq_sum, ← Finset.sum_add_distrib, ← smul_add, Finset.mul_sum, mul_smul_comm,\n    ← Finset.sum_add_distrib, ← smul_add]\n  simp_rw [← integral_eq_sum]\n  have : IsProbabilityMeasure (Measure.map R ℙ) := isProbabilityMeasure_map (by measurability)\n  calc\n    k = (Measure.map R ℙ)[fun _r => k] := by\n      rw [integral_const]; simp\n    _ ≤ _ := ?_\n  simp_rw [integral_eq_sum]\n  apply Finset.sum_le_sum\n  intro r _\n  by_cases hr : ℙ (R⁻¹' {r}) = 0\n  · rw [Measure.map_apply hR (MeasurableSet.singleton r), hr]\n    simp\n  simp_rw [smul_eq_mul]\n  gcongr (?_ * ?_)\n  · apply rdist_nonneg hX₁ hX₂\n  · rfl\n  have : IsProbabilityMeasure (ℙ[|R ⁻¹' {r}])\n  · refine cond_isProbabilityMeasure ℙ hr\n  apply construct_good' p X₁ X₂ h_min hT hT₁ hT₂ hT₃\n\nend construct_good\n\n","proof":":= by\n  have h0 := cond_construct_good p X₁ X₂ hX₁ hX₂ h_min (sum_uvw_eq_zero ..)\n    (show Measurable U by measurability) (show Measurable V by measurability)\n    (show Measurable W by measurability) (show Measurable S by measurability)\n  have h1 := sum_condMutual_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h2 := sum_dist_diff_le p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep h_min\n  have h_indep' : iIndepFun (fun _i => hG) ![X₁, X₂, X₂', X₁'] := by\n    let σ : Fin 4 ≃ Fin 4 :=\n    { toFun := ![0, 1, 3, 2]\n      invFun := ![0, 1, 3, 2]\n      left_inv := by intro i; fin_cases i <;> rfl\n      right_inv := by intro i; fin_cases i <;> rfl }\n    refine' iIndepFun.reindex σ.symm _\n    convert h_indep using 1\n    ext i; fin_cases i <;> rfl\n  have h3 := first_estimate p X₁ X₂ X₁' X₂' hX₁ hX₂ hX₁' hX₂' h₁ h₂ h_indep' h_min\n  have h : k ≤ (8*p.η + p.η^2) * k := calc\n    k ≤ (1+p.η/3) * (6*p.η*k - (1-5*p.η) / (1-p.η) * (2*p.η*k - I₁)) + p.η/3*((6-3*p.η)*k + 3*(2*p.η*k-I₁)) := by\n      rw [hpη] at *\n      linarith\n    _ = (8*p.η+p.η^2)*k - ((1-5*p.η)/(1-p.η)*(1+p.η/3)-p.η)*(2*p.η*k-I₁) := by\n      ring\n    _ ≤ (8*p.η + p.η^2) * k := by\n      rw [hpη] at *\n      norm_num\n      linarith\n  have : 0 ≤ k := rdist_nonneg hX₁ hX₂\n  rw [hpη] at *\n  linarith","declId":"PFR.Endgame.481_0.rp2YyFquz9NknDI","decl":"/-- If $d[X_1;X_2] > 0$ then there are $G$-valued random variables $X'_1, X'_2$ such that\nPhrased in the contrapositive form for convenience of proof. -/\ntheorem tau_strictly_decreases_aux (hpη: p.η = 1/9): d[X₁ # X₂] = 0 "}
