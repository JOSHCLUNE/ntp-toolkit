{"srcUpToDecl":"import Mathlib.Probability.Kernel.MeasureCompProd\nimport Mathlib.Probability.Kernel.Composition\n\n/-!\n# Composition-Product of a measure and a kernel\n\nThis operation, denoted by `⊗ₘ`, takes `μ : Measure α` and `κ : kernel α β` and creates\n`μ ⊗ₘ κ : Measure (α × β)`.\n\nIt is defined as `((kernel.const Unit μ) ⊗ₖ (kernel.prodMkLeft Unit κ)) ()`.\n\n## Main definitions\n\n* `Measure.compProd`: from `μ : Measure α` and `κ : kernel α β`, get a `Measure (α × β)`.\n\n## Notations\n\n* `μ ⊗ₘ κ = μ.compProd κ`\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {α β γ δ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ}\n\n","proof":":= by\n  rw [compProd_apply _ _ _ (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]","declId":"PFR.Mathlib.Probability.Kernel.MeasureCompProd.29_0.3FG2L4dl2ZgLJIB","decl":"lemma compProd_preimage_fst (κ : kernel α β) (η : kernel (α × β) γ) [IsSFiniteKernel κ]\n    [IsMarkovKernel η] {x : α} {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.MeasureCompProd\nimport Mathlib.Probability.Kernel.Composition\n\n/-!\n# Composition-Product of a measure and a kernel\n\nThis operation, denoted by `⊗ₘ`, takes `μ : Measure α` and `κ : kernel α β` and creates\n`μ ⊗ₘ κ : Measure (α × β)`.\n\nIt is defined as `((kernel.const Unit μ) ⊗ₖ (kernel.prodMkLeft Unit κ)) ()`.\n\n## Main definitions\n\n* `Measure.compProd`: from `μ : Measure α` and `κ : kernel α β`, get a `Measure (α × β)`.\n\n## Notations\n\n* `μ ⊗ₘ κ = μ.compProd κ`\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {α β γ δ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ}\n\nlemma compProd_preimage_fst (κ : kernel α β) (η : kernel (α × β) γ) [IsSFiniteKernel κ]\n    [IsMarkovKernel η] {x : α} {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s := by\n  rw [compProd_apply _ _ _ (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]\n\n","proof":":= by\n  rw [compProd_apply _ _ _ hs]\n  simp only [deterministic_apply, measurableSet_setOf, Set.mem_setOf_eq, Measure.dirac_apply]\n  classical\n  simp only [Set.mem_setOf_eq, Set.indicator_apply, Pi.one_apply]\n  let t := {b | (b, f (x, b)) ∈ s}\n  have ht : MeasurableSet t := (measurable_id.prod_mk (hf.comp measurable_prod_mk_left)) hs\n  rw [← lintegral_add_compl _ ht]\n  have h1 : ∫⁻ b in t, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = κ x {b | (b, f (x, b)) ∈ s} := by\n    suffices ∀ b ∈ t, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 1 by\n      rw [set_lintegral_congr_fun ht (ae_of_all _ this), set_lintegral_one]\n    intro b hb\n    simp only [Set.mem_setOf_eq] at hb\n    simp [hb]\n  have h2 : ∫⁻ b in tᶜ, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = 0 := by\n    suffices ∀ b ∈ tᶜ, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 0 by\n      rw [set_lintegral_congr_fun ht.compl (ae_of_all _ this), lintegral_zero]\n    intro b hb\n    simp only [Set.mem_compl_iff, Set.mem_setOf_eq] at hb\n    simp [hb]\n  rw [h1, h2, add_zero]","declId":"PFR.Mathlib.Probability.Kernel.MeasureCompProd.41_0.3FG2L4dl2ZgLJIB","decl":"lemma compProd_deterministic_apply [MeasurableSingletonClass γ]\n    (κ : kernel α β) [IsSFiniteKernel κ]\n    {f : α × β → γ} (hf : Measurable f) (x : α) {s : Set (β × γ)} (hs : MeasurableSet s) :\n    (κ ⊗ₖ deterministic f hf) x s = κ x {b | (b, f (x, b)) ∈ s} "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.MeasureCompProd\nimport Mathlib.Probability.Kernel.Composition\n\n/-!\n# Composition-Product of a measure and a kernel\n\nThis operation, denoted by `⊗ₘ`, takes `μ : Measure α` and `κ : kernel α β` and creates\n`μ ⊗ₘ κ : Measure (α × β)`.\n\nIt is defined as `((kernel.const Unit μ) ⊗ₖ (kernel.prodMkLeft Unit κ)) ()`.\n\n## Main definitions\n\n* `Measure.compProd`: from `μ : Measure α` and `κ : kernel α β`, get a `Measure (α × β)`.\n\n## Notations\n\n* `μ ⊗ₘ κ = μ.compProd κ`\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {α β γ δ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ}\n\nlemma compProd_preimage_fst (κ : kernel α β) (η : kernel (α × β) γ) [IsSFiniteKernel κ]\n    [IsMarkovKernel η] {x : α} {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s := by\n  rw [compProd_apply _ _ _ (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]\n\nlemma compProd_deterministic_apply [MeasurableSingletonClass γ]\n    (κ : kernel α β) [IsSFiniteKernel κ]\n    {f : α × β → γ} (hf : Measurable f) (x : α) {s : Set (β × γ)} (hs : MeasurableSet s) :\n    (κ ⊗ₖ deterministic f hf) x s = κ x {b | (b, f (x, b)) ∈ s} := by\n  rw [compProd_apply _ _ _ hs]\n  simp only [deterministic_apply, measurableSet_setOf, Set.mem_setOf_eq, Measure.dirac_apply]\n  classical\n  simp only [Set.mem_setOf_eq, Set.indicator_apply, Pi.one_apply]\n  let t := {b | (b, f (x, b)) ∈ s}\n  have ht : MeasurableSet t := (measurable_id.prod_mk (hf.comp measurable_prod_mk_left)) hs\n  rw [← lintegral_add_compl _ ht]\n  have h1 : ∫⁻ b in t, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = κ x {b | (b, f (x, b)) ∈ s} := by\n    suffices ∀ b ∈ t, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 1 by\n      rw [set_lintegral_congr_fun ht (ae_of_all _ this), set_lintegral_one]\n    intro b hb\n    simp only [Set.mem_setOf_eq] at hb\n    simp [hb]\n  have h2 : ∫⁻ b in tᶜ, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = 0 := by\n    suffices ∀ b ∈ tᶜ, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 0 by\n      rw [set_lintegral_congr_fun ht.compl (ae_of_all _ this), lintegral_zero]\n    intro b hb\n    simp only [Set.mem_compl_iff, Set.mem_setOf_eq] at hb\n    simp [hb]\n  rw [h1, h2, add_zero]\n\nvariable {α β γ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n  {f : β → γ} {g : γ → α}\n\n","proof":":= by\n  ext s hs\n  rw [Measure.comap_apply _ Prod.swap_injective _ _ hs, Measure.map_apply measurable_swap hs,\n    ← Set.image_swap_eq_preimage_swap]\n  intro s hs\n  rw [Set.image_swap_eq_preimage_swap]\n  exact measurable_swap hs","declId":"PFR.Mathlib.Probability.Kernel.MeasureCompProd.69_0.3FG2L4dl2ZgLJIB","decl":"lemma _root_.MeasureTheory.Measure.comap_swap (μ : Measure (α × β)) :\n    μ.comap Prod.swap = μ.map Prod.swap "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.MeasureCompProd\nimport Mathlib.Probability.Kernel.Composition\n\n/-!\n# Composition-Product of a measure and a kernel\n\nThis operation, denoted by `⊗ₘ`, takes `μ : Measure α` and `κ : kernel α β` and creates\n`μ ⊗ₘ κ : Measure (α × β)`.\n\nIt is defined as `((kernel.const Unit μ) ⊗ₖ (kernel.prodMkLeft Unit κ)) ()`.\n\n## Main definitions\n\n* `Measure.compProd`: from `μ : Measure α` and `κ : kernel α β`, get a `Measure (α × β)`.\n\n## Notations\n\n* `μ ⊗ₘ κ = μ.compProd κ`\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {α β γ δ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ}\n\nlemma compProd_preimage_fst (κ : kernel α β) (η : kernel (α × β) γ) [IsSFiniteKernel κ]\n    [IsMarkovKernel η] {x : α} {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s := by\n  rw [compProd_apply _ _ _ (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]\n\nlemma compProd_deterministic_apply [MeasurableSingletonClass γ]\n    (κ : kernel α β) [IsSFiniteKernel κ]\n    {f : α × β → γ} (hf : Measurable f) (x : α) {s : Set (β × γ)} (hs : MeasurableSet s) :\n    (κ ⊗ₖ deterministic f hf) x s = κ x {b | (b, f (x, b)) ∈ s} := by\n  rw [compProd_apply _ _ _ hs]\n  simp only [deterministic_apply, measurableSet_setOf, Set.mem_setOf_eq, Measure.dirac_apply]\n  classical\n  simp only [Set.mem_setOf_eq, Set.indicator_apply, Pi.one_apply]\n  let t := {b | (b, f (x, b)) ∈ s}\n  have ht : MeasurableSet t := (measurable_id.prod_mk (hf.comp measurable_prod_mk_left)) hs\n  rw [← lintegral_add_compl _ ht]\n  have h1 : ∫⁻ b in t, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = κ x {b | (b, f (x, b)) ∈ s} := by\n    suffices ∀ b ∈ t, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 1 by\n      rw [set_lintegral_congr_fun ht (ae_of_all _ this), set_lintegral_one]\n    intro b hb\n    simp only [Set.mem_setOf_eq] at hb\n    simp [hb]\n  have h2 : ∫⁻ b in tᶜ, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = 0 := by\n    suffices ∀ b ∈ tᶜ, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 0 by\n      rw [set_lintegral_congr_fun ht.compl (ae_of_all _ this), lintegral_zero]\n    intro b hb\n    simp only [Set.mem_compl_iff, Set.mem_setOf_eq] at hb\n    simp [hb]\n  rw [h1, h2, add_zero]\n\nvariable {α β γ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n  {f : β → γ} {g : γ → α}\n\nlemma _root_.MeasureTheory.Measure.comap_swap (μ : Measure (α × β)) :\n    μ.comap Prod.swap = μ.map Prod.swap := by\n  ext s hs\n  rw [Measure.comap_apply _ Prod.swap_injective _ _ hs, Measure.map_apply measurable_swap hs,\n    ← Set.image_swap_eq_preimage_swap]\n  intro s hs\n  rw [Set.image_swap_eq_preimage_swap]\n  exact measurable_swap hs\n\n","proof":":= by\n  rw [ext_fun_iff]\n  intro x f hf\n  rw [lintegral_comap, lintegral_map _ _ _ hf, lintegral_prod _ _ _ hf,\n    lintegral_prod]\n  swap; · exact hf.comp measurable_swap\n  simp only [prodMkRight_apply, Prod.fst_swap, Prod.swap_prod_mk, lintegral_prodMkLeft,\n    Prod.snd_swap]\n  refine (lintegral_lintegral_swap ?_).symm\n  exact (hf.comp measurable_swap).aemeasurable","declId":"PFR.Mathlib.Probability.Kernel.MeasureCompProd.78_0.3FG2L4dl2ZgLJIB","decl":"lemma comap_prod_swap (κ : kernel α β) (η : kernel γ δ) [IsFiniteKernel κ] [IsFiniteKernel η] :\n    comap (prodMkRight α η ×ₖ prodMkLeft γ κ) Prod.swap measurable_swap\n      = map (prodMkRight γ κ ×ₖ prodMkLeft α η) Prod.swap measurable_swap "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.MeasureCompProd\nimport Mathlib.Probability.Kernel.Composition\n\n/-!\n# Composition-Product of a measure and a kernel\n\nThis operation, denoted by `⊗ₘ`, takes `μ : Measure α` and `κ : kernel α β` and creates\n`μ ⊗ₘ κ : Measure (α × β)`.\n\nIt is defined as `((kernel.const Unit μ) ⊗ₖ (kernel.prodMkLeft Unit κ)) ()`.\n\n## Main definitions\n\n* `Measure.compProd`: from `μ : Measure α` and `κ : kernel α β`, get a `Measure (α × β)`.\n\n## Notations\n\n* `μ ⊗ₘ κ = μ.compProd κ`\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nnamespace ProbabilityTheory.kernel\n\nvariable {α β γ δ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ}\n\nlemma compProd_preimage_fst (κ : kernel α β) (η : kernel (α × β) γ) [IsSFiniteKernel κ]\n    [IsMarkovKernel η] {x : α} {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s := by\n  rw [compProd_apply _ _ _ (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]\n\nlemma compProd_deterministic_apply [MeasurableSingletonClass γ]\n    (κ : kernel α β) [IsSFiniteKernel κ]\n    {f : α × β → γ} (hf : Measurable f) (x : α) {s : Set (β × γ)} (hs : MeasurableSet s) :\n    (κ ⊗ₖ deterministic f hf) x s = κ x {b | (b, f (x, b)) ∈ s} := by\n  rw [compProd_apply _ _ _ hs]\n  simp only [deterministic_apply, measurableSet_setOf, Set.mem_setOf_eq, Measure.dirac_apply]\n  classical\n  simp only [Set.mem_setOf_eq, Set.indicator_apply, Pi.one_apply]\n  let t := {b | (b, f (x, b)) ∈ s}\n  have ht : MeasurableSet t := (measurable_id.prod_mk (hf.comp measurable_prod_mk_left)) hs\n  rw [← lintegral_add_compl _ ht]\n  have h1 : ∫⁻ b in t, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = κ x {b | (b, f (x, b)) ∈ s} := by\n    suffices ∀ b ∈ t, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 1 by\n      rw [set_lintegral_congr_fun ht (ae_of_all _ this), set_lintegral_one]\n    intro b hb\n    simp only [Set.mem_setOf_eq] at hb\n    simp [hb]\n  have h2 : ∫⁻ b in tᶜ, if (b, f (x, b)) ∈ s then 1 else 0 ∂(κ x) = 0 := by\n    suffices ∀ b ∈ tᶜ, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 0 by\n      rw [set_lintegral_congr_fun ht.compl (ae_of_all _ this), lintegral_zero]\n    intro b hb\n    simp only [Set.mem_compl_iff, Set.mem_setOf_eq] at hb\n    simp [hb]\n  rw [h1, h2, add_zero]\n\nvariable {α β γ : Type*} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n  {f : β → γ} {g : γ → α}\n\nlemma _root_.MeasureTheory.Measure.comap_swap (μ : Measure (α × β)) :\n    μ.comap Prod.swap = μ.map Prod.swap := by\n  ext s hs\n  rw [Measure.comap_apply _ Prod.swap_injective _ _ hs, Measure.map_apply measurable_swap hs,\n    ← Set.image_swap_eq_preimage_swap]\n  intro s hs\n  rw [Set.image_swap_eq_preimage_swap]\n  exact measurable_swap hs\n\nlemma comap_prod_swap (κ : kernel α β) (η : kernel γ δ) [IsFiniteKernel κ] [IsFiniteKernel η] :\n    comap (prodMkRight α η ×ₖ prodMkLeft γ κ) Prod.swap measurable_swap\n      = map (prodMkRight γ κ ×ₖ prodMkLeft α η) Prod.swap measurable_swap := by\n  rw [ext_fun_iff]\n  intro x f hf\n  rw [lintegral_comap, lintegral_map _ _ _ hf, lintegral_prod _ _ _ hf,\n    lintegral_prod]\n  swap; · exact hf.comp measurable_swap\n  simp only [prodMkRight_apply, Prod.fst_swap, Prod.swap_prod_mk, lintegral_prodMkLeft,\n    Prod.snd_swap]\n  refine (lintegral_lintegral_swap ?_).symm\n  exact (hf.comp measurable_swap).aemeasurable\n\n","proof":":= by\n  rw [ext_fun_iff]\n  intro x f hf\n  rw [lintegral_map _ _ _ hf, lintegral_prod, lintegral_prod _ _ _ hf]\n  swap; · exact hf.comp measurable_swap\n  refine (lintegral_lintegral_swap ?_).symm\n  exact hf.aemeasurable","declId":"PFR.Mathlib.Probability.Kernel.MeasureCompProd.91_0.3FG2L4dl2ZgLJIB","decl":"lemma map_prod_swap (κ : kernel α β) (η : kernel α γ) [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) Prod.swap measurable_swap = η ×ₖ κ "}
