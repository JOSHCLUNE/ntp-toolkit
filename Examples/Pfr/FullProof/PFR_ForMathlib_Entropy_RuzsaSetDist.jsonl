{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n","proof":":= ((Set.encard H).toENNReal)⁻¹ • (restrict count H)","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.20_0.qmdhKZCJ7oG8kHE","decl":"/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n","proof":":= by\n  simp [discreteUniform, Set.Infinite.encard_eq h]","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.23_0.qmdhKZCJ7oG8kHE","decl":"/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n","proof":":= by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.29_0.qmdhKZCJ7oG8kHE","decl":"/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n","proof":":= by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.42_0.qmdhKZCJ7oG8kHE","decl":"/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\n","proof":":= by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.50_0.qmdhKZCJ7oG8kHE","decl":"instance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n","proof":":= by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.55_0.qmdhKZCJ7oG8kHE","decl":"/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n","proof":":= by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.66_0.qmdhKZCJ7oG8kHE","decl":"/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n","proof":":= by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.109_0.qmdhKZCJ7oG8kHE","decl":"/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n","proof":":= kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.144_0.qmdhKZCJ7oG8kHE","decl":"/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n","proof":":= by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.149_0.qmdhKZCJ7oG8kHE","decl":"/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n","proof":":= by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.160_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes\n\n","proof":":= by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ hUB_unif hUA_unif hUB_mes hUA_mes]\n  exact rdist_symm","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.167_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets is symmetric. -/\nlemma rdist_set_symm (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : dᵤ[A # B] = dᵤ[B # A] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes\n\n/-- Ruzsa distance between sets is symmetric. -/\nlemma rdist_set_symm (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : dᵤ[A # B] = dᵤ[B # A] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ hUB_unif hUA_unif hUB_mes hUA_mes]\n  exact rdist_symm\n\n","proof":":= by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  obtain ⟨ Ω'', mΩ'', UC, hμ'', hUC_mes, hUC_unif, -, hUC_fin ⟩ := exists_isUniform_measureSpace' C\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ'' hUB_unif hUC_unif hUB_mes hUC_mes, rdist_set_eq_rdist hμ hμ'' hUA_unif hUC_unif hUA_mes hUC_mes]\n  exact rdist_triangle hUA_mes hUB_mes hUC_mes","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.174_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets obeys the triangle inequality. -/\nlemma rdist_set_triangle (A B C: Set G) [Finite A] [Finite B] [Finite C] [Nonempty A] [Nonempty B] [Nonempty C] : dᵤ[A # C] ≤ dᵤ[A # B] + dᵤ[B # C] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes\n\n/-- Ruzsa distance between sets is symmetric. -/\nlemma rdist_set_symm (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : dᵤ[A # B] = dᵤ[B # A] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ hUB_unif hUA_unif hUB_mes hUA_mes]\n  exact rdist_symm\n\n/-- Ruzsa distance between sets obeys the triangle inequality. -/\nlemma rdist_set_triangle (A B C: Set G) [Finite A] [Finite B] [Finite C] [Nonempty A] [Nonempty B] [Nonempty C] : dᵤ[A # C] ≤ dᵤ[A # B] + dᵤ[B # C] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  obtain ⟨ Ω'', mΩ'', UC, hμ'', hUC_mes, hUC_unif, -, hUC_fin ⟩ := exists_isUniform_measureSpace' C\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ'' hUB_unif hUC_unif hUB_mes hUC_mes, rdist_set_eq_rdist hμ hμ'' hUA_unif hUC_unif hUA_mes hUC_mes]\n  exact rdist_triangle hUA_mes hUB_mes hUC_mes\n\n","proof":":= by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, <- rdist_add_const' c c' hUA_mes hUB_mes]\n  classical\n  convert rdist_set_eq_rdist (A := A+{c}) (B := B+{c'}) hμ hμ' ?_ ?_ ?_ ?_\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . convert IsUniform.comp (A.toFinite.coe_toFinset.symm ▸ hUA_unif) (add_left_injective c) using 1\n    simp\n  . convert IsUniform.comp (B.toFinite.coe_toFinset.symm ▸ hUB_unif) (add_left_injective c') using 1\n    simp\n  . measurability\n  measurability","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.182_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets is translation invariant. -/\nlemma rdist_set_add_const (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] (c c' : G) : dᵤ[A + {c} # B + {c'}] = dᵤ[A # B] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes\n\n/-- Ruzsa distance between sets is symmetric. -/\nlemma rdist_set_symm (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : dᵤ[A # B] = dᵤ[B # A] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ hUB_unif hUA_unif hUB_mes hUA_mes]\n  exact rdist_symm\n\n/-- Ruzsa distance between sets obeys the triangle inequality. -/\nlemma rdist_set_triangle (A B C: Set G) [Finite A] [Finite B] [Finite C] [Nonempty A] [Nonempty B] [Nonempty C] : dᵤ[A # C] ≤ dᵤ[A # B] + dᵤ[B # C] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  obtain ⟨ Ω'', mΩ'', UC, hμ'', hUC_mes, hUC_unif, -, hUC_fin ⟩ := exists_isUniform_measureSpace' C\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ'' hUB_unif hUC_unif hUB_mes hUC_mes, rdist_set_eq_rdist hμ hμ'' hUA_unif hUC_unif hUA_mes hUC_mes]\n  exact rdist_triangle hUA_mes hUB_mes hUC_mes\n\n/-- Ruzsa distance between sets is translation invariant. -/\nlemma rdist_set_add_const (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] (c c' : G) : dᵤ[A + {c} # B + {c'}] = dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, <- rdist_add_const' c c' hUA_mes hUB_mes]\n  classical\n  convert rdist_set_eq_rdist (A := A+{c}) (B := B+{c'}) hμ hμ' ?_ ?_ ?_ ?_\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . convert IsUniform.comp (A.toFinite.coe_toFinset.symm ▸ hUA_unif) (add_left_injective c) using 1\n    simp\n  . convert IsUniform.comp (B.toFinite.coe_toFinset.symm ▸ hUB_unif) (add_left_injective c') using 1\n    simp\n  . measurability\n  measurability\n\n","proof":":= by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, <-rdist_of_inj hUA_mes hUB_mes φ hφ]\n  classical\n  convert rdist_set_eq_rdist (A := φ '' A) (B := φ '' B) hμ hμ' ?_ ?_ ?_ ?_\n  . convert IsUniform.comp (A.toFinite.coe_toFinset.symm ▸ hUA_unif) hφ using 1\n    ext x; simp\n  . convert IsUniform.comp (B.toFinite.coe_toFinset.symm ▸ hUB_unif) hφ using 1\n    ext x; simp\n  . measurability\n  measurability","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.198_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets is preserved by injective homomorphisms. -/\nlemma rdist_set_of_inj (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n [Countable H] {φ: G →+ H} (hφ: Function.Injective φ) : dᵤ[φ '' A # φ '' B] = dᵤ[A # B] "}
{"srcUpToDecl":"import Mathlib.Data.ENat.Basic\nimport Mathlib.Data.Real.ENatENNReal\nimport Mathlib.Data.Set.Card\nimport PFR.ForMathlib.Entropy.Basic\nimport PFR.ForMathlib.Entropy.RuzsaDist\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.Uniform\n\n\nsection UniformMeasure\n\n/- Here we set up the foundational theory of discrete uniform measures on finite non-empty sets. -/\n\nopen BigOperators\n\nnamespace MeasureTheory.Measure\n\nvariable {S : Type*} [MeasurableSpace S] (H : Set S)\n\n/-- In practice one would also impose the conditions `MeasurableSingletonClass S`, `Finite H` and `Nonempty H` before attempting to use this definition. -/\nnoncomputable def discreteUniform : Measure S := ((Set.encard H).toENNReal)⁻¹ • (restrict count H)\n\n/-- The uniform distribution on an infinite set vanishes by definition. -/\nlemma discreteUniform_of_infinite (h: Set.Infinite H) : discreteUniform H = 0 := by\n  simp [discreteUniform, Set.Infinite.encard_eq h]\n\nvariable [MeasurableSingletonClass S] [Finite H]\n\n/-- The usual formula for the discrete uniform measure applied to an arbitrary set. -/\nlemma discreteUniform_apply (A : Set S) :\n  discreteUniform H A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n    have : Fintype (A ∩ H : Set S) := Fintype.ofFinite (A ∩ H : Set S)\n\n    rw [discreteUniform, smul_apply, restrict_apply' (Set.Finite.measurableSet H.toFinite), count_apply (Set.Finite.measurableSet (A ∩ H).toFinite), tsum_eq_sum (s := Finset.univ)]\n    . simp [Finset.card_univ, ENNReal.div_eq_inv_mul, Set.Nat.card_coe_set_eq, Set.ncard_def]\n      congr\n      rw [<-ENat.coe_toNat (n := Set.encard H) _]\n      . rfl\n      simp [H.toFinite]\n    simp\n\n/-- Variant of `discreteUniform_apply' using real-valued measures. -/\nlemma discreteUniform_apply' (A : Set S) :\n  (discreteUniform H).real A = (Nat.card (A ∩ H : Set S)) / Nat.card H := by\n  rw [measureReal_def, discreteUniform_apply, ENNReal.toReal_div]\n  congr\n\nvariable [Nonempty H]\n\ninstance discreteUniform.isProbabilityMeasure  : IsProbabilityMeasure (discreteUniform H) := by\n  rw [isProbabilityMeasure_iff, discreteUniform_apply, Set.univ_inter, ENNReal.div_self]\n  . simp [Nat.pos_iff_ne_zero.mp Nat.card_pos]\n  simp\n\n/--  injective map of discrete uniform is discrete uniform -/\nlemma map_discreteUniform_of_inj {T: Type*} [MeasurableSpace T] [MeasurableSingletonClass T] {f : S → T} (hmes : Measurable f) (hf : Function.Injective f) : (discreteUniform H).map f = discreteUniform (f '' H) := by\n  ext A hA\n  simp_rw [map_apply hmes hA, discreteUniform_apply, Nat.card_image_of_injective hf, Set.Nat.card_coe_set_eq, <-Set.ncard_image_of_injective (f⁻¹' A ∩ H) hf]\n  congr; ext t; simp\n  constructor\n  . rintro ⟨ s, ⟨ hs, hs' ⟩, hs'' ⟩\n    exact ⟨ hs'' ▸ hs, ⟨ s, hs', hs'' ⟩ ⟩\n  rintro ⟨ ht, s, ⟨ hs, hs'⟩ ⟩\n  exact ⟨ s, ⟨ hs' ▸ ht, hs ⟩, hs' ⟩\n\n/-- A random variable is uniform iff its distribution is. -/\nlemma isUniform_iff_uniform_dist {Ω : Type*} [mΩ : MeasurableSpace Ω] {μ: Measure Ω} [Countable S] (hμ: IsProbabilityMeasure μ) {U: Ω → S} (hU: Measurable U) :\n  ProbabilityTheory.IsUniform H U μ ↔ μ.map U = discreteUniform H := by\n  constructor\n  . intro h_unif\n    ext A hA\n    let Hf := H.toFinite.toFinset\n    have h_unif': ProbabilityTheory.IsUniform Hf U μ := (Set.Finite.coe_toFinset H.toFinite).symm ▸ h_unif\n    let AHf := (A ∩ H).toFinite.toFinset\n\n    rw [discreteUniform_apply, <-MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hA]\n    classical\n    calc ∑' x, Set.indicator A (fun x => (μ.map U) {x}) x\n      _ = ∑' x, (if x ∈ (A ∩ H) then (1:ENNReal) / (Nat.card H) else 0) := by\n        congr with x\n        by_cases h : x ∈ A\n        . by_cases h' : x ∈ H\n          . simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_mem h_unif' hU ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n          simp [h, h', map_apply hU (MeasurableSet.singleton x), ProbabilityTheory.IsUniform.measure_preimage_of_nmem h_unif' ((Set.Finite.coe_toFinset H.toFinite).symm ▸ h')]\n        simp [h]\n      _ = Finset.sum AHf (fun _ ↦ (1:ENNReal) / (Nat.card H)) := by\n        rw [tsum_eq_sum (s := (A ∩ H).toFinite.toFinset)]\n        . apply Finset.sum_congr (by rfl)\n          intro x hx\n          simp at hx\n          simp [hx]\n        intro x hx\n        simp at hx\n        simpa\n      _ = (Nat.card (A ∩ H:Set S)) / (Nat.card H) := by\n        simp [Finset.sum_const, <-Set.ncard_eq_toFinset_card (A ∩ H), Set.Nat.card_coe_set_eq]\n        rfl\n  intro this\n  constructor\n  . intro x y hx hy\n    replace hx : {x} ∩ H = {x} := by simp [hx]\n    replace hy : {y} ∩ H = {y} := by simp [hy]\n    simp [<-map_apply hU (MeasurableSet.singleton _), this, discreteUniform_apply, hx, hy]\n  rw [<-map_apply hU (by measurability), this, discreteUniform_apply]\n  simp\n\nopen Real ProbabilityTheory\n\n/-- The entropy of a uniform measure is the log of the cardinality of its support. -/\nlemma _root_.ProbabilityTheory.entropy_of_discreteUniform : measureEntropy (discreteUniform H) = log (Nat.card H) := by\n  simp [measureEntropy_def', discreteUniform_apply']\n  classical\n  calc ∑' s, negMulLog ((Nat.card ({s} ∩ H : Set S)) / (Nat.card H))\n    _ = ∑' s, if s ∈ H then negMulLog (1 / (Nat.card H)) else 0 := by\n      congr with s\n      by_cases h: s ∈ H\n      all_goals simp [h]\n    _ = ∑ s in H.toFinite.toFinset, negMulLog (1 / (Nat.card H)) := by\n      convert tsum_eq_sum (s := H.toFinite.toFinset) ?_ using 2 with s hs\n      . simp at hs; simp [hs]\n      intro s hs\n      simp at hs; simp [hs]\n    _ = (Nat.card H) * negMulLog (1 / (Nat.card H)) := by\n      simp [<-Set.ncard_coe_Finset, Set.Nat.card_coe_set_eq]\n    _ = log (Nat.card H) := by\n      simp [negMulLog, Nat.card_pos, <-mul_assoc]\n      rw [mul_inv_cancel, one_mul]\n      simp only [ne_eq, Nat.cast_eq_zero, Nat.card_ne_zero]\n      exact ⟨ ‹_›, ‹_› ⟩\n\nend MeasureTheory.Measure\n\nend UniformMeasure\n\nsection RuzsaSetDist\n\nnamespace ProbabilityTheory\n\nopen MeasureTheory Pointwise Real\n\nvariable {G:Type*} [Countable G]  [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G]\n\n/-- The Ruzsa distance between two subsets `A`, `B` of a group `G` is defined to be the Ruzsa distance between their uniform probability distributions.  Is only intended for use when `A`, `B` are finite and non-empty. -/\nnoncomputable def rdist_set (A B: Set G) : ℝ := kernel.rdistm (Measure.discreteUniform A) (Measure.discreteUniform B)\n\nnotation3:max \"dᵤ[\" A \" # \" B \"]\" => rdist_set A B\n\n/-- Relating Ruzsa distance between sets to Ruzsa distance between random variables -/\nlemma rdist_set_eq_rdist {A B: Set G} [Finite A] [Finite B]  [Nonempty A] [Nonempty B]\n    {Ω Ω': Type*} [mΩ : MeasureSpace Ω] [mΩ' : MeasureSpace Ω']\n    {μ : Measure Ω} {μ' : Measure Ω'}\n    (hμ: IsProbabilityMeasure μ) (hμ': IsProbabilityMeasure μ')\n    {UA: Ω → G} {UB: Ω' → G} (hUA : IsUniform A UA μ) (hUB : IsUniform B UB μ')\n    (hUA_mes : Measurable UA) (hUB_mes : Measurable UB) :\n    dᵤ[A # B] = d[UA ; μ # UB ; μ'] := by\n  rw [rdist_eq_rdistm, rdist_set, (Measure.isUniform_iff_uniform_dist A hμ hUA_mes).mp hUA,\n    (Measure.isUniform_iff_uniform_dist B hμ' hUB_mes).mp hUB]\n\n/-- Ruzsa distance between sets is nonnegative. -/\nlemma rdist_set_nonneg (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : 0 ≤ dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, UA_hfin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, UB_hfin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes]\n  exact rdist_nonneg hUA_mes hUB_mes\n\n/-- Ruzsa distance between sets is symmetric. -/\nlemma rdist_set_symm (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] : dᵤ[A # B] = dᵤ[B # A] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ hUB_unif hUA_unif hUB_mes hUA_mes]\n  exact rdist_symm\n\n/-- Ruzsa distance between sets obeys the triangle inequality. -/\nlemma rdist_set_triangle (A B C: Set G) [Finite A] [Finite B] [Finite C] [Nonempty A] [Nonempty B] [Nonempty C] : dᵤ[A # C] ≤ dᵤ[A # B] + dᵤ[B # C] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  obtain ⟨ Ω'', mΩ'', UC, hμ'', hUC_mes, hUC_unif, -, hUC_fin ⟩ := exists_isUniform_measureSpace' C\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, rdist_set_eq_rdist hμ' hμ'' hUB_unif hUC_unif hUB_mes hUC_mes, rdist_set_eq_rdist hμ hμ'' hUA_unif hUC_unif hUA_mes hUC_mes]\n  exact rdist_triangle hUA_mes hUB_mes hUC_mes\n\n/-- Ruzsa distance between sets is translation invariant. -/\nlemma rdist_set_add_const (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] (c c' : G) : dᵤ[A + {c} # B + {c'}] = dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, hUA_fin ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, hUB_fin ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, <- rdist_add_const' c c' hUA_mes hUB_mes]\n  classical\n  convert rdist_set_eq_rdist (A := A+{c}) (B := B+{c'}) hμ hμ' ?_ ?_ ?_ ?_\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . exact Set.Nonempty.to_subtype (Set.Nonempty.add (Set.nonempty_coe_sort.mp ‹_›) (Set.singleton_nonempty _))\n  . convert IsUniform.comp (A.toFinite.coe_toFinset.symm ▸ hUA_unif) (add_left_injective c) using 1\n    simp\n  . convert IsUniform.comp (B.toFinite.coe_toFinset.symm ▸ hUB_unif) (add_left_injective c') using 1\n    simp\n  . measurability\n  measurability\n\n/-- Ruzsa distance between sets is preserved by injective homomorphisms. -/\nlemma rdist_set_of_inj (A B: Set G) [Finite A] [Finite B]  [Nonempty A] [Nonempty B] {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n [Countable H] {φ: G →+ H} (hφ: Function.Injective φ) : dᵤ[φ '' A # φ '' B] = dᵤ[A # B] := by\n  obtain ⟨ Ω, mΩ, UA, hμ, hUA_mes, hUA_unif, -, - ⟩ := exists_isUniform_measureSpace' A\n  obtain ⟨ Ω', mΩ', UB, hμ', hUB_mes, hUB_unif, -, - ⟩ := exists_isUniform_measureSpace' B\n  rw [rdist_set_eq_rdist hμ hμ' hUA_unif hUB_unif hUA_mes hUB_mes, <-rdist_of_inj hUA_mes hUB_mes φ hφ]\n  classical\n  convert rdist_set_eq_rdist (A := φ '' A) (B := φ '' B) hμ hμ' ?_ ?_ ?_ ?_\n  . convert IsUniform.comp (A.toFinite.coe_toFinset.symm ▸ hUA_unif) hφ using 1\n    ext x; simp\n  . convert IsUniform.comp (B.toFinite.coe_toFinset.symm ▸ hUB_unif) hφ using 1\n    ext x; simp\n  . measurability\n  measurability\n\n","proof":":= by\n  have := hA.to_subtype\n  have := hB.to_subtype\n  simp_rw [rdist_set, kernel.rdistm, ProbabilityTheory.entropy_of_discreteUniform]\n  gcongr\n  convert measureEntropy_le_card_aux (A-B).toFinite.toFinset ?_\n  . rw [Set.Nat.card_coe_set_eq,]\n    exact Set.ncard_eq_toFinset_card (A - B)\n  . exact isProbabilityMeasure_map (Measurable.aemeasurable measurable_sub)\n  rw [Measure.map_apply measurable_sub (measurableSet_discrete _)]\n  apply MeasureTheory.measure_mono_null (s₂ := (Aᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ Bᶜ))\n  . intro (x, y)\n    contrapose!\n    aesop (add unsafe Set.sub_mem_sub, simp not_or)\n  apply MeasureTheory.measure_union_null\n  all_goals simp [Measure.discreteUniform_apply]","declId":"PFR.ForMathlib.Entropy.RuzsaSetDist.213_0.qmdhKZCJ7oG8kHE","decl":"/-- Ruzsa distance between sets is controlled by the doubling constant. -/\nlemma rdist_set_le (A B: Set G) [Finite A] [Finite B] (hA : A.Nonempty) (hB : B.Nonempty) :\n    dᵤ[A # B] ≤ log (Nat.card (A-B)) - log (Nat.card A) / 2 - log (Nat.card B) / 2 "}
