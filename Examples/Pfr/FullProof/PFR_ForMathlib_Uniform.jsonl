{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n","proof":":= by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0","declId":"PFR.ForMathlib.Uniform.16_0.qlYyUwRn6gSkYi1","decl":"/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n","proof":":= by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp","declId":"PFR.ForMathlib.Uniform.24_0.qlYyUwRn6gSkYi1","decl":"/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n","proof":":= by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl","declId":"PFR.ForMathlib.Uniform.57_0.qlYyUwRn6gSkYi1","decl":"/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n","proof":":= by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩","declId":"PFR.ForMathlib.Uniform.69_0.qlYyUwRn6gSkYi1","decl":"/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n","proof":":= by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩","declId":"PFR.ForMathlib.Uniform.77_0.qlYyUwRn6gSkYi1","decl":"/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n","proof":":= h.measure_preimage_compl","declId":"PFR.ForMathlib.Uniform.91_0.qlYyUwRn6gSkYi1","decl":"/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n","proof":":= by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'","declId":"PFR.ForMathlib.Uniform.94_0.qlYyUwRn6gSkYi1","decl":"/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n","proof":":= by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp","declId":"PFR.ForMathlib.Uniform.102_0.qlYyUwRn6gSkYi1","decl":"/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n","proof":":= by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]","declId":"PFR.ForMathlib.Uniform.131_0.qlYyUwRn6gSkYi1","decl":"/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\n","proof":":= by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]","declId":"PFR.ForMathlib.Uniform.138_0.qlYyUwRn6gSkYi1","decl":"lemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n","proof":":= by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs","declId":"PFR.ForMathlib.Uniform.144_0.qlYyUwRn6gSkYi1","decl":"/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n","proof":":= by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]","declId":"PFR.ForMathlib.Uniform.151_0.qlYyUwRn6gSkYi1","decl":"/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n","proof":":= calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]","declId":"PFR.ForMathlib.Uniform.156_0.qlYyUwRn6gSkYi1","decl":"/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n","proof":":= by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]","declId":"PFR.ForMathlib.Uniform.173_0.qlYyUwRn6gSkYi1","decl":"/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\n","proof":":= by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]","declId":"PFR.ForMathlib.Uniform.179_0.qlYyUwRn6gSkYi1","decl":"lemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\nlemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) := by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]\n\n","proof":":= by\n    rw [Measure.map_apply hX (by measurability)]\n    refine measure_eq_measure_of_null_diff (subset_univ _) ?h_nulldiff\n    convert h.measure_preimage_compl\n    ext ω; simp","declId":"PFR.ForMathlib.Uniform.185_0.qlYyUwRn6gSkYi1","decl":"lemma IsUniform.full_measure (h : IsUniform H X μ) (hX: Measurable X) :\n    (μ.map X) H = μ Set.univ "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\nlemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) := by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]\n\nlemma IsUniform.full_measure (h : IsUniform H X μ) (hX: Measurable X) :\n    (μ.map X) H = μ Set.univ := by\n    rw [Measure.map_apply hX (by measurability)]\n    refine measure_eq_measure_of_null_diff (subset_univ _) ?h_nulldiff\n    convert h.measure_preimage_compl\n    ext ω; simp\n\n","proof":":= by\n  constructor\n  · intro x y hx hy\n    rw [← h'.measure_mem_eq (MeasurableSet.singleton x),\n      ← h'.measure_mem_eq (MeasurableSet.singleton y)]\n    apply h.eq_of_mem x y hx hy\n  · rw [← h'.measure_mem_eq hH.compl]\n    exact h.measure_preimage_compl","declId":"PFR.ForMathlib.Uniform.192_0.qlYyUwRn6gSkYi1","decl":"/-- A copy of a uniform random variable is also uniform.-/\nlemma IsUniform.of_identDistrib {Ω' : Type*} [MeasurableSpace Ω'] (h : IsUniform H X μ)\n    {X' : Ω' → S} {μ' : Measure Ω'} (h' : IdentDistrib X X' μ μ') (hH : MeasurableSet (H : Set S)) :\n    IsUniform H X' μ' "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\nlemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) := by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]\n\nlemma IsUniform.full_measure (h : IsUniform H X μ) (hX: Measurable X) :\n    (μ.map X) H = μ Set.univ := by\n    rw [Measure.map_apply hX (by measurability)]\n    refine measure_eq_measure_of_null_diff (subset_univ _) ?h_nulldiff\n    convert h.measure_preimage_compl\n    ext ω; simp\n\n/-- A copy of a uniform random variable is also uniform.-/\nlemma IsUniform.of_identDistrib {Ω' : Type*} [MeasurableSpace Ω'] (h : IsUniform H X μ)\n    {X' : Ω' → S} {μ' : Measure Ω'} (h' : IdentDistrib X X' μ μ') (hH : MeasurableSet (H : Set S)) :\n    IsUniform H X' μ' := by\n  constructor\n  · intro x y hx hy\n    rw [← h'.measure_mem_eq (MeasurableSet.singleton x),\n      ← h'.measure_mem_eq (MeasurableSet.singleton y)]\n    apply h.eq_of_mem x y hx hy\n  · rw [← h'.measure_mem_eq hH.compl]\n    exact h.measure_preimage_compl\n\n","proof":":= by\n  simp_rw [h.measure_preimage hX H', ne_eq, ENNReal.div_eq_zero_iff, ENNReal.nat_ne_top, or_false,\n    mul_eq_zero, NeZero.ne, false_or, Nat.cast_eq_zero, ← Nat.pos_iff_ne_zero, Nat.card_pos]","declId":"PFR.ForMathlib.Uniform.204_0.qlYyUwRn6gSkYi1","decl":"/-- $\\mathbb{P}(U_H \\in H') \\neq 0$ if $H'$ intersects $H$ and the measure is non-zero. -/\nlemma IsUniform.measure_preimage_ne_zero {H : Finset S} [NeZero μ] (h : IsUniform H X μ)\n    (hX : Measurable X) (H' : Set S) [Nonempty (H' ∩ H.toSet).Elem] : μ (X ⁻¹' H') ≠ 0 "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\nlemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) := by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]\n\nlemma IsUniform.full_measure (h : IsUniform H X μ) (hX: Measurable X) :\n    (μ.map X) H = μ Set.univ := by\n    rw [Measure.map_apply hX (by measurability)]\n    refine measure_eq_measure_of_null_diff (subset_univ _) ?h_nulldiff\n    convert h.measure_preimage_compl\n    ext ω; simp\n\n/-- A copy of a uniform random variable is also uniform.-/\nlemma IsUniform.of_identDistrib {Ω' : Type*} [MeasurableSpace Ω'] (h : IsUniform H X μ)\n    {X' : Ω' → S} {μ' : Measure Ω'} (h' : IdentDistrib X X' μ μ') (hH : MeasurableSet (H : Set S)) :\n    IsUniform H X' μ' := by\n  constructor\n  · intro x y hx hy\n    rw [← h'.measure_mem_eq (MeasurableSet.singleton x),\n      ← h'.measure_mem_eq (MeasurableSet.singleton y)]\n    apply h.eq_of_mem x y hx hy\n  · rw [← h'.measure_mem_eq hH.compl]\n    exact h.measure_preimage_compl\n\n/-- $\\mathbb{P}(U_H \\in H') \\neq 0$ if $H'$ intersects $H$ and the measure is non-zero. -/\nlemma IsUniform.measure_preimage_ne_zero {H : Finset S} [NeZero μ] (h : IsUniform H X μ)\n    (hX : Measurable X) (H' : Set S) [Nonempty (H' ∩ H.toSet).Elem] : μ (X ⁻¹' H') ≠ 0 := by\n  simp_rw [h.measure_preimage hX H', ne_eq, ENNReal.div_eq_zero_iff, ENNReal.nat_ne_top, or_false,\n    mul_eq_zero, NeZero.ne, false_or, Nat.cast_eq_zero, ← Nat.pos_iff_ne_zero, Nat.card_pos]\n\n","proof":":= fun x y hx hy ↦ by\n    show _ * _ = _ * _\n    rw [μ.restrict_eq_self (preimage_mono (singleton_subset_iff.mpr hx.1)),\n      μ.restrict_eq_self (preimage_mono (singleton_subset_iff.mpr hy.1)), h.eq_of_mem x y hx.2 hy.2]\n  measure_preimage_compl := le_zero_iff.mp <| by\n    rewrite [Set.compl_inter, Set.preimage_union]\n    calc\n      _ ≤ (μ[|X ⁻¹' H']) (X ⁻¹' H'ᶜ) + (μ[|X ⁻¹' H']) (X ⁻¹' Hᶜ) := measure_union_le _ _\n      _ = (μ[|X ⁻¹' H']) (X ⁻¹' H'ᶜ) + 0 := congrArg _ <| by\n        show _ * _ = _\n        rw [le_zero_iff.mp <| h.measure_preimage_compl.trans_ge <| Measure.restrict_apply_le _ _,\n          mul_zero]\n      _ = 0 := by\n        show _ * _ + 0 = 0\n        rw [add_zero, Set.preimage_compl, Measure.restrict_apply <|\n          MeasurableSet.compl (measurableSet_preimage hX (measurableSet_discrete H')),\n          compl_inter_self, measure_empty, mul_zero]","declId":"PFR.ForMathlib.Uniform.210_0.qlYyUwRn6gSkYi1","decl":"/-- If $X$ is uniform w.r.t. $\\mu$ on $H$, then $X$ is uniform w.r.t. $\\mu$ conditioned by\n$H'$ on $H' \\cap H$. -/\nlemma IsUniform.restrict {H : Set S} (h : IsUniform H X μ) (hX : Measurable X) (H' : Set S) :\n    IsUniform (H' ∩ H) X (μ[|X ⁻¹' H']) where\n  eq_of_mem "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport Mathlib.Probability.ConditionalProbability\nimport PFR.ForMathlib.MeasureReal\nimport PFR.ForMathlib.FiniteRange\n\nopen Function MeasureTheory Set\nopen scoped BigOperators ENNReal\n\nnamespace ProbabilityTheory\nuniverse uΩ uS uT uU\nvariable {Ω : Type uΩ} {S : Type uS} {T : Type uT} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Countable T] [Nonempty T] [MeasurableSpace S] [MeasurableSpace T]\n  [MeasurableSingletonClass S] [MeasurableSingletonClass T] {X : Ω → S} {Y : Ω → T} {μ : Measure Ω}\n  {H : Set S}\n\n/-- The assertion that the law of $X$ is the uniform probability measure on a finite set $H$.\nWhile in applications $H$ will be non-empty finite set, $X$ measurable, and and $μ$ a probability\nmeasure, it could be technically convenient to have a definition that works even without these\nhypotheses.  (For instance, `isUniform` would be well-defined, but false, for infinite `H`) -/\nstructure IsUniform (H : Set S) (X : Ω → S) (μ : Measure Ω := by volume_tac) : Prop :=\n  eq_of_mem : ∀ x y, x ∈ H → y ∈ H → μ (X ⁻¹' {x}) = μ (X ⁻¹' {y})\n  measure_preimage_compl : μ (X ⁻¹' Hᶜ) = 0\n\n/-- Uniform distributions exist. -/\nlemma exists_isUniform (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type uS) (mΩ : MeasurableSpace Ω) (X : Ω → S) (μ : Measure Ω),\n    IsProbabilityMeasure μ ∧ Measurable X ∧ IsUniform H X μ ∧ (∀ ω : Ω, X ω ∈ H) ∧ FiniteRange X := by\n  refine ⟨H, Subtype.instMeasurableSpace, (fun x ↦ x),\n      (Finset.card H : ℝ≥0∞)⁻¹ • ∑ i, Measure.dirac i, ?_, measurable_subtype_coe, ?_, fun x ↦ x.2, ?_⟩\n  · constructor\n    simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n      Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, MeasurableSet.univ,\n      Measure.dirac_apply', mem_univ, indicator_of_mem, Pi.one_apply, Finset.sum_const,\n      Finset.card_attach, nsmul_eq_mul, mul_one, smul_eq_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simpa using h.ne_empty\n    · simp\n  · constructor\n    · intro x y hx hy\n      simp only [Finset.univ_eq_attach, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul,\n        Measure.coe_finset_sum, Pi.smul_apply, Finset.sum_apply, mem_preimage, mem_singleton_iff,\n        Measure.dirac_apply, smul_eq_mul]\n      rw [Finset.sum_eq_single ⟨x, hx⟩, Finset.sum_eq_single ⟨y, hy⟩]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n      · rintro ⟨b, bH⟩ _hb h'b\n        simp only [ne_eq, Subtype.mk.injEq] at h'b\n        simp [h'b]\n      · simp\n    · simp\n  apply finiteRange_of_finset _ H _\n  simp\n\n/-- The image of a uniform random variable under an injective map is uniform on the image. -/\nlemma IsUniform.comp [DecidableEq T] {H: Finset S} (h : IsUniform H X μ) {f : S → T} (hf : Injective f) :\n    IsUniform (Finset.image f H) (f ∘ X) μ where\n  eq_of_mem := by\n    intro x y hx hy\n    simp at hx hy\n    rcases hx with ⟨x, hx, rfl⟩\n    rcases hy with ⟨y, hy, rfl⟩\n    have A z : f ⁻¹' {f z} = {z} := by ext; simp [hf.eq_iff]\n    simp [preimage_comp, A, h.eq_of_mem x y hx hy]\n  measure_preimage_compl := by simpa [preimage_comp, hf] using h.measure_preimage_compl\n\n/-- Uniform distributions exist, version giving a measure space -/\nlemma exists_isUniform_measureSpace {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Finset S) (h : H.Nonempty) :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω : Ω, U ω ∈ H) ∧ FiniteRange U := by\n  rcases exists_isUniform H h with ⟨Ω, mΩ, X, μ, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n  exact ⟨Ω, ⟨μ⟩, X, hμ, Xmeas, Xunif, Xmem, Xfin⟩\n\n/-- Uniform distributions exist, version with a Finite set rather than a Finset and giving a measure space -/\nlemma exists_isUniform_measureSpace' {S : Type u}  [MeasurableSpace S]\n    [MeasurableSingletonClass S] (H : Set S) [Finite H] [Nonempty H] :\n    ∃ (Ω : Type u) (mΩ : MeasureSpace Ω) (U : Ω → S),\n    IsProbabilityMeasure (ℙ : Measure Ω) ∧ Measurable U ∧ IsUniform H U ∧ (∀ ω, U ω ∈ H) ∧ FiniteRange U := by\n  set Hf := H.toFinite.toFinset\n  have hHf : Hf.Nonempty := by\n    rwa [<-Hf.coe_nonempty, H.toFinite.coe_toFinset, <-H.nonempty_coe_sort]\n  obtain ⟨ Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin ⟩ := exists_isUniform_measureSpace Hf hHf\n  rw [ H.toFinite.coe_toFinset] at hunif\n  replace hrange : ∀ ω, U ω ∈ H := by convert hrange with ω; simp_rw [Finite.mem_toFinset]\n  exact ⟨Ω, mΩ, U, hμ, hmes, hunif, hrange, hfin⟩\n\n\n/-- A uniform random variable on H almost surely takes values in H. -/\nlemma IsUniform.ae_mem (h : IsUniform H X μ) : ∀ᵐ ω ∂μ, X ω ∈ H := h.measure_preimage_compl\n\n/-- Uniform random variables only exist for non-empty sets H. -/\nlemma IsUniform.nonempty {H: Finset S} (h : IsUniform H X μ) [hμ : NeZero μ] : H.Nonempty := by\n  rcases Finset.eq_empty_or_nonempty H with rfl|h'\n  · have : μ univ = 0 := by convert h.measure_preimage_compl; simp\n    simp at this\n    exact (hμ.out this).elim\n  · exact h'\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_mem {H: Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    {s : S} (hs : s ∈ H) :\n    μ (X ⁻¹' {s}) = μ univ / Nat.card H := by\n  have B : μ univ = (Nat.card H) * μ (X ⁻¹' {s}) := calc\n    μ univ = μ (X ⁻¹' Hᶜ) + μ (X ⁻¹' H) := by\n      rw [← measure_union (disjoint_compl_left.preimage _) (hX (measurableSet_discrete _))]\n      simp\n    _ = μ (X ⁻¹' H) := by rw [h.measure_preimage_compl, zero_add]\n    _ = ∑ x in H, μ (X ⁻¹' {x}) := by\n      have : X ⁻¹' H = ⋃ x ∈ H, X ⁻¹' ({x} : Set S) := by simp\n      rw [this, measure_biUnion_finset]\n      · intro y _hy z _hz hyz\n        apply Disjoint.preimage\n        simp [hyz]\n      · intro y _hy\n        exact hX (measurableSet_discrete _)\n    _ = ∑ _x in H, μ (X ⁻¹' {s}) :=\n      Finset.sum_congr rfl (fun x hx ↦ h.eq_of_mem x s (by simpa using hx) hs)\n    _ = H.card * μ (X ⁻¹' {s}) := by simp\n    _ = (Nat.card H) * μ (X ⁻¹' {s}) := by\n      congr; simp\n  rcases Nat.eq_zero_or_pos (Nat.card H) with hH|hH\n  · simp only [hH, CharP.cast_eq_zero, zero_mul, Measure.measure_univ_eq_zero] at B\n    simp [B]\n  · rwa [eq_comm, ← ENNReal.eq_div_iff] at B\n    · simpa using Nat.pos_iff_ne_zero.mp hH\n    · simp\n\n/-- A \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_mem {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    μ.real (X ⁻¹' {s}) = 1 / Nat.card H := by\n  rw [measureReal_def, h.measure_preimage_of_mem hX hs]\n  simp [ENNReal.toReal_inv]\n\nlemma IsUniform.measureReal_preimage_of_mem' {H: Finset S} [IsProbabilityMeasure μ]\n    (h : IsUniform H X μ) (hX : Measurable X) {s : S} (hs : s ∈ H) :\n    (μ.map X).real {s} = 1 / Nat.card H := by\n  rw [map_measureReal_apply hX (MeasurableSet.singleton s),\n    IsUniform.measureReal_preimage_of_mem h hX hs]\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measure_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ (X ⁻¹' {s}) = 0 := by\n  apply le_antisymm ((measure_mono _).trans h.measure_preimage_compl.le) (zero_le _)\n  apply preimage_mono\n  simpa using hs\n\n/-- Another \"unit test\" for the definition of uniform distribution. -/\nlemma IsUniform.measureReal_preimage_of_nmem (h : IsUniform H X μ) {s : S} (hs : s ∉ H) :\n    μ.real (X ⁻¹' {s}) = 0 := by\n  rw [measureReal_def, h.measure_preimage_of_nmem hs, ENNReal.zero_toReal]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measure_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) : μ (X ⁻¹' H') = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := calc\n  _ = μ (X ⁻¹' (H' ∩ H.toSet) ∪ X ⁻¹' (H' \\ H.toSet)) := by simp\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + μ (X ⁻¹' (H' \\ H.toSet)) :=\n    measure_union (Disjoint.preimage X disjoint_inf_sdiff) (by measurability)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet)) + 0 := congrArg _ <| by\n    rewrite [Set.diff_eq_compl_inter, ← le_zero_iff, ← h.measure_preimage_compl]\n    exact measure_mono (inter_subset_left _ _)\n  _ = μ (X ⁻¹' (H' ∩ H.toSet).toFinite.toFinset) := by simp\n  _ = (μ univ) * ∑ __ in (H' ∩ H.toSet).toFinite.toFinset, (1 : ENNReal) / Nat.card H := by\n    rewrite [← sum_measure_preimage_singleton _ (by measurability), Finset.mul_sum]\n    refine Finset.sum_congr rfl (fun _ hx ↦ ?_)\n    rw [mul_one_div, h.measure_preimage_of_mem hX ((Finite.mem_toFinset _).mp hx).2]\n  _ = (μ univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n    rw [Finset.sum_const, Nat.card_eq_card_finite_toFinset, nsmul_eq_mul, ← mul_assoc, mul_one_div]\n\n/-- $\\mathbb{P}(U_H \\in H') = \\dfrac{|H' \\cap H|}{|H|}$ -/\nlemma IsUniform.measureReal_preimage {H : Finset S} (h : IsUniform H X μ) (hX : Measurable X)\n    (H' : Set S) :\n    μ.real (X ⁻¹' H') = (μ.real univ) * (Nat.card (H' ∩ H.toSet).Elem) / Nat.card H := by\n  simp [measureReal_def, h.measure_preimage hX H', ENNReal.toReal_div]\n\nlemma IsUniform.nonempty_preimage_of_mem [NeZero μ] {H: Finset S} (h : IsUniform H X μ)\n    (hX : Measurable X) {s : S} (hs : s ∈ H) : Set.Nonempty (X ⁻¹' {s}) := by\n  apply MeasureTheory.nonempty_of_measure_ne_zero\n  rewrite [h.measure_preimage_of_mem hX hs]\n  simp [NeZero.ne]\n\nlemma IsUniform.full_measure (h : IsUniform H X μ) (hX: Measurable X) :\n    (μ.map X) H = μ Set.univ := by\n    rw [Measure.map_apply hX (by measurability)]\n    refine measure_eq_measure_of_null_diff (subset_univ _) ?h_nulldiff\n    convert h.measure_preimage_compl\n    ext ω; simp\n\n/-- A copy of a uniform random variable is also uniform.-/\nlemma IsUniform.of_identDistrib {Ω' : Type*} [MeasurableSpace Ω'] (h : IsUniform H X μ)\n    {X' : Ω' → S} {μ' : Measure Ω'} (h' : IdentDistrib X X' μ μ') (hH : MeasurableSet (H : Set S)) :\n    IsUniform H X' μ' := by\n  constructor\n  · intro x y hx hy\n    rw [← h'.measure_mem_eq (MeasurableSet.singleton x),\n      ← h'.measure_mem_eq (MeasurableSet.singleton y)]\n    apply h.eq_of_mem x y hx hy\n  · rw [← h'.measure_mem_eq hH.compl]\n    exact h.measure_preimage_compl\n\n/-- $\\mathbb{P}(U_H \\in H') \\neq 0$ if $H'$ intersects $H$ and the measure is non-zero. -/\nlemma IsUniform.measure_preimage_ne_zero {H : Finset S} [NeZero μ] (h : IsUniform H X μ)\n    (hX : Measurable X) (H' : Set S) [Nonempty (H' ∩ H.toSet).Elem] : μ (X ⁻¹' H') ≠ 0 := by\n  simp_rw [h.measure_preimage hX H', ne_eq, ENNReal.div_eq_zero_iff, ENNReal.nat_ne_top, or_false,\n    mul_eq_zero, NeZero.ne, false_or, Nat.cast_eq_zero, ← Nat.pos_iff_ne_zero, Nat.card_pos]\n\n/-- If $X$ is uniform w.r.t. $\\mu$ on $H$, then $X$ is uniform w.r.t. $\\mu$ conditioned by\n$H'$ on $H' \\cap H$. -/\nlemma IsUniform.restrict {H : Set S} (h : IsUniform H X μ) (hX : Measurable X) (H' : Set S) :\n    IsUniform (H' ∩ H) X (μ[|X ⁻¹' H']) where\n  eq_of_mem := fun x y hx hy ↦ by\n    show _ * _ = _ * _\n    rw [μ.restrict_eq_self (preimage_mono (singleton_subset_iff.mpr hx.1)),\n      μ.restrict_eq_self (preimage_mono (singleton_subset_iff.mpr hy.1)), h.eq_of_mem x y hx.2 hy.2]\n  measure_preimage_compl := le_zero_iff.mp <| by\n    rewrite [Set.compl_inter, Set.preimage_union]\n    calc\n      _ ≤ (μ[|X ⁻¹' H']) (X ⁻¹' H'ᶜ) + (μ[|X ⁻¹' H']) (X ⁻¹' Hᶜ) := measure_union_le _ _\n      _ = (μ[|X ⁻¹' H']) (X ⁻¹' H'ᶜ) + 0 := congrArg _ <| by\n        show _ * _ = _\n        rw [le_zero_iff.mp <| h.measure_preimage_compl.trans_ge <| Measure.restrict_apply_le _ _,\n          mul_zero]\n      _ = 0 := by\n        show _ * _ + 0 = 0\n        rw [add_zero, Set.preimage_compl, Measure.restrict_apply <|\n          MeasurableSet.compl (measurableSet_preimage hX (measurableSet_discrete H')),\n          compl_inter_self, measure_empty, mul_zero]\n\n","proof":":= by\n  constructor\n  . exact Measurable.aemeasurable hX\n  . exact Measurable.aemeasurable hX'\n  ext E hE\n  rw [← MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hE, ← MeasureTheory.Measure.tsum_indicator_apply_singleton _ _ hE]\n  congr! 4 with _ x\n  rw [Measure.map_apply hX (MeasurableSet.singleton x), Measure.map_apply hX' (MeasurableSet.singleton x)]\n  set Hf := H.toFinite.toFinset\n  have hX_unif' : IsUniform Hf X μ := by convert hX_unif; simp\n  have hX'_unif' : IsUniform Hf X' μ' := by convert hX'_unif; simp\n\n  by_cases h : x ∈ Hf\n  . rw [IsUniform.measure_preimage_of_mem hX_unif' hX h,IsUniform.measure_preimage_of_mem hX'_unif' hX' h]\n    simp\n  rw [IsUniform.measure_preimage_of_nmem hX_unif' h,IsUniform.measure_preimage_of_nmem hX'_unif' h]","declId":"PFR.ForMathlib.Uniform.232_0.qlYyUwRn6gSkYi1","decl":"lemma IdentDistrib.of_isUniform {Ω' : Type*}  [MeasurableSpace Ω'] {μ' : Measure Ω'} [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Finite H] {X: Ω → S} {X': Ω' → S} (hX: Measurable X) (hX': Measurable X') (hX_unif : IsUniform H X μ) (hX'_unif : IsUniform H X' μ') : IdentDistrib X X' μ μ' "}
