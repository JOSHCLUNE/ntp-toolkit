{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n","proof":":= TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr","declId":"PFR.Tactic.RPowSimp.22_0.JQv8zIegBpv0leR","decl":"/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n","proof":":= ReaderT Context AtomM","declId":"PFR.Tactic.RPowSimp.33_0.JQv8zIegBpv0leR","decl":"/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\n","proof":":= ⟨_, .atom 0 default⟩","declId":"PFR.Tactic.RPowSimp.67_0.JQv8zIegBpv0leR","decl":"instance : Inhabited (Σ e, ExBase e) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\n","proof":":= ⟨_, .one⟩","declId":"PFR.Tactic.RPowSimp.68_0.JQv8zIegBpv0leR","decl":"instance : Inhabited (Σ e, ExProd e) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n","proof":":= .mul va .one","declId":"PFR.Tactic.RPowSimp.70_0.JQv8zIegBpv0leR","decl":"/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\n","proof":":= Ring.Result (u := .zero) (α := q(ℝ))","declId":"PFR.Tactic.RPowSimp.73_0.JQv8zIegBpv0leR","decl":"nonrec abbrev Result "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\n","proof":":= by simp","declId":"PFR.Tactic.RPowSimp.75_0.JQv8zIegBpv0leR","decl":"theorem atom_pf (a : ℝ) : a = a * 1 "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\n","proof":":= by simp [*]","declId":"PFR.Tactic.RPowSimp.76_0.JQv8zIegBpv0leR","decl":"theorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\n","proof":":= by simp","declId":"PFR.Tactic.RPowSimp.77_0.JQv8zIegBpv0leR","decl":"theorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\n","proof":":= by simp [*]","declId":"PFR.Tactic.RPowSimp.78_0.JQv8zIegBpv0leR","decl":"theorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n","proof":":= do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩","declId":"PFR.Tactic.RPowSimp.80_0.JQv8zIegBpv0leR","decl":"/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\n","proof":":= by\n  subst_vars; rw [mul_assoc]","declId":"PFR.Tactic.RPowSimp.97_0.JQv8zIegBpv0leR","decl":"theorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\n","proof":":= by\n  subst_vars; rw [mul_left_comm]","declId":"PFR.Tactic.RPowSimp.100_0.JQv8zIegBpv0leR","decl":"theorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\n","proof":":= by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]","declId":"PFR.Tactic.RPowSimp.103_0.JQv8zIegBpv0leR","decl":"theorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n","proof":":=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩","declId":"PFR.Tactic.RPowSimp.107_0.JQv8zIegBpv0leR","decl":"/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\n","proof":":=\n  mul_pos (rpow_pos_of_pos ha e) hb","declId":"PFR.Tactic.RPowSimp.135_0.JQv8zIegBpv0leR","decl":"theorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\n","proof":":= by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]","declId":"PFR.Tactic.RPowSimp.138_0.JQv8zIegBpv0leR","decl":"theorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\n","proof":":=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩","declId":"PFR.Tactic.RPowSimp.142_0.JQv8zIegBpv0leR","decl":"def evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\n","proof":":= by subst_vars; rfl","declId":"PFR.Tactic.RPowSimp.152_0.JQv8zIegBpv0leR","decl":"theorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\n","proof":":= by\n  subst_vars; simp [rpow_neg_one]","declId":"PFR.Tactic.RPowSimp.154_0.JQv8zIegBpv0leR","decl":"theorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\n","proof":":= by\n  subst_vars; simp [rpow_nat_cast]","declId":"PFR.Tactic.RPowSimp.157_0.JQv8zIegBpv0leR","decl":"theorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\n","proof":":= Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els","declId":"PFR.Tactic.RPowSimp.160_0.JQv8zIegBpv0leR","decl":"partial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\n","proof":":= true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })","declId":"PFR.Tactic.RPowSimp.189_0.JQv8zIegBpv0leR","decl":"def rewrite (parent : Expr) (root "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n","proof":":= do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s","declId":"PFR.Tactic.RPowSimp.206_0.JQv8zIegBpv0leR","decl":"/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\n","proof":":= do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s","declId":"PFR.Tactic.RPowSimp.205_0.JQv8zIegBpv0leR","decl":"open RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n","proof":":= withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]","declId":"PFR.Tactic.RPowSimp.228_0.JQv8zIegBpv0leR","decl":"/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n","proof":":= withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]","declId":"PFR.Tactic.RPowSimp.239_0.JQv8zIegBpv0leR","decl":"/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n","proof":":= cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"","declId":"PFR.Tactic.RPowSimp.249_0.JQv8zIegBpv0leR","decl":"/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n","proof":":= rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv","declId":"PFR.Tactic.RPowSimp.270_0.JQv8zIegBpv0leR","decl":"@[inherit_doc rpowRing] syntax (name "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n","proof":":= fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax","declId":"PFR.Tactic.RPowSimp.272_0.JQv8zIegBpv0leR","decl":"/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\n","proof":":= by\n  simp [← rpow_neg_one, ← rpow_mul h]","declId":"PFR.Tactic.RPowSimp.281_0.JQv8zIegBpv0leR","decl":"theorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\n","proof":":= by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]","declId":"PFR.Tactic.RPowSimp.284_0.JQv8zIegBpv0leR","decl":"theorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\n","proof":":= by\n  simp [← inv_rpow' hx, inv_rpow hx]","declId":"PFR.Tactic.RPowSimp.287_0.JQv8zIegBpv0leR","decl":"theorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\n","proof":":= Int.cast_eq_one.mpr rfl","declId":"PFR.Tactic.RPowSimp.290_0.JQv8zIegBpv0leR","decl":"lemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\n","proof":":= rfl","declId":"PFR.Tactic.RPowSimp.292_0.JQv8zIegBpv0leR","decl":"lemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\nlemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n := rfl\n\n","proof":":= by rfl","declId":"PFR.Tactic.RPowSimp.294_0.JQv8zIegBpv0leR","decl":"lemma fix_cast₃ {n : ℕ} [n.AtLeastTwo] : (Nat.cast n : ℝ) = OfNat.ofNat n "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\nlemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n := rfl\n\nlemma fix_cast₃ {n : ℕ} [n.AtLeastTwo] : (Nat.cast n : ℝ) = OfNat.ofNat n := by rfl\n\nopen Lean Lean.PrettyPrinter.Delaborator in\n","proof":":= whenPPOption Lean.getPPNotation do\n  SubExpr.withNaryArg 1 delab","declId":"PFR.Tactic.RPowSimp.297_0.JQv8zIegBpv0leR","decl":"@[delab app.OfNat.ofNat] def delab_ofNat "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\nlemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n := rfl\n\nlemma fix_cast₃ {n : ℕ} [n.AtLeastTwo] : (Nat.cast n : ℝ) = OfNat.ofNat n := by rfl\n\n","proof":":= whenPPOption Lean.getPPNotation do\n  SubExpr.withNaryArg 1 delab","declId":"PFR.Tactic.RPowSimp.296_0.JQv8zIegBpv0leR","decl":"open Lean Lean.PrettyPrinter.Delaborator in\n@[delab app.OfNat.ofNat] def delab_ofNat "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\nlemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n := rfl\n\nlemma fix_cast₃ {n : ℕ} [n.AtLeastTwo] : (Nat.cast n : ℝ) = OfNat.ofNat n := by rfl\n\nopen Lean Lean.PrettyPrinter.Delaborator in\n@[delab app.OfNat.ofNat] def delab_ofNat := whenPPOption Lean.getPPNotation do\n  SubExpr.withNaryArg 1 delab\n\nopen Lean Parser Tactic\n","proof":":= {failIfUnchanged := false}) (discharger := positivity) only\n      [abs_one, abs_mul, abs_inv, abs_div, abs_abs, abs_zero, mul_rpow, ← rpow_mul, div_rpow,\n       ← rpow_nat_cast, abs_rpow_of_nonneg, rpow_one, ← rpow_add, ← rpow_sub, zero_rpow, one_rpow,\n       rpow_one, inv_rpow', rpow_inv] $(loc)? <;> try push_cast) <;>\n   try rpow_ring) <;> try field_simp only $(extras)? $(loc)?) <;> try ring_nf (config:={}) $(loc)?) <;>\n   try simp (discharger := positivity) only [abs_one, abs_zero, one_rpow, rpow_one, rpow_zero, mul_zero, zero_mul, mul_one, one_mul,\n       fix_cast₁, fix_cast₂, fix_cast₃, Nat.cast_one, inv_rpow', rpow_inv] $(loc)?)","declId":"PFR.Tactic.RPowSimp.301_0.JQv8zIegBpv0leR","decl":"macro \"rpow_simp\" extras:(simpArgs)? loc:(location)? : tactic => `(tactic|\n  ((((simp (config "}
{"srcUpToDecl":"import Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.Tactic.Rify\n\nnamespace Mathlib.Tactic\nopen Lean hiding Rat\nopen Qq Meta Real\n\n/- In this file the power notation will always mean the base and exponent are real numbers. -/\nlocal macro_rules | `($x ^ $y) => `(HPow.hPow ($x : ℝ) ($y : ℝ))\n\nnamespace RPowRing\n-- open Ring\n\n/-- The read-only state of the `RPowRing` monad. -/\nstructure Context where\n  /-- A basically empty simp context, passed to the `simp` traversal in `RPowRing.rewrite`. -/\n  ctx : Simp.Context\n  /-- A cleanup routine, which simplifies normalized polynomials to a more human-friendly\n  format. -/\n  simp : Simp.Result → SimpM Simp.Result\n\n/-- Configuration for `ring_nf`. -/\nstructure Config where\n  /-- the reducibility setting to use when comparing atoms for defeq -/\n  red := TransparencyMode.reducible\n  -- /-- if true, atoms inside ring expressions will be reduced recursively -/\n  -- recursive := true\n  deriving Inhabited, BEq, Repr\n\n/-- Function elaborating `RingNF.Config`. -/\ndeclare_config_elab elabConfig Config\n\n/-- The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. -/\nabbrev M := ReaderT Context AtomM\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExBase : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | atom (id : ℕ) (x : Q(ℝ)) : ExBase x\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExBase` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | pow (id : ℕ) (x : Q(ℝ)) (h : Q(0 < $x)) (e : Q(ℝ)) : ExBase q($x ^ $e)\n\ndef ExBase.id : ExBase e → ℕ\n  | .atom id .. | .pow id .. => id\n\n/--\nA monomial, which is a product of powers of `ExBase` expressions,\nterminated by a (nonzero) constant coefficient.\n-/\ninductive ExProd : (e : Q(ℝ)) → Type\n  /-- A coefficient `value`, which must not be `0`. `e` is a raw rat cast.\n  If `value` is not an integer, then `hyp` should be a proof of `(value.den : α) ≠ 0`. -/\n  | one : ExProd q(1)\n  /-- A product `x ^ e * b` is a monomial if `b` is a monomial. Here `x` is an `ExBase`\n  and `e` is an `ExProd` representing a monomial expression in `ℕ` (it is a monomial instead of\n  a polynomial because we eagerly normalize `x ^ (a + b) = x ^ a * x ^ b`.) -/\n  | mul {x b : Q(ℝ)} : ExBase x → ExProd b → ExProd q($x * $b)\n\ninstance : Inhabited (Σ e, ExBase e) := ⟨_, .atom 0 default⟩\ninstance : Inhabited (Σ e, ExProd e) := ⟨_, .one⟩\n\n/-- Embed an exponent (an `ExBase, ExProd` pair) as an `ExProd` by multiplying by 1. -/\ndef ExBase.toProd (va : ExBase a) : ExProd q($a * 1) := .mul va .one\n\nnonrec abbrev Result := Ring.Result (u := .zero) (α := q(ℝ))\n\ntheorem atom_pf (a : ℝ) : a = a * 1 := by simp\ntheorem atom_pf' (p : (a : ℝ) = a') : a = a * 1 := by simp [*]\ntheorem atom_pow_pf (a : ℝ) : a = a ^ 1 * 1 := by simp\ntheorem atom_pow_pf' (p : (a : ℝ) = a') : a = a ^ 1 * 1 := by simp [*]\n\n/--\nEvaluates an atom, an expression where `ring` can find no additional structure.\n\n* `a = a ^ 1 * 1 + 0`\n-/\ndef evalAtom (e : Q(ℝ)) : AtomM (Result ExProd e) := do\n  let r ← (← read).evalAtom e\n  have a : Q(ℝ) := r.expr\n  let i ← AtomM.addAtom a\n  match ← Positivity.catchNone <| Positivity.core q(inferInstance) q(inferInstance) a, r.proof? with\n  | .positive pa, none =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf $e) : Expr)⟩\n  | .positive pa, some (p : Q($e = $a)) =>\n    pure ⟨_, (ExBase.pow i a pa q(1)).toProd, (q(atom_pow_pf' $p) : Expr)⟩\n  | _, none => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf $e) : Expr)⟩\n  | _, some (p : Q($e = $a)) => pure ⟨_, (ExBase.atom i a).toProd, (q(atom_pf' $p) : Expr)⟩\n\ntheorem mul_pf_left (a₁ : ℝ) (_ : a₂ * b = c) : (a₁ * a₂ : ℝ) * b = a₁ * c := by\n  subst_vars; rw [mul_assoc]\n\ntheorem mul_pf_right (b₁ : ℝ) (_ : a * b₂ = c) : a * (b₁ * b₂) = b₁ * c := by\n  subst_vars; rw [mul_left_comm]\n\ntheorem mul_pp_pf_overlap (ea eb : ℝ) (h : 0 < x) (_ : a₂ * b₂ = c) :\n    (x ^ ea * a₂ : ℝ) * (x ^ eb * b₂) = x ^ (ea + eb) * c := by\n  subst_vars; rw [rpow_add h, mul_mul_mul_comm]\n\n/-- Multiplies two monomials `va, vb` together to get a normalized result monomial.\n\n* `x * y = (x * y)` (for `x`, `y` coefficients)\n* `x * (b₁ * b₂) = b₁ * (b₂ * x)` (for `x` coefficient)\n* `(a₁ * a₂) * y = a₁ * (a₂ * y)` (for `y` coefficient)\n* `(x ^ ea * a₂) * (x ^ eb * b₂) = x ^ (ea + eb) * (a₂ * b₂)`\n    (if `ea` and `eb` are identical except coefficient)\n* `(a₁ * a₂) * (b₁ * b₂) = a₁ * (a₂ * (b₁ * b₂))` (if `a₁.lt b₁`)\n* `(a₁ * a₂) * (b₁ * b₂) = b₁ * ((a₁ * a₂) * b₂)` (if not `a₁.lt b₁`)\n-/\npartial def evalMul (va : ExProd a) (vb : ExProd b) : Result ExProd q($a * $b) :=\n  match va, vb with\n  | .one, vb => ⟨b, vb, q(one_mul $b)⟩\n  | va, .one => ⟨a, va, q(mul_one $a)⟩\n  | .mul (x := ax) (b := ab) vax vab, .mul (x := bx) (b := bb) vbx vbb => Id.run do\n    have els (_ : Unit) : Result ExProd q($ax * $ab * ($bx * $bb)) :=\n      if vax.id < vbx.id then\n        let ⟨_, vc, pc⟩ := evalMul vab vb\n        ⟨_, .mul vax vc, (q(mul_pf_left $ax $pc) : Expr)⟩\n      else\n        let ⟨_, vc, pc⟩ := evalMul va vbb\n        ⟨_, .mul vbx vc, (q(mul_pf_right $bx $pc) : Expr)⟩\n    let .pow ai ax ah ae := vax | els ()\n    let .pow bi _ _ be := vbx | els ()\n    unless ai = bi do return els ()\n    let ⟨_, vc, pc⟩ := evalMul vab vbb\n    ⟨_, .mul (.pow ai ax ah q($ae + $be)) vc, (q(mul_pp_pf_overlap $ae $be $ah $pc) : Expr)⟩\n\ntheorem pow_pos (ha : 0 < a) (hb : 0 < b) : 0 < (a ^ e * b : ℝ) :=\n  mul_pos (rpow_pos_of_pos ha e) hb\n\ntheorem pow_pf (ha : 0 < a) (hb : 0 < b) (_ : b ^ e₂ = b') :\n    (a ^ e₁ * b : ℝ) ^ e₂ = a ^ (e₁ * e₂) * b' := by\n  subst_vars; rw [mul_rpow (rpow_pos_of_pos ha e₁).le hb.le, rpow_mul ha.le]\n\ndef evalPow (va : ExProd a) (e : Q(ℝ)) : Option (Q(0 < $a) × Result ExProd q($a ^ $e)) :=\n  match va with\n  | .one => some ⟨q(one_pos), _, .one, q(one_rpow _)⟩\n  | .mul (x := x) vx vb =>\n    match x, vx with\n    | _, .atom .. => none\n    | _, .pow i x hx e₁ => do\n      let ⟨hb, _, vc, pc⟩ ← evalPow vb e\n      some ⟨q(pow_pos $hx $hb), _, .mul (.pow i x hx q($e₁ * $e)) vc, q(pow_pf $hx $hb $pc)⟩\n\ntheorem pow_congr (_ : a = a') (_ : a' ^ b = c) : (a ^ b : ℝ) = c := by subst_vars; rfl\n\ntheorem inv_congr (_ : a = a') (_ : a' ^ (-1 : ℝ) = b) : (a⁻¹ : ℝ) = b := by\n  subst_vars; simp [rpow_neg_one]\n\ntheorem npow_congr {b : ℕ} (_ : a = a') (_ : a' ^ (b : ℝ) = c) : Monoid.npow b a = c := by\n  subst_vars; simp [rpow_nat_cast]\n\npartial def eval (e : Q(ℝ)) : AtomM (Result ExProd e) := Lean.withIncRecDepth do\n  let els := evalAtom e\n  let .const n _ := (← withReducible <| whnf e).getAppFn | els\n  match n with\n  | ``HMul.hMul | ``Mul.mul => match e with\n    | ~q($a * $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let ⟨_, vb, pb⟩ ← eval b\n      let ⟨c, vc, p⟩ := evalMul va vb\n      pure ⟨c, vc, (q(Ring.mul_congr $pa $pb $p) : Expr)⟩\n    | _ => els\n  | ``HPow.hPow | ``Pow.pow => match e with\n    | ~q($a ^ $b) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va b | els\n      pure ⟨c, vc, (q(pow_congr $pa $p) : Expr)⟩\n    | ~q(Monoid.npow $b $a) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, c, vc, p⟩ := evalPow va q($b) | els\n      pure ⟨c, vc, (q(npow_congr $pa $p) : Expr)⟩\n    | _ => els\n  | ``Inv.inv => match e with\n    | ~q($a⁻¹) =>\n      let ⟨_, va, pa⟩ ← eval a\n      let some ⟨_, b, vb, p⟩ := evalPow va q(-1) | els\n      pure ⟨b, vb, (q(inv_congr $pa $p) : Expr)⟩\n    | _ => els\n  | _ => els\n\ndef rewrite (parent : Expr) (root := true) : M Simp.Result := fun nctx rctx s ↦\n  let pre e :=\n    try\n      guard <| root || parent != e -- recursion guard\n      let e ← withReducible <| whnf e\n      guard e.isApp -- all interesting ring expressions are applications\n      guard <| ← isDefEq (← inferType e) q(ℝ)\n      let ⟨a, _, pa⟩ ← eval e rctx s\n      let r ← nctx.simp { expr := a, proof? := pa }\n      if ← withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n      pure (.done r)\n    catch _ =>\n      pure <| Simp.Step.visit { expr := e }\n  let post := (Simp.postDefault · fun _ ↦ none)\n  (·.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })\n\nopen RingNF in\n/--\nRuns a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n-/\ndef M.run\n    (s : IO.Ref AtomM.State) (cfg : RPowRing.Config) (x : M α) : MetaM α := do\n  let ctx : Simp.Context := {\n    simpTheorems := #[← Elab.Tactic.simpOnlyBuiltins.foldlM (·.addConst ·) {}]\n    congrTheorems := ← getSimpCongrTheorems }\n  let thms : SimpTheorems := {}\n  let thms ← [``mul_one, ``one_mul, ``pow_one, ``RingNF.mul_neg, ``RingNF.add_neg\n    ].foldlM (·.addConst ·) thms\n  let ctx' := { ctx with simpTheorems := #[thms] }\n  let simp (r' : Simp.Result) := do\n    Simp.mkEqTrans r' (← Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  x { ctx := { ctx with config.singlePass := true }, simp } { red := cfg.red } s\n\nopen Elab.Tactic Parser.Tactic\n/-- Use `rpow_ring` to rewrite the main goal. -/\ndef rpowRingTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal ← getMainGoal\n  let tgt ← instantiateMVars (← goal.getType)\n  let r ← M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (← mkOfEqTrue (← r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [← applySimpResultToTarget goal tgt r]\n\n/-- Use `rpow_ring` to rewrite hypothesis `h`. -/\ndef rpowRingLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt ← instantiateMVars (← fvarId.getType)\n  let goal ← getMainGoal\n  let myres ← M.run s cfg <| rewrite tgt\n  match ← applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]\n\n/--\nSimplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `rpow_ring!` will use a more aggressive reducibility setting to identify atoms.\n* `rpow_ring (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `rpow_ring` will also recurse into atoms\n* `rpow_ring` works as both a tactic and a conv tactic.\n  In tactic mode, `rpow_ring at h` can be used to rewrite in a hypothesis.\n-/\nelab (name := rpowRing) \"rpow_ring\" tk:\"!\"? cfg:(config ?) loc:(location)? : tactic => do\n  let mut cfg ← elabConfig cfg\n  if tk.isSome then cfg := { cfg with red := .default }\n  let loc := (loc.map expandLocation).getD (.targets #[] true)\n  let s ← IO.mkRef {}\n  withLocation loc (rpowRingLocalDecl s cfg) (rpowRingTarget s cfg)\n    fun _ ↦ throwError \"rpow_ring failed\"\n\n@[inherit_doc rpowRing] macro \"rpow_ring!\" cfg:(config)? loc:(location)? : tactic =>\n  `(tactic| rpow_ring ! $(cfg)? $(loc)?)\n\n@[inherit_doc rpowRing] syntax (name := rpowRingConv) \"rpow_ring\" \"!\"? (config)? : conv\n\n/-- Elaborator for the `rpow_ring` tactic. -/\n@[tactic rpowRingConv] def elabRPowRingConv : Tactic := fun stx ↦ match stx with\n  | `(conv| rpow_ring $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg ← elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s ← IO.mkRef {}\n    Conv.applySimpResult (← M.run s cfg <| rewrite (← instantiateMVars (← Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax\n\ntheorem _root_.Real.pow_neg (a b : ℝ) (h : 0 ≤ a) : a ^ (-b) = a⁻¹ ^ b := by\n  simp [← rpow_neg_one, ← rpow_mul h]\n\ntheorem _root_.Real.inv_rpow' (hx : 0 ≤ x) (y : ℝ) : x⁻¹ ^ y = x ^ (-y) := by\n  simp only [← rpow_neg_one, ← rpow_mul hx, neg_mul, one_mul]\n\ntheorem _root_.Real.rpow_inv (hx : 0 ≤ x) (y : ℝ) : (x ^ y)⁻¹ = x ^ (-y) := by\n  simp [← inv_rpow' hx, inv_rpow hx]\n\nlemma fix_cast₁ : (Int.cast (Int.ofNat 1) : ℝ) = 1 := Int.cast_eq_one.mpr rfl\n\nlemma fix_cast₂ {n : ℕ} : (Int.cast (Int.ofNat n) : ℝ) = n := rfl\n\nlemma fix_cast₃ {n : ℕ} [n.AtLeastTwo] : (Nat.cast n : ℝ) = OfNat.ofNat n := by rfl\n\nopen Lean Lean.PrettyPrinter.Delaborator in\n@[delab app.OfNat.ofNat] def delab_ofNat := whenPPOption Lean.getPPNotation do\n  SubExpr.withNaryArg 1 delab\n\nopen Lean Parser Tactic\nmacro \"rpow_simp\" extras:(simpArgs)? loc:(location)? : tactic => `(tactic|\n  ((((simp (config := {failIfUnchanged := false}) (discharger := positivity) only\n      [abs_one, abs_mul, abs_inv, abs_div, abs_abs, abs_zero, mul_rpow, ← rpow_mul, div_rpow,\n       ← rpow_nat_cast, abs_rpow_of_nonneg, rpow_one, ← rpow_add, ← rpow_sub, zero_rpow, one_rpow,\n       rpow_one, inv_rpow', rpow_inv] $(loc)? <;> try push_cast) <;>\n   try rpow_ring) <;> try field_simp only $(extras)? $(loc)?) <;> try ring_nf (config:={}) $(loc)?) <;>\n   try simp (discharger := positivity) only [abs_one, abs_zero, one_rpow, rpow_one, rpow_zero, mul_zero, zero_mul, mul_one, one_mul,\n       fix_cast₁, fix_cast₂, fix_cast₃, Nat.cast_one, inv_rpow', rpow_inv] $(loc)?)\n\n","proof":":= by\n  rpow_simp","declId":"PFR.Tactic.RPowSimp.310_0.JQv8zIegBpv0leR","decl":"example (a e b : ℝ) (_ : 0 < a) :\n    ((a ^ (e / b)) ^ b) * b ^ e * a ^ (-b) = a ^ (e / b * b - b) * b ^ e "}
