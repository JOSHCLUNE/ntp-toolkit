{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n","proof":":= Sigma.casesOn a f","declId":"PFR.Mathlib.Probability.Independence.Basic.14_0.LdMrQvd0gEnGs4y","decl":"/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\n","proof":":= by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h","declId":"PFR.Mathlib.Probability.Independence.Basic.32_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\n","proof":":= by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp","declId":"PFR.Mathlib.Probability.Independence.Basic.42_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\n","proof":":= by\n  apply h.reindex_of_injective _ (Equiv.injective g)","declId":"PFR.Mathlib.Probability.Independence.Basic.52_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\n","proof":":=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩","declId":"PFR.Mathlib.Probability.Independence.Basic.55_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\n","proof":":= by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)","declId":"PFR.Mathlib.Probability.Independence.Basic.58_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n","proof":":= by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]","declId":"PFR.Mathlib.Probability.Independence.Basic.67_0.LdMrQvd0gEnGs4y","decl":"@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\n","proof":":= by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]","declId":"PFR.Mathlib.Probability.Independence.Basic.66_0.LdMrQvd0gEnGs4y","decl":"variable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\n","proof":":=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht","declId":"PFR.Mathlib.Probability.Independence.Basic.83_0.LdMrQvd0gEnGs4y","decl":"theorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\n","proof":":= by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl","declId":"PFR.Mathlib.Probability.Independence.Basic.89_0.LdMrQvd0gEnGs4y","decl":"theorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n","proof":":= by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]","declId":"PFR.Mathlib.Probability.Independence.Basic.99_0.LdMrQvd0gEnGs4y","decl":"/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\n","proof":":= by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]","declId":"PFR.Mathlib.Probability.Independence.Basic.106_0.LdMrQvd0gEnGs4y","decl":"lemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n","proof":":= by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht","declId":"PFR.Mathlib.Probability.Independence.Basic.115_0.LdMrQvd0gEnGs4y","decl":"/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\n","proof":":= by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]","declId":"PFR.Mathlib.Probability.Independence.Basic.135_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\n","proof":":= by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]","declId":"PFR.Mathlib.Probability.Independence.Basic.152_0.LdMrQvd0gEnGs4y","decl":"theorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\n","proof":":= by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp","declId":"PFR.Mathlib.Probability.Independence.Basic.168_0.LdMrQvd0gEnGs4y","decl":"theorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\n","proof":":= by\n  measurability","declId":"PFR.Mathlib.Probability.Independence.Basic.210_0.LdMrQvd0gEnGs4y","decl":"lemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n","proof":":= by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]","declId":"PFR.Mathlib.Probability.Independence.Basic.214_0.LdMrQvd0gEnGs4y","decl":"@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n","proof":":= by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]","declId":"PFR.Mathlib.Probability.Independence.Basic.219_0.LdMrQvd0gEnGs4y","decl":"@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n","proof":":= by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd","declId":"PFR.Mathlib.Probability.Independence.Basic.227_0.LdMrQvd0gEnGs4y","decl":"/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n","proof":":=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf","declId":"PFR.Mathlib.Probability.Independence.Basic.291_0.LdMrQvd0gEnGs4y","decl":"/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\n","proof":":= fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)","declId":"PFR.Mathlib.Probability.Independence.Basic.302_0.LdMrQvd0gEnGs4y","decl":"lemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\nlemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β := fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)\n\n\nvariable {β β' Ω : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω}\n\n","proof":":= by\n  refine kernel.IndepFun.ae_eq' hfg ?_ ?_ <;>\n    simp only [ae_dirac_eq, Filter.eventually_pure, kernel.const_apply]\n  exacts [hf, hg]","declId":"PFR.Mathlib.Probability.Independence.Basic.322_0.LdMrQvd0gEnGs4y","decl":"/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.ae_eq' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β}\n    {g g' : Ω → β'} (hfg : IndepFun f g μ)\n    (hf : f =ᵐ[μ] f') (hg : g =ᵐ[μ] g') : IndepFun f' g' μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\nlemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β := fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)\n\n\nvariable {β β' Ω : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω}\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.ae_eq' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β}\n    {g g' : Ω → β'} (hfg : IndepFun f g μ)\n    (hf : f =ᵐ[μ] f') (hg : g =ᵐ[μ] g') : IndepFun f' g' μ := by\n  refine kernel.IndepFun.ae_eq' hfg ?_ ?_ <;>\n    simp only [ae_dirac_eq, Filter.eventually_pure, kernel.const_apply]\n  exacts [hf, hg]\n\n","proof":":=\n  kernel.Indep.symm hfg","declId":"PFR.Mathlib.Probability.Independence.Basic.330_0.LdMrQvd0gEnGs4y","decl":"/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem kernel.IndepFun.symm' {Ω α β γ : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace γ} {κ : kernel α Ω} {f : Ω → β} {g : Ω → γ}\n    {μ : Measure α}\n    (hfg : kernel.IndepFun f g κ μ) : kernel.IndepFun g f κ μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\nlemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β := fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)\n\n\nvariable {β β' Ω : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω}\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.ae_eq' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β}\n    {g g' : Ω → β'} (hfg : IndepFun f g μ)\n    (hf : f =ᵐ[μ] f') (hg : g =ᵐ[μ] g') : IndepFun f' g' μ := by\n  refine kernel.IndepFun.ae_eq' hfg ?_ ?_ <;>\n    simp only [ae_dirac_eq, Filter.eventually_pure, kernel.const_apply]\n  exacts [hf, hg]\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem kernel.IndepFun.symm' {Ω α β γ : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace γ} {κ : kernel α Ω} {f : Ω → β} {g : Ω → γ}\n    {μ : Measure α}\n    (hfg : kernel.IndepFun f g κ μ) : kernel.IndepFun g f κ μ :=\n  kernel.Indep.symm hfg\n\n","proof":":= kernel.IndepFun.symm' hfg","declId":"PFR.Mathlib.Probability.Independence.Basic.337_0.LdMrQvd0gEnGs4y","decl":"/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.symm' {γ β Ω : Type*} {_ : MeasurableSpace γ}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → γ}\n    (hfg : IndepFun f g μ) :\n    IndepFun g f μ "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\nlemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β := fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)\n\n\nvariable {β β' Ω : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω}\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.ae_eq' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β}\n    {g g' : Ω → β'} (hfg : IndepFun f g μ)\n    (hf : f =ᵐ[μ] f') (hg : g =ᵐ[μ] g') : IndepFun f' g' μ := by\n  refine kernel.IndepFun.ae_eq' hfg ?_ ?_ <;>\n    simp only [ae_dirac_eq, Filter.eventually_pure, kernel.const_apply]\n  exacts [hf, hg]\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem kernel.IndepFun.symm' {Ω α β γ : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace γ} {κ : kernel α Ω} {f : Ω → β} {g : Ω → γ}\n    {μ : Measure α}\n    (hfg : kernel.IndepFun f g κ μ) : kernel.IndepFun g f κ μ :=\n  kernel.Indep.symm hfg\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.symm' {γ β Ω : Type*} {_ : MeasurableSpace γ}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → γ}\n    (hfg : IndepFun f g μ) :\n    IndepFun g f μ := kernel.IndepFun.symm' hfg\n\n","proof":":= by\n  unfold Filter.EventuallyEq Filter.Eventually at h ⊢\n  simp at h ⊢\n  rw [← Filter.biInter_finset_mem] at h\n  apply Filter.mem_of_superset h\n  intro a ha\n  simp at ha ⊢\n  change a ∈ ⋂ i ∈ s, E i ↔ a ∈ ⋂ i ∈ s, F i\n  simp\n  change ∀ i ∈ s, a ∈ E i ↔ a ∈ F i at ha\n  exact ball_congr ha","declId":"PFR.Mathlib.Probability.Independence.Basic.343_0.LdMrQvd0gEnGs4y","decl":"/-- The new Mathlib tool `Finset.eventuallyEq_iInter` will supersede this result. -/\ntheorem EventuallyEq.finite_iInter {ι : Type*} {α : Type u_2} {l : Filter α} (s: Finset ι)\n    {E : ι → Set α} {F : ι → Set α}\n    (h : ∀ i ∈ s, E i =ᶠ[l] F i) :\n    ⋂ i ∈ s, E i =ᶠ[l] ⋂ i ∈ s, F i "}
{"srcUpToDecl":"import Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Data.Fintype.Lattice\nimport PFR.Mathlib.Data.Finset.Sigma\nimport PFR.Mathlib.Data.Fintype.Sigma\nimport PFR.Mathlib.Probability.Independence.Kernel\n\nopen Function MeasureTheory MeasurableSpace Measure Set\nopen scoped BigOperators MeasureTheory ENNReal\n\nnamespace Sigma\nvariable {α γ : Type*} {β : α → Type*}\n\n/-- Nondependent eliminator for `Sigma`. -/\ndef elim (f : ∀ a, β a → γ) (a : Sigma β) : γ := Sigma.casesOn a f\n\nend Sigma\n\nnamespace ProbabilityTheory\nvariable {Ω ι β γ : Type*} {κ : ι → Type*}\n\nsection IndepFun\nvariable {β β' γ γ' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\nsection iIndepFun\n\nvariable {Ω ι ι' : Type*} [MeasurableSpace Ω] {α β : ι → Type*}\n  [n : ∀ i, MeasurableSpace (α i)]\n  [m : ∀ i, MeasurableSpace (β i)] {f : ∀ i, Ω → α i}\n  {μ : Measure Ω}\n\nlemma iIndepFun.reindex_of_injective (h : iIndepFun n f μ) (g : ι' → ι) (hg : Injective g) :\n    iIndepFun (n ∘' g) (f ∘' g) μ := by\n  have : IsProbabilityMeasure μ := h.isProbabilityMeasure\n  nontriviality ι'\n  have A : ∀ x, invFun g (g x) = x := leftInverse_invFun hg\n  rw [iIndepFun_iff] at h ⊢\n  intro t s' hs'\n  specialize h (t.map ⟨g, hg⟩ ) (f' := fun i ↦ s' (invFun g i)) (by simpa [A ] using hs')\n  simpa [A] using h\n\nlemma iIndepFun.reindex (g : ι' ≃ ι) (h : iIndepFun (n ∘' g) (f ∘' g) μ) : iIndepFun n f μ := by\n  rw [iIndepFun_iff] at h ⊢\n  intro t s hs\n  have : ⋂ i, ⋂ (_ : g i ∈ t), s (g i) = ⋂ i ∈ t, s i\n  · ext x; simp [g.forall_congr_left']\n  specialize h (t.map g.symm.toEmbedding) (f' := s ∘ g)\n  simp [this, g.forall_congr_left'] at h\n  apply h\n  convert hs <;> simp\n\nlemma iIndepFun.reindex_symm (g : ι' ≃ ι) (h : iIndepFun n f μ) : iIndepFun (n ∘' g) (f ∘' g) μ := by\n  apply h.reindex_of_injective _ (Equiv.injective g)\n\nlemma iIndepFun_reindex_iff (g : ι' ≃ ι) : iIndepFun (n ∘' g) (f ∘' g) μ ↔ iIndepFun n f μ :=\n  ⟨fun h ↦ h.reindex g, fun h ↦ h.reindex_symm g⟩\n\nlemma iIndepFun.comp (h : iIndepFun n f μ) (g : ∀ i, α i → β i) (hg : ∀ i, Measurable (g i)) :\n    iIndepFun m (fun i ↦ g i ∘ f i) μ := by\n  rw [iIndepFun_iff] at h ⊢\n  refine fun t s hs ↦ h t (fun i hi ↦ ?_)\n  simp_rw [measurable_iff_comap_le] at hg\n  simp_rw [← MeasurableSpace.comap_comp] at hs\n  exact MeasurableSpace.comap_mono (hg i) (s i) (hs i hi)\n\nvariable (i : ι) [Inv (α i)] [MeasurableInv (α i)] [DecidableEq ι] in\n@[to_additive]\nlemma iIndepFun.inv (h : iIndepFun n f μ) : iIndepFun n (update f i (f i)⁻¹) μ := by\n  convert h.comp (update (fun _ ↦ id) i (·⁻¹)) _ with j\n  · by_cases hj : j = i\n    · subst hj; ext x; simp\n    · simp [hj]\n  intro j\n  by_cases hj : j = i\n  · subst hj; simp [measurable_inv]\n  · simp [hj, measurable_id]\n\nend iIndepFun\n\nsection\nvariable {β β' : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → β'}\n\ntheorem IndepFun.measure_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ (f ⁻¹' s ∩ g ⁻¹' t) = μ (f ⁻¹' s) * μ (g ⁻¹' t) :=\n  indepFun_iff_measure_inter_preimage_eq_mul.1 h _ _ hs ht\n\ntheorem IndepFun.measureReal_inter_preimage_eq_mul {_mβ : MeasurableSpace β}\n    {_mβ' : MeasurableSpace β'} (h : IndepFun f g μ) {s : Set β} {t : Set β'}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    μ.real (f ⁻¹' s ∩ g ⁻¹' t) = μ.real (f ⁻¹' s) * μ.real (g ⁻¹' t) := by\n  rw [measureReal_def, h.measure_inter_preimage_eq_mul hs ht, ENNReal.toReal_mul]; rfl\n\nend\n\nvariable {Ω' : Type*} [MeasurableSpace Ω'] [MeasurableSpace α] [MeasurableSpace β]\n\n/-- Random variables are always independent of constants. -/\nlemma indepFun_const [IsProbabilityMeasure μ] (c : α) : IndepFun f (fun _ => c) μ := by\n  rw [IndepFun_iff, MeasurableSpace.comap_const]\n  intro t₁ t₂ _ ht₂\n  rcases MeasurableSpace.measurableSet_bot_iff.mp ht₂ with h | h\n  all_goals simp [h]\n\nlemma indepFun_fst_snd [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    IndepFun (Prod.fst : Ω × Ω' → Ω) (Prod.snd : Ω × Ω' → Ω') (μ.prod μ') := by\n  rw [IndepFun_iff]\n  rintro _ _ ⟨s, _, rfl⟩ ⟨t, _, rfl⟩\n  simp [← Set.prod_univ, ← Set.univ_prod, Set.top_eq_univ, Set.prod_inter_prod, Set.inter_univ,\n    Set.univ_inter, Measure.prod_prod, measure_univ, mul_one, one_mul]\n\nvariable {f : Ω → α} {g : Ω → β}\n\n/-- Composing independent functions with a measurable embedding of conull range gives independent\nfunctions. -/\nlemma IndepFun.comp_right {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hg : Measurable g) (hfg : IndepFun f g μ) :\n    IndepFun (f ∘ i) (g ∘ i) (μ.comap i) := by\n  change μ (range i)ᶜ = 0 at hi'\n  rw [IndepFun_iff] at hfg ⊢\n  rintro _ _ ⟨s, hs, rfl⟩ ⟨t, ht, rfl⟩\n  rw [preimage_comp, preimage_comp, ← preimage_inter, comap_apply, comap_apply, comap_apply,\n    image_preimage_eq_inter_range, image_preimage_eq_inter_range, image_preimage_eq_inter_range,\n    measure_inter_conull hi', measure_inter_conull hi', measure_inter_conull hi',\n    hfg _ _ ⟨_, hs, rfl⟩ ⟨_, ht, rfl⟩]\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hi.measurable $ hf hs\n  | exact hi.measurable $ hg ht\n  | exact hi.measurable $ (hf hs).inter $ hg ht\n\n-- Same as `iIndepFun_iff` except that the function `f'` returns measurable sets even on junk values\nlemma iIndepFun_iff' [MeasurableSpace Ω] {β : ι → Type*}\n    (m : ∀ i, MeasurableSpace (β i)) (f : ∀ i, Ω → β i) (μ : Measure Ω) :\n    iIndepFun m f μ ↔ ∀ (s : Finset ι) ⦃f' : ι → Set Ω⦄\n      (_hf' : ∀ i, MeasurableSet[(m i).comap (f i)] (f' i)),\n      μ (⋂ i ∈ s, f' i) = ∏ i in s, μ (f' i) := by\n  classical\n  rw [iIndepFun_iff]\n  refine forall_congr' fun s ↦ ⟨fun h f hf ↦ h fun i _ ↦ hf _, fun h f hf ↦ ?_⟩\n  let g (i : ι) : Set Ω := if i ∈ s then f i else univ\n  have (i : ι) (hi : i ∈ s) : f i = g i := (if_pos hi).symm\n  convert @h g _ using 2\n  · exact iInter₂_congr this\n  · rw [this _ ‹_›]\n  · rintro i\n    by_cases hi : i ∈ s <;> simp [hi, hf]\n\n-- TODO: Replace mathlib version with this lemma (this lemma uses `AEMeasurable`)\ntheorem indepFun_iff_map_prod_eq_prod_map_map' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'}\n    {f : Ω → β} {g : Ω → β'} [IsFiniteMeasure μ] (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    IndepFun f g μ ↔ μ.map (fun ω ↦ (f ω, g ω)) = (μ.map f).prod (μ.map g) := by\n  rw [indepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {s : Set β} {t : Set β'} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n      μ (f ⁻¹' s) * μ (g ⁻¹' t) = μ.map f s * μ.map g t ∧\n      μ (f ⁻¹' s ∩ g ⁻¹' t) = μ.map (fun ω ↦ (f ω, g ω)) (s ×ˢ t) :=\n    ⟨by rw [Measure.map_apply_of_aemeasurable hf hs, Measure.map_apply_of_aemeasurable hg ht],\n      (Measure.map_apply_of_aemeasurable (hf.prod_mk hg) (hs.prod ht)).symm⟩\n  constructor\n  · refine fun h ↦ (Measure.prod_eq fun s t hs ht ↦ ?_).symm\n    rw [← (h₀ hs ht).1, ← (h₀ hs ht).2, h s t hs ht]\n  · intro h s t hs ht\n    rw [(h₀ hs ht).1, (h₀ hs ht).2, h, Measure.prod_prod]\n\n-- TODO(Mantas): Add this to mathlib & upgrade to work for `AEMeasurable` (currently lemmas missing)\ntheorem iIndepFun_iff_pi_map_eq_map {ι : Type*} {β : ι → Type*} [Fintype ι]\n    (f : ∀ x : ι, Ω → β x) [m : ∀ x : ι, MeasurableSpace (β x)]\n    [IsProbabilityMeasure μ] (hf : ∀ (x : ι), Measurable (f x)) :\n    iIndepFun m f μ ↔ Measure.pi (fun i ↦ μ.map (f i)) = μ.map (fun ω i ↦ f i ω) := by\n  classical -- might be able to get rid of this\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul]\n  have h₀ {h : ∀ i, Set (β i)} (hm : ∀ (i : ι), MeasurableSet (h i)) :\n      ∏ i : ι, μ (f i ⁻¹' h i) = ∏ i : ι, μ.map (f i) (h i) ∧\n      μ (⋂ i : ι, (f i ⁻¹' h i)) = μ.map (fun ω i ↦ f i ω) (Set.pi univ h)\n  · constructor\n    · rw [Finset.prod_congr (show Finset.univ = Finset.univ by rfl)\n      (fun x _ => Measure.map_apply_of_aemeasurable (hf x).aemeasurable (hm x))]\n    rw [Measure.map_apply_of_aemeasurable _ (MeasurableSet.univ_pi hm)]\n    · congr\n      aesop\n    measurability\n  refine ⟨fun hS ↦ Measure.pi_eq fun h hm ↦ ?_, fun h S s hs ↦ ?_⟩\n  · rw [← (h₀ hm).1, ← (h₀ hm).2]\n    convert hS Finset.univ (sets := h)\n    simp [hm]\n  set l : ∀ i, Set (β i) := fun i ↦ if i ∈ S then s i else univ with hldef\n  have hl (i : ι) : MeasurableSet (l i) := by by_cases hiS : i ∈ S <;> simp [hldef, hiS, hs]\n  specialize h₀ hl\n  rw [← h] at h₀\n  convert h₀.2 using 1\n  · congr with x\n    simp (config := { contextual := true })\n  convert h₀.1 using 1\n  · rw [hldef, ← Finset.prod_compl_mul_prod S]\n    suffices : ∀ i ∈ Sᶜ, μ (f i ⁻¹' (fun i ↦ if i ∈ S then s i else univ) i) = 1\n    · rw [Finset.prod_congr (show Sᶜ = Sᶜ by rfl) this]; aesop\n    aesop\n  . simp\n\nend IndepFun\nend ProbabilityTheory\n\nnamespace ProbabilityTheory\nvariable {ι Ω : Type*} {κ : ι → Type*} {α : ∀ i, κ i → Type*} [MeasurableSpace Ω] {μ : Measure Ω}\n  [IsProbabilityMeasure μ] [m : ∀ i j, MeasurableSpace (α i j)] {f : ∀ i j, Ω → α i j}\n  [Fintype ι] [∀ i, Fintype (κ i)]\n\nlemma measurable_sigmaCurry :\n    Measurable (Sigma.curry : (∀ ij : Σ i, κ i, α ij.1 ij.2) → ∀ i j, α i j) := by\n  measurability\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod {β : Type*} [CommMonoid β] (f : ∀ i, κ i → β) :\n    (∏ ij : (i : ι) × κ i, f ij.1 ij.2) = (∏ i : ι, ∏ j : κ i, f i j) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\n@[to_additive]\nlemma _root_.Finset.prod_univ_prod' {β : Type*} [CommMonoid β] (f : ((i : ι) × κ i) → β) :\n    (∏ ij : (i : ι) × κ i, f ij) = (∏ i : ι, ∏ j : κ i, f ⟨i, j⟩) := by\n  rw [← Finset.univ_sigma_univ, Finset.prod_sigma]\n\nvariable {ι : Type*} {κ : ι → Type*} [∀ i, Fintype (κ i)]\n  {α : ∀ i, κ i → Type*} {f : ∀ i j, Ω → α i j} [m : ∀ i j, MeasurableSpace (α i j)]\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi\n    (f_meas : ∀ i j, Measurable (f i j))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) (fun ij : Σ i, κ i ↦ f ij.1 ij.2) μ) :\n    iIndepFun (fun i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f i j ω)) μ := by\n  let F i ω j := f i j ω\n  let M (i : ι):= MeasurableSpace.pi (m := m i)\n  let πβ (i : ι) := Set.pi Set.univ '' Set.pi Set.univ fun j => { s | MeasurableSet[m i j] s }\n  apply iIndepSets.iIndep\n  · exact fun i ↦ measurable_iff_comap_le.mp (measurable_pi_iff.mpr (f_meas i))\n  · exact fun i ↦ IsPiSystem.comap isPiSystem_pi (F i)\n  · intro k\n    show MeasurableSpace.comap _ (M k) = _\n    have : M k = MeasurableSpace.generateFrom (πβ k) := generateFrom_pi.symm\n    rewrite [this, MeasurableSpace.comap_generateFrom] ; rfl\n\n  rw [iIndepSets_iff]\n  intro s E hE\n  simp? at hE\n    says simp only [mem_image, mem_pi, mem_univ, mem_setOf_eq, forall_true_left,\n      exists_exists_and_eq_and] at hE\n  have hE' (k : s) := hE k (Finset.coe_mem k)\n  classical\n  obtain ⟨sets, h_sets⟩ := Classical.axiomOfChoice hE'\n  let sets' (i : ι) (j : κ i) : Set (α i j) := if h : i ∈ s then sets ⟨i, h⟩ j else Set.univ\n  have box (i : ι) (hi : i ∈ s) : E i = ⋂ j : κ i, (f i j)⁻¹' (sets' i j) := by\n    rw [← (h_sets ⟨i, hi⟩).right]\n    simp_rw [hi]\n    ext : 1\n    rw [Set.mem_preimage, Set.mem_univ_pi, Set.mem_iInter]\n    exact ⟨fun hj j ↦ mem_preimage.mpr (hj j), fun hj j ↦ mem_preimage.mp (hj j)⟩\n\n  let set (i : ι) (j : κ i) := f i j ⁻¹' sets' i j\n  set set_σ := fun (ij : (i : ι) × κ i) ↦ set ij.fst ij.snd with set_σ_def\n  let meas i j := μ (set i j)\n  let meas_σ ij := μ (set_σ ij)\n  suffices : μ (⋂ i ∈ s, ⋂ j : κ i, set i j) = ∏ i in s, μ (⋂ j : κ i, set i j)\n  · convert this with k hk k hk ; all_goals { exact box k hk }\n\n  let κ_σ (i : ι) := Finset.sigma {i} fun i ↦ Finset.univ (α := κ i)\n  have reindex_prod (i : ι) : ∏ j : κ i, meas i j = ∏ ij : κ_σ i, meas_σ ij := by\n    rw [Finset.prod_coe_sort, Finset.prod_sigma, Finset.prod_singleton]\n  have reindex_inter (i : ι) : ⋂ j : κ i, set i j = ⋂ ij : κ_σ i, set_σ ij := by\n    rw [iInter_subtype, set_σ_def, ← Finset.iInter_sigma, Finset.set_biInter_singleton]\n    exact Finset.set_biInter_univ\n\n  rw [iIndepFun_iff_measure_inter_preimage_eq_mul] at hf\n  rw [Fintype.iInter_sigma, hf, Finset.prod_sigma]\n  · apply Finset.prod_congr rfl\n    intro i hi\n    symm\n    rw [reindex_prod, reindex_inter, Finset.prod_coe_sort, iInter_subtype]\n    apply hf (κ_σ i) (sets := fun ij ↦ sets' ij.fst ij.snd)\n    intro ij hij\n    rw [← Finset.mem_singleton.mp (Finset.mem_sigma.mp hij).left] at hi\n    convert (h_sets ⟨ij.fst, hi⟩).left ij.snd\n    simp? [hi] says simp only [hi, dite_true]\n  intros ij hij\n  obtain ⟨hi, _⟩ := Finset.mem_sigma.mp hij\n  simp_rw [hi]\n  exact (h_sets ⟨ij.fst, hi⟩).1 ij.snd\n\n\n/-- If a family of functions `(i, j) ↦ f i j` is independent, then the family of function tuples\n`i ↦ (f i j)ⱼ` is independent. -/\nlemma iIndepFun.pi' {f : ∀ ij : (Σ i, κ i), Ω → α ij.1 ij.2 }\n    (f_meas : ∀ i, Measurable (f i))\n    (hf : iIndepFun (fun ij : Σ i, κ i ↦ m ij.1 ij.2) f μ) :\n    iIndepFun (fun _i ↦ MeasurableSpace.pi) (fun i ω ↦ (fun j ↦ f ⟨i, j⟩ ω)) μ :=\n  iIndepFun.pi (fun _ _ ↦ f_meas _) hf\n\nvariable {ι ι' : Type*} {α : ι → Type*}\n    {n : (i : ι) → MeasurableSpace (α i)} {f : (i : ι) → Ω → α i}\n    {hf : ∀ (i : ι), Measurable (f i)} {ST : ι' → Finset ι} (hS : Pairwise (Disjoint on ST))\nlemma iIndepFun.prod (h : iIndepFun n f μ) :\n    let β := fun k ↦ Π i : ST k, α i\n    iIndepFun (β := β) (fun k ↦ MeasurableSpace.pi) (fun (k : ι') (x : Ω) (i : ST k) ↦ f i x) μ := by\n  let g : (i : ι') × ST i → ι := Subtype.val ∘' (Sigma.snd (α := ι'))\n  have hg : Injective g := by\n    intro x y hxy\n    have : ¬(Disjoint on ST) x.fst y.fst := by\n      refine not_forall.mpr ⟨{g y}, ?_⟩\n      rewrite [not_imp, not_imp]\n      repeat' apply And.intro\n      · exact Finset.singleton_subset_iff.mpr (by rewrite [← hxy] ; exact Finset.coe_mem x.snd)\n      · exact Finset.singleton_subset_iff.mpr (Finset.coe_mem y.snd)\n      · rewrite [le_bot_iff] ; exact Finset.singleton_ne_empty (g y)\n    exact Sigma.subtype_ext (not_ne_iff.mp ((@hS x.fst y.fst).mt this)) hxy\n  let m (i : ι') (j : ST i) : MeasurableSpace (α j) := n j\n  exact iIndepFun.pi' (m := m) (hf ∘' g) (h.reindex_of_injective g hg)\n\n\nvariable {β β' Ω : Type*} {mΩ : MeasurableSpace Ω} {μ : Measure Ω}\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.ae_eq' {mβ : MeasurableSpace β} {mβ' : MeasurableSpace β'} {f f' : Ω → β}\n    {g g' : Ω → β'} (hfg : IndepFun f g μ)\n    (hf : f =ᵐ[μ] f') (hg : g =ᵐ[μ] g') : IndepFun f' g' μ := by\n  refine kernel.IndepFun.ae_eq' hfg ?_ ?_ <;>\n    simp only [ae_dirac_eq, Filter.eventually_pure, kernel.const_apply]\n  exacts [hf, hg]\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem kernel.IndepFun.symm' {Ω α β γ : Type*} {_ : MeasurableSpace Ω} {_ : MeasurableSpace α}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace γ} {κ : kernel α Ω} {f : Ω → β} {g : Ω → γ}\n    {μ : Measure α}\n    (hfg : kernel.IndepFun f g κ μ) : kernel.IndepFun g f κ μ :=\n  kernel.Indep.symm hfg\n\n/-- in mathlib as of `4d385393cd569f08ac30425ef886a57bb10daaa5` (TODO: bump) -/\ntheorem IndepFun.symm' {γ β Ω : Type*} {_ : MeasurableSpace γ}\n    {_ : MeasurableSpace β} {_ : MeasurableSpace Ω} {μ : Measure Ω} {f : Ω → β} {g : Ω → γ}\n    (hfg : IndepFun f g μ) :\n    IndepFun g f μ := kernel.IndepFun.symm' hfg\n\n/-- The new Mathlib tool `Finset.eventuallyEq_iInter` will supersede this result. -/\ntheorem EventuallyEq.finite_iInter {ι : Type*} {α : Type u_2} {l : Filter α} (s: Finset ι)\n    {E : ι → Set α} {F : ι → Set α}\n    (h : ∀ i ∈ s, E i =ᶠ[l] F i) :\n    ⋂ i ∈ s, E i =ᶠ[l] ⋂ i ∈ s, F i := by\n  unfold Filter.EventuallyEq Filter.Eventually at h ⊢\n  simp at h ⊢\n  rw [← Filter.biInter_finset_mem] at h\n  apply Filter.mem_of_superset h\n  intro a ha\n  simp at ha ⊢\n  change a ∈ ⋂ i ∈ s, E i ↔ a ∈ ⋂ i ∈ s, F i\n  simp\n  change ∀ i ∈ s, a ∈ E i ↔ a ∈ F i at ha\n  exact ball_congr ha\n\n","proof":":= by\n  rw [iIndepFun_iff_iIndep, iIndep_iff] at hf_Indep ⊢\n  intro s E H\n  have (i : ι) : ∃ E' : Set Ω, i ∈ s → MeasurableSet[MeasurableSpace.comap (f i) (m i)] E' ∧ E' =ᵐ[μ] E i := by\n    by_cases hi: i ∈ s\n    . rcases H i hi with ⟨F, mF, hFE⟩\n      use (f i)⁻¹' F\n      simp [hi]\n      constructor\n      . use F\n      rw [← hFE]\n      exact Filter.EventuallyEq.preimage (hfg i) F\n    use ∅\n    tauto\n  classical\n  rcases Classical.axiomOfChoice this with ⟨E', hE'⟩\n  have hE'' : ∀ i ∈ s, MeasurableSet[MeasurableSpace.comap (f i) (m i)] (E' i) := by\n    intro i hi; exact (hE' i hi).1\n  have hE''' : ∀ i ∈ s, E' i =ᵐ[μ] E i := by\n    intro i hi; exact (hE' i hi).2\n  convert hf_Indep s hE'' using 1 with i\n  . apply measure_congr\n    apply EventuallyEq.finite_iInter\n    intro i hi\n    exact (hE''' i hi).symm\n  apply Finset.prod_congr rfl\n  intro i hi\n  exact measure_congr (hE''' i hi).symm","declId":"PFR.Mathlib.Probability.Independence.Basic.359_0.LdMrQvd0gEnGs4y","decl":"/-- TODO: a kernel version of this theorem-/\ntheorem iIndepFun.ae_eq {ι : Type*} {β : ι → Type*}\n    {m : ∀ i, MeasurableSpace (β i)} {f g : ∀ i, Ω → β i}\n    (hf_Indep : iIndepFun m f μ) (hfg : ∀ i, f i =ᵐ[μ] g i) : iIndepFun m g μ "}
