{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n","proof":":= by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }","declId":"PFR.ForMathlib.Elementary.22_0.iFSsvrDJ9DhpmNK","decl":"@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n","proof":":= n) = (S : Set M) := rfl","declId":"PFR.ForMathlib.Elementary.30_0.iFSsvrDJ9DhpmNK","decl":"@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\n","proof":":= ⟨AddSubmonoid.toSubmodule⟩","declId":"PFR.ForMathlib.Elementary.33_0.iFSsvrDJ9DhpmNK","decl":"instance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n","proof":":= by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }","declId":"PFR.ForMathlib.Elementary.37_0.iFSsvrDJ9DhpmNK","decl":"@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n","proof":":= n)) = f := rfl","declId":"PFR.ForMathlib.Elementary.45_0.iFSsvrDJ9DhpmNK","decl":"@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\n","proof":":= ⟨AddMonoidHom.toLinearMap⟩","declId":"PFR.ForMathlib.Elementary.48_0.iFSsvrDJ9DhpmNK","decl":"instance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n","proof":":= by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }","declId":"PFR.ForMathlib.Elementary.56_0.iFSsvrDJ9DhpmNK","decl":"@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n","proof":":= n) = (H : Set G) := rfl","declId":"PFR.ForMathlib.Elementary.67_0.iFSsvrDJ9DhpmNK","decl":"@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\n","proof":":= ⟨AddSubgroup.toSubmodule⟩","declId":"PFR.ForMathlib.Elementary.70_0.iFSsvrDJ9DhpmNK","decl":"instance : Coe (AddSubgroup G) (Submodule (ZMod n) G) "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n","proof":":= by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }","declId":"PFR.ForMathlib.Elementary.74_0.iFSsvrDJ9DhpmNK","decl":"@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n","proof":":= n)) = f := rfl","declId":"PFR.ForMathlib.Elementary.85_0.iFSsvrDJ9DhpmNK","decl":"@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\n","proof":":= ⟨AddMonoidHom.toLinearMapGroup⟩","declId":"PFR.ForMathlib.Elementary.88_0.iFSsvrDJ9DhpmNK","decl":"instance : Coe (G →+ G') (G →ₗ[ZMod n] G') "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n","proof":":= by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x","declId":"PFR.ForMathlib.Elementary.101_0.iFSsvrDJ9DhpmNK","decl":"@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\n","proof":":= by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this","declId":"PFR.ForMathlib.Elementary.109_0.iFSsvrDJ9DhpmNK","decl":"lemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n","proof":":= addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))","declId":"PFR.ForMathlib.Elementary.119_0.iFSsvrDJ9DhpmNK","decl":"/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\n","proof":":= ofModule","declId":"PFR.ForMathlib.Elementary.126_0.iFSsvrDJ9DhpmNK","decl":"instance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n","proof":":= by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩","declId":"PFR.ForMathlib.Elementary.128_0.iFSsvrDJ9DhpmNK","decl":"/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n","proof":":= by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)","declId":"PFR.ForMathlib.Elementary.148_0.iFSsvrDJ9DhpmNK","decl":"@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n","proof":":= by\n  rw [← sub_eq_add]\n  simp","declId":"PFR.ForMathlib.Elementary.155_0.iFSsvrDJ9DhpmNK","decl":"@[simp]\nlemma add_self ( x : G ) : x + x = 0 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n","proof":":= by\n  simpa [-sub_eq_add] using sub_eq_add 0 x","declId":"PFR.ForMathlib.Elementary.161_0.iFSsvrDJ9DhpmNK","decl":"@[simp]\nlemma neg_eq_self ( x : G ) : - x = x "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\n","proof":":= by\n  rw [← sub_eq_add x y]\n  abel","declId":"PFR.ForMathlib.Elementary.165_0.iFSsvrDJ9DhpmNK","decl":"lemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\n","proof":":= by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]","declId":"PFR.ForMathlib.Elementary.169_0.iFSsvrDJ9DhpmNK","decl":"lemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n","proof":":= by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)","declId":"PFR.ForMathlib.Elementary.174_0.iFSsvrDJ9DhpmNK","decl":"@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n","proof":":= by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)","declId":"PFR.ForMathlib.Elementary.183_0.iFSsvrDJ9DhpmNK","decl":"lemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n","proof":":= by\n  rw [mul_smul]\n  norm_cast\n  simp","declId":"PFR.ForMathlib.Elementary.192_0.iFSsvrDJ9DhpmNK","decl":"@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\n","proof":":= by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp","declId":"PFR.ForMathlib.Elementary.198_0.iFSsvrDJ9DhpmNK","decl":"lemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\n","proof":":= by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩","declId":"PFR.ForMathlib.Elementary.206_0.iFSsvrDJ9DhpmNK","decl":"lemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\n","proof":":= by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2","declId":"PFR.ForMathlib.Elementary.212_0.iFSsvrDJ9DhpmNK","decl":"instance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\n","proof":":= by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2","declId":"PFR.ForMathlib.Elementary.211_0.iFSsvrDJ9DhpmNK","decl":"open Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\n","proof":":= by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']","declId":"PFR.ForMathlib.Elementary.248_0.iFSsvrDJ9DhpmNK","decl":"lemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\nlemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m := by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']\n\nopen Set\n\n","proof":":= by\n  rcases mem_span_set.1 hx with ⟨w, hw, rfl⟩; clear hx\n  use (w.subtypeDomain A).mapRange (↑) rfl\n  rw [Finsupp.sum_mapRange_index (by simp)]\n  set A' := w.support.preimage ((↑) : A → G) injOn_subtype_val\n  erw [Finsupp.sum_subtypeDomain_index hw (h := fun (a : G) (r : ℤ) ↦ ((r : ZMod (n+1)) : ℤ) • a)]\n  refine (Finsupp.sum_congr ?_).symm\n  intro g _\n  generalize w g = r\n  have : ∃ k : ℤ, ((r : ZMod (n+1)) : ℤ) = r + k*(n+1) := by\n    use -(r / (n+1))\n    rw_mod_cast [ZMod.coe_int_cast, Int.mod_eq, sub_eq_add_neg, neg_mul]\n  rcases this with ⟨k, hk⟩\n  rw [hk, add_smul]\n  norm_cast\n  simp only [char_smul_eq_zero', add_zero]","declId":"PFR.ForMathlib.Elementary.253_0.iFSsvrDJ9DhpmNK","decl":"lemma exists_finsupp {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} {x : G} (hx : x ∈ Submodule.span ℤ A) :\n    ∃ μ : A →₀ ZMod (n + 1), (μ.sum fun a r ↦ (r : ℤ) • (a : G)) = x "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\nlemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m := by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']\n\nopen Set\n\nlemma exists_finsupp {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} {x : G} (hx : x ∈ Submodule.span ℤ A) :\n    ∃ μ : A →₀ ZMod (n + 1), (μ.sum fun a r ↦ (r : ℤ) • (a : G)) = x := by\n  rcases mem_span_set.1 hx with ⟨w, hw, rfl⟩; clear hx\n  use (w.subtypeDomain A).mapRange (↑) rfl\n  rw [Finsupp.sum_mapRange_index (by simp)]\n  set A' := w.support.preimage ((↑) : A → G) injOn_subtype_val\n  erw [Finsupp.sum_subtypeDomain_index hw (h := fun (a : G) (r : ℤ) ↦ ((r : ZMod (n+1)) : ℤ) • a)]\n  refine (Finsupp.sum_congr ?_).symm\n  intro g _\n  generalize w g = r\n  have : ∃ k : ℤ, ((r : ZMod (n+1)) : ℤ) = r + k*(n+1) := by\n    use -(r / (n+1))\n    rw_mod_cast [ZMod.coe_int_cast, Int.mod_eq, sub_eq_add_neg, neg_mul]\n  rcases this with ⟨k, hk⟩\n  rw [hk, add_smul]\n  norm_cast\n  simp only [char_smul_eq_zero', add_zero]\n\n","proof":":= by\n  classical\n  have : Fintype A := Finite.fintype h\n  have : Fintype (A →₀ ZMod (n + 1)) := Finsupp.fintype\n  rw [← Submodule.span_int_eq_addSubgroup_closure, Submodule.coe_toAddSubgroup]\n  let φ : (A →₀ ZMod (n + 1)) → G := fun μ ↦ μ.sum fun a r ↦ (r : ℤ) • (a : G)\n  have : SurjOn φ univ (Submodule.span ℤ A : Set G) := by\n    intro x hx\n    rcases exists_finsupp hx with ⟨μ, hμ⟩\n    use μ, trivial, hμ\n  exact finite_univ.of_surjOn _ this","declId":"PFR.ForMathlib.Elementary.272_0.iFSsvrDJ9DhpmNK","decl":"lemma finite_closure {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} (h : A.Finite) :\n    (AddSubgroup.closure A : Set G).Finite "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\nlemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m := by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']\n\nopen Set\n\nlemma exists_finsupp {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} {x : G} (hx : x ∈ Submodule.span ℤ A) :\n    ∃ μ : A →₀ ZMod (n + 1), (μ.sum fun a r ↦ (r : ℤ) • (a : G)) = x := by\n  rcases mem_span_set.1 hx with ⟨w, hw, rfl⟩; clear hx\n  use (w.subtypeDomain A).mapRange (↑) rfl\n  rw [Finsupp.sum_mapRange_index (by simp)]\n  set A' := w.support.preimage ((↑) : A → G) injOn_subtype_val\n  erw [Finsupp.sum_subtypeDomain_index hw (h := fun (a : G) (r : ℤ) ↦ ((r : ZMod (n+1)) : ℤ) • a)]\n  refine (Finsupp.sum_congr ?_).symm\n  intro g _\n  generalize w g = r\n  have : ∃ k : ℤ, ((r : ZMod (n+1)) : ℤ) = r + k*(n+1) := by\n    use -(r / (n+1))\n    rw_mod_cast [ZMod.coe_int_cast, Int.mod_eq, sub_eq_add_neg, neg_mul]\n  rcases this with ⟨k, hk⟩\n  rw [hk, add_smul]\n  norm_cast\n  simp only [char_smul_eq_zero', add_zero]\n\nlemma finite_closure {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} (h : A.Finite) :\n    (AddSubgroup.closure A : Set G).Finite := by\n  classical\n  have : Fintype A := Finite.fintype h\n  have : Fintype (A →₀ ZMod (n + 1)) := Finsupp.fintype\n  rw [← Submodule.span_int_eq_addSubgroup_closure, Submodule.coe_toAddSubgroup]\n  let φ : (A →₀ ZMod (n + 1)) → G := fun μ ↦ μ.sum fun a r ↦ (r : ℤ) • (a : G)\n  have : SurjOn φ univ (Submodule.span ℤ A : Set G) := by\n    intro x hx\n    rcases exists_finsupp hx with ⟨μ, hμ⟩\n    use μ, trivial, hμ\n  exact finite_univ.of_surjOn _ this\n\n","proof":":= by\n  constructor\n  intro x hx\n  rw [← AddSubgroup.addOrderOf_coe x]\n  apply orderOf_of_ne\n  norm_cast","declId":"PFR.ForMathlib.Elementary.286_0.iFSsvrDJ9DhpmNK","decl":"lemma subgroup {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G n] (H : AddSubgroup G) : ElementaryAddCommGroup H n "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\nlemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m := by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']\n\nopen Set\n\nlemma exists_finsupp {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} {x : G} (hx : x ∈ Submodule.span ℤ A) :\n    ∃ μ : A →₀ ZMod (n + 1), (μ.sum fun a r ↦ (r : ℤ) • (a : G)) = x := by\n  rcases mem_span_set.1 hx with ⟨w, hw, rfl⟩; clear hx\n  use (w.subtypeDomain A).mapRange (↑) rfl\n  rw [Finsupp.sum_mapRange_index (by simp)]\n  set A' := w.support.preimage ((↑) : A → G) injOn_subtype_val\n  erw [Finsupp.sum_subtypeDomain_index hw (h := fun (a : G) (r : ℤ) ↦ ((r : ZMod (n+1)) : ℤ) • a)]\n  refine (Finsupp.sum_congr ?_).symm\n  intro g _\n  generalize w g = r\n  have : ∃ k : ℤ, ((r : ZMod (n+1)) : ℤ) = r + k*(n+1) := by\n    use -(r / (n+1))\n    rw_mod_cast [ZMod.coe_int_cast, Int.mod_eq, sub_eq_add_neg, neg_mul]\n  rcases this with ⟨k, hk⟩\n  rw [hk, add_smul]\n  norm_cast\n  simp only [char_smul_eq_zero', add_zero]\n\nlemma finite_closure {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} (h : A.Finite) :\n    (AddSubgroup.closure A : Set G).Finite := by\n  classical\n  have : Fintype A := Finite.fintype h\n  have : Fintype (A →₀ ZMod (n + 1)) := Finsupp.fintype\n  rw [← Submodule.span_int_eq_addSubgroup_closure, Submodule.coe_toAddSubgroup]\n  let φ : (A →₀ ZMod (n + 1)) → G := fun μ ↦ μ.sum fun a r ↦ (r : ℤ) • (a : G)\n  have : SurjOn φ univ (Submodule.span ℤ A : Set G) := by\n    intro x hx\n    rcases exists_finsupp hx with ⟨μ, hμ⟩\n    use μ, trivial, hμ\n  exact finite_univ.of_surjOn _ this\n\nlemma subgroup {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G n] (H : AddSubgroup G) : ElementaryAddCommGroup H n := by\n  constructor\n  intro x hx\n  rw [← AddSubgroup.addOrderOf_coe x]\n  apply orderOf_of_ne\n  norm_cast\n\ndef smul : ZMod 2 → G → G\n  | 0, _ => 0\n  | 1, x => x\n\n","proof":":= low) module : Module (ZMod 2) G where\n  smul := smul\n  one_smul := fun _ => rfl\n  mul_smul := by\n    intro a b x\n    fin_cases a <;> fin_cases b <;> abel\n  smul_zero := by intro a ; fin_cases a <;> rfl\n  smul_add := by\n    intro a x y\n    fin_cases a\n    · change 0 = 0 + 0 ; simp\n    · rfl\n  add_smul := by\n    intro a b x\n    fin_cases a <;> fin_cases b\n    · simp only [Fin.zero_eta, CharTwo.add_self_eq_zero, ElementaryAddCommGroup.add_self] ; rfl\n    · simp only [Fin.zero_eta, Fin.mk_one, zero_add, self_eq_add_left] ; rfl\n    · simp only [Fin.mk_one, Fin.zero_eta, add_zero, self_eq_add_right] ; rfl\n    · simp only [Fin.mk_one, CharTwo.add_self_eq_zero, ElementaryAddCommGroup.add_self] ; rfl\n  zero_smul := fun _ => rfl","declId":"PFR.ForMathlib.Elementary.298_0.iFSsvrDJ9DhpmNK","decl":"instance (priority "}
{"srcUpToDecl":"import Mathlib.Data.Finsupp.Fintype\nimport Mathlib.LinearAlgebra.Basis.VectorSpace\nimport Mathlib.GroupTheory.Sylow\n\n/-!\n# Finite field vector spaces\n\nHere we define the notion of a vector space over a finite field, and record basic results about it.\n\n## Main classes\n\n* `ElementaryAddCommGroup`: An elementary p-group.\n-/\n\n-- TODO: Find an appropriate home for this section\nsection to_move\n\nsection AddCommMonoid\nvariable {n : ℕ} {M : Type*} [AddCommMonoid M] [Module (ZMod (n + 1)) M]\n\n/- FIXME: n is not unified/inferred -/\n@[coe] def AddSubmonoid.toSubmodule (S : AddSubmonoid M) : Submodule (ZMod (n + 1)) M := by\n  have smul_mem : ∀ (c : ZMod (n + 1)) { x : M }, x ∈ S.carrier → c • x ∈ S.carrier := by\n    intros c _ hx\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, AddSubmonoid.mem_carrier, AddSubmonoid.zero_mem]\n    · rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul] ; exact S.add_mem hc hx\n  exact { S with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubmonoid.coe_toSubmodule (S : AddSubmonoid M) :\n  S.toSubmodule (n := n) = (S : Set M) := rfl\n\ninstance : Coe (AddSubmonoid M) (Submodule (ZMod (n + 1)) M) := ⟨AddSubmonoid.toSubmodule⟩\n\nvariable {M' : Type*} [AddCommMonoid M'] [Module (ZMod (n + 1)) M']\n\n@[coe] def AddMonoidHom.toLinearMap (f : M →+ M') : M →ₗ[ZMod (n + 1)] M' := by\n  have map_smul : ∀ (c : ZMod (n + 1)) (x : M), f (c • x) = c • f x := by\n    intros c _\n    induction' c using Fin.induction with _ hc\n    · simp_rw [zero_smul, map_zero]\n    · simp_rw [← Fin.coeSucc_eq_succ, Module.add_smul, one_smul, f.map_add, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMap (f : M →+ M) :\n  ⇑(f.toLinearMap (n := n)) = f := rfl\n\ninstance : Coe (M →+ M') (M →ₗ[ZMod (n + 1)] M') := ⟨AddMonoidHom.toLinearMap⟩\n\nend AddCommMonoid\n\nsection AddCommGroup\n\nvariable {n : ℕ} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]\n\n@[coe] def AddSubgroup.toSubmodule (H : AddSubgroup G) : Submodule (ZMod n) G := by\n  have smul_mem : ∀ (c : ZMod n) { x : G }, x ∈ H.carrier → c • x ∈ H.carrier := by\n    cases' n with n; swap\n    · exact fun c _ hx ↦ (AddSubmonoid.toSubmodule H.toAddSubmonoid).smul_mem c hx\n    · intros c _ hx\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, AddSubgroup.mem_carrier, AddSubgroup.zero_mem]\n      · simp_rw [Module.add_smul, one_smul, AddSubgroup.mem_carrier, H.add_mem hc hx]\n      · simp_rw [sub_smul, one_smul, AddSubgroup.mem_carrier, H.sub_mem hc hx]\n  exact { H with smul_mem' := smul_mem }\n\n@[simp, norm_cast] theorem AddSubgroup.coe_toSubmodule (H : AddSubgroup G) :\n  H.toSubmodule (n := n) = (H : Set G) := rfl\n\ninstance : Coe (AddSubgroup G) (Submodule (ZMod n) G) := ⟨AddSubgroup.toSubmodule⟩\n\nvariable {G' : Type*} [AddCommGroup G'] [Module (ZMod n) G']\n\n@[coe] def AddMonoidHom.toLinearMapGroup (f : G →+ G') : G →ₗ[ZMod n] G' := by\n  have map_smul : ∀ (c : ZMod n) (x : G), f (c • x) = c • f x := by\n    cases' n with n; swap\n    · exact (AddMonoidHom.toLinearMap f).map_smul\n    · intros c _\n      induction' c using Int.induction_on with _ hc _ hc\n      · simp_rw [zero_smul, map_zero]\n      · simp_rw [Module.add_smul, one_smul, f.map_add, hc]\n      · simp_rw [sub_smul, one_smul, f.map_sub, hc]\n  exact { f with map_smul' := map_smul }\n\n@[simp, norm_cast] theorem AddMonoidHom.coe_toLinearMapGroup (f : G →+ G') :\n  ⇑(f.toLinearMapGroup (n := n)) = f := rfl\n\ninstance : Coe (G →+ G') (G →ₗ[ZMod n] G') := ⟨AddMonoidHom.toLinearMapGroup⟩\n\nend AddCommGroup\nend to_move\n\n\n/-- An elementary `p`-group, i.e., a commutative additive group in which every nonzero element has\norder exactly `p`. -/\nclass ElementaryAddCommGroup (G : Type*) [AddCommGroup G] (p : outParam ℕ) : Prop where\n  orderOf_of_ne {x : G} (hx : x ≠ 0) : addOrderOf x = p\n\nnamespace ElementaryAddCommGroup\n\n@[simp]\nlemma torsion {G: Type*} [AddCommGroup G] (p: ℕ) [elem : ElementaryAddCommGroup G p] (x:G) : p • x = 0 := by\n  by_cases h: x = 0\n  . simp [h]\n  have := elem.orderOf_of_ne h\n  rw [← this]\n  exact addOrderOf_nsmul_eq_zero x\n\nlemma of_torsion {G: Type*} [AddCommGroup G] {p: ℕ} (hp: p.Prime) (h : ∀ x : G, p • x = 0) : ElementaryAddCommGroup G p := by\n  constructor\n  intro x hx\n  have := addOrderOf_dvd_of_nsmul_eq_zero (h x)\n  rw [Nat.dvd_prime hp] at this\n  rcases this with this | this\n  . simp at this; contradiction\n  exact this\n\n\n/-- A vector space over Z/p is an elementary abelian p-group. -/\n-- We can't make this an instance as `p` is not determined.\nlemma ofModule [AddCommGroup G] [Module (ZMod p) G] [Fact p.Prime] :\n    ElementaryAddCommGroup G p where\n  orderOf_of_ne := addOrderOf_eq_prime (Basis.ext_elem (.ofVectorSpace (ZMod p) G) (by simp))\n\n-- We add the special case instance for `p = 2`.\ninstance [AddCommGroup G] [Module (ZMod 2) G] : ElementaryAddCommGroup G 2 := ofModule\n\n/-- In an elementary abelian $p$-group, every finite subgroup $H$ contains a further subgroup of\ncardinality between $k$ and $pk$, if $k \\leq |H|$.-/\nlemma exists_subgroup_subset_card_le {G : Type*} {p : ℕ} (hp : p.Prime)\n    [AddCommGroup G] [h : ElementaryAddCommGroup G p]\n    {k : ℕ} (H : AddSubgroup G) (hk : k ≤ Nat.card H) (h'k : k ≠ 0) :\n    ∃ (H' : AddSubgroup G), Nat.card H' ≤ k ∧ k < p * Nat.card H' ∧ H' ≤ H := by\n  let Gm := Multiplicative G\n  have hm : IsPGroup p Gm := by\n    intro gm\n    rcases eq_or_ne gm 1 with rfl|hg\n    · exact ⟨0, by simp⟩\n    · refine ⟨1, ?_⟩\n      have : Multiplicative.toAdd gm ≠ 0 := hg\n      simpa only [pow_one, h.orderOf_of_ne this] using addOrderOf_nsmul_eq_zero (Multiplicative.toAdd gm)\n  let Hm : Subgroup Gm := AddSubgroup.toSubgroup H\n  obtain ⟨H'm, H'mHm, H'mk, kH'm⟩ := Sylow.exists_subgroup_le_card_le (H := Hm) hp hm hk h'k\n  exact ⟨AddSubgroup.toSubgroup.symm H'm, H'mk, kH'm, H'mHm⟩\n\nvariable [AddCommGroup G] [elem : ElementaryAddCommGroup G 2]\n\n@[simp]\nlemma sub_eq_add ( x y : G ) : x - y = x + y := by\n  rw [sub_eq_add_neg, add_right_inj, ← add_eq_zero_iff_neg_eq]\n  by_cases h : y = 0\n  · simp only [h, add_zero]\n  · simpa only [elem.orderOf_of_ne h, two_nsmul] using (addOrderOf_nsmul_eq_zero y)\n\n@[simp]\nlemma add_self ( x : G ) : x + x = 0 := by\n  rw [← sub_eq_add]\n  simp\n\n\n@[simp]\nlemma neg_eq_self ( x : G ) : - x = x := by\n  simpa [-sub_eq_add] using sub_eq_add 0 x\n\nlemma sum_add_sum_eq_sum ( x y z : G ) : (x + y) + (y + z) = x + z := by\n  rw [← sub_eq_add x y]\n  abel\n\nlemma sum_add_sum_add_sum_eq_zero ( x y z : G ) : (x + y) + (y + z) + (z + x) = 0 := by\n  rw [sum_add_sum_eq_sum, add_comm x z, add_self]\n\nopen Function\n\n@[simp] lemma char_smul_eq_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ) :\n    p • x = 0 := by\n  by_cases hx : x = 0\n  · simp only [hx, smul_zero]\n  · have obs := ElementaryAddCommGroup.orderOf_of_ne hx\n    rw [addOrderOf] at obs\n    simpa only [obs, add_left_iterate, add_zero] using\n      iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\nlemma char_ne_one_of_ne_zero {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] {x : Γ}\n    (x_ne_zero : x ≠ 0) : p ≠ 1 := by\n  have obs := ElementaryAddCommGroup.orderOf_of_ne x_ne_zero\n  rw [addOrderOf] at obs\n  by_contra maybe_one\n  apply x_ne_zero\n  simpa only [obs, maybe_one, iterate_succ, iterate_zero, comp_apply, add_zero, id_eq] using\n    iterate_minimalPeriod (f := fun z ↦ x + z) (x := 0)\n\n@[simp] lemma char_smul_eq_zero' {Γ : Type*} [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] (x : Γ)\n    (k : ℤ) : (k*p) • x = 0 := by\n  rw [mul_smul]\n  norm_cast\n  simp\n\nlemma two_le_char_of_ne_zero {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (x_ne_zero : x ≠ 0) : 2 ≤ p := by\n  by_contra maybe_small\n  have p_le_one : p ≤ 1 := by linarith\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp p_le_one with hp|hp\n  · simp_all only [neZero_zero_iff_false]\n  · exact char_ne_one_of_ne_zero x_ne_zero hp\n\nlemma mem_periodicPts {Γ : Type*} [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p]\n    {x : Γ} (y : Γ) : y ∈ periodicPts (fun z ↦ x + z) := by\n  simp only [periodicPts, IsPeriodicPt, add_left_iterate, Set.mem_setOf_eq]\n  exact ⟨p, Fin.size_pos', by simp [IsFixedPt]⟩\n\nopen Nat in\ninstance (Ω Γ : Type*) (p : ℕ) [NeZero p] [AddCommGroup Γ] [ElementaryAddCommGroup Γ p] :\n    ElementaryAddCommGroup (Ω → Γ) p where\n  orderOf_of_ne := by\n    intro f f_ne_zero\n    have iter_p : (fun x ↦ f + x)^[p] 0 = 0 := by\n      ext ω\n      simp\n    have no_less : ∀ n, 0 < n → n < p → (fun x ↦ f + x)^[n] 0 ≠ 0 := by\n      intro n n_pos n_lt_p\n      apply ne_iff.mpr\n      obtain ⟨ω, hfω⟩ := show ∃ ω, f ω ≠ 0 from ne_iff.mp f_ne_zero\n      existsi ω\n      have obs := ElementaryAddCommGroup.orderOf_of_ne hfω\n      rw [addOrderOf] at obs\n      by_contra con\n      apply not_isPeriodicPt_of_pos_of_lt_minimalPeriod (f := fun x ↦ f ω + x) (x := 0)\n              n_pos.ne.symm (by simpa only [obs] using n_lt_p)\n      simp_rw [IsPeriodicPt, IsFixedPt]\n      convert con\n      simp\n    rw [addOrderOf, minimalPeriod]\n    have mem_pPts : 0 ∈ periodicPts (fun g ↦ f + g) := by\n      rw [periodicPts]\n      existsi p\n      rw [IsPeriodicPt, IsFixedPt]\n      refine ⟨Fin.size_pos', ?_⟩\n      ext ω\n      simp\n    simp only [mem_pPts, gt_iff_lt, dite_true]\n    classical\n    rw [find_eq_iff]\n    refine ⟨⟨Fin.size_pos', iter_p⟩, ?_⟩\n    intro n n_lt_p\n    by_contra con\n    exact no_less n con.1 n_lt_p con.2\n\nlemma Int.mod_eq (n m : ℤ) : n % m = n - (n / m) * m := by\n  rw [eq_sub_iff_add_eq, add_comm, Int.ediv_add_emod']\n\nopen Set\n\nlemma exists_finsupp {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} {x : G} (hx : x ∈ Submodule.span ℤ A) :\n    ∃ μ : A →₀ ZMod (n + 1), (μ.sum fun a r ↦ (r : ℤ) • (a : G)) = x := by\n  rcases mem_span_set.1 hx with ⟨w, hw, rfl⟩; clear hx\n  use (w.subtypeDomain A).mapRange (↑) rfl\n  rw [Finsupp.sum_mapRange_index (by simp)]\n  set A' := w.support.preimage ((↑) : A → G) injOn_subtype_val\n  erw [Finsupp.sum_subtypeDomain_index hw (h := fun (a : G) (r : ℤ) ↦ ((r : ZMod (n+1)) : ℤ) • a)]\n  refine (Finsupp.sum_congr ?_).symm\n  intro g _\n  generalize w g = r\n  have : ∃ k : ℤ, ((r : ZMod (n+1)) : ℤ) = r + k*(n+1) := by\n    use -(r / (n+1))\n    rw_mod_cast [ZMod.coe_int_cast, Int.mod_eq, sub_eq_add_neg, neg_mul]\n  rcases this with ⟨k, hk⟩\n  rw [hk, add_smul]\n  norm_cast\n  simp only [char_smul_eq_zero', add_zero]\n\nlemma finite_closure {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G (n + 1)] {A : Set G} (h : A.Finite) :\n    (AddSubgroup.closure A : Set G).Finite := by\n  classical\n  have : Fintype A := Finite.fintype h\n  have : Fintype (A →₀ ZMod (n + 1)) := Finsupp.fintype\n  rw [← Submodule.span_int_eq_addSubgroup_closure, Submodule.coe_toAddSubgroup]\n  let φ : (A →₀ ZMod (n + 1)) → G := fun μ ↦ μ.sum fun a r ↦ (r : ℤ) • (a : G)\n  have : SurjOn φ univ (Submodule.span ℤ A : Set G) := by\n    intro x hx\n    rcases exists_finsupp hx with ⟨μ, hμ⟩\n    use μ, trivial, hμ\n  exact finite_univ.of_surjOn _ this\n\nlemma subgroup {G : Type*} [AddCommGroup G] {n : ℕ}\n    [ElementaryAddCommGroup G n] (H : AddSubgroup G) : ElementaryAddCommGroup H n := by\n  constructor\n  intro x hx\n  rw [← AddSubgroup.addOrderOf_coe x]\n  apply orderOf_of_ne\n  norm_cast\n\ndef smul : ZMod 2 → G → G\n  | 0, _ => 0\n  | 1, x => x\n\ninstance (priority := low) module : Module (ZMod 2) G where\n  smul := smul\n  one_smul := fun _ => rfl\n  mul_smul := by\n    intro a b x\n    fin_cases a <;> fin_cases b <;> abel\n  smul_zero := by intro a ; fin_cases a <;> rfl\n  smul_add := by\n    intro a x y\n    fin_cases a\n    · change 0 = 0 + 0 ; simp\n    · rfl\n  add_smul := by\n    intro a b x\n    fin_cases a <;> fin_cases b\n    · simp only [Fin.zero_eta, CharTwo.add_self_eq_zero, ElementaryAddCommGroup.add_self] ; rfl\n    · simp only [Fin.zero_eta, Fin.mk_one, zero_add, self_eq_add_left] ; rfl\n    · simp only [Fin.mk_one, Fin.zero_eta, add_zero, self_eq_add_right] ; rfl\n    · simp only [Fin.mk_one, CharTwo.add_self_eq_zero, ElementaryAddCommGroup.add_self] ; rfl\n  zero_smul := fun _ => rfl\n\n\n","proof":":= by\n  apply of_torsion hp\n  intro x\n  rcases QuotientAddGroup.mk'_surjective H x with ⟨y, rfl⟩\n  simp only [QuotientAddGroup.mk'_apply, ← QuotientAddGroup.mk_nsmul, QuotientAddGroup.eq_zero_iff, hH y]","declId":"PFR.ForMathlib.Elementary.320_0.iFSsvrDJ9DhpmNK","decl":"lemma quotient_group {G : Type*} [AddCommGroup G] {p : ℕ} (hp: p.Prime) {H : AddSubgroup G} (hH: ∀ x : G, p • x ∈ H) : ElementaryAddCommGroup (G ⧸ H) p "}
