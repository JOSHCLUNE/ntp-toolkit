{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\n","proof":":= aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp","declId":"PFR.Mathlib.Probability.IdentDistrib.23_0.yB10eruUJPZlil3","decl":"lemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\n","proof":":=\n  (identDistrib_id_left hX).symm","declId":"PFR.Mathlib.Probability.IdentDistrib.28_0.yB10eruUJPZlil3","decl":"lemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n","proof":":= by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]","declId":"PFR.Mathlib.Probability.IdentDistrib.31_0.yB10eruUJPZlil3","decl":"@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n","proof":":= by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable","declId":"PFR.Mathlib.Probability.IdentDistrib.34_0.yB10eruUJPZlil3","decl":"/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n","proof":":= by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable","declId":"PFR.Mathlib.Probability.IdentDistrib.42_0.yB10eruUJPZlil3","decl":"/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\n","proof":":= (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous","declId":"PFR.Mathlib.Probability.IdentDistrib.50_0.yB10eruUJPZlil3","decl":"protected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n","proof":":= (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']","declId":"PFR.Mathlib.Probability.IdentDistrib.72_0.yB10eruUJPZlil3","decl":"/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n","proof":":=\n  (identDistrib_comp_left hi hi' hf).symm","declId":"PFR.Mathlib.Probability.IdentDistrib.80_0.yB10eruUJPZlil3","decl":"/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n","proof":":=\n  (identDistrib_comp_left hi hi' hf).trans hfg","declId":"PFR.Mathlib.Probability.IdentDistrib.88_0.yB10eruUJPZlil3","decl":"/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n","proof":":=\n  hfg.trans $ identDistrib_comp_right hi hi' hg","declId":"PFR.Mathlib.Probability.IdentDistrib.94_0.yB10eruUJPZlil3","decl":"/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n","proof":":= hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]","declId":"PFR.Mathlib.Probability.IdentDistrib.110_0.yB10eruUJPZlil3","decl":"theorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\n","proof":":= hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]","declId":"PFR.Mathlib.Probability.IdentDistrib.109_0.yB10eruUJPZlil3","decl":"variable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n","proof":":=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable","declId":"PFR.Mathlib.Probability.IdentDistrib.121_0.yB10eruUJPZlil3","decl":"@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\n","proof":":=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable","declId":"PFR.Mathlib.Probability.IdentDistrib.120_0.yB10eruUJPZlil3","decl":"variable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n","proof":":= hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX","declId":"PFR.Mathlib.Probability.IdentDistrib.130_0.yB10eruUJPZlil3","decl":"/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\n","proof":":= by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]","declId":"PFR.Mathlib.Probability.IdentDistrib.137_0.yB10eruUJPZlil3","decl":"lemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n","proof":":= hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq","declId":"PFR.Mathlib.Probability.IdentDistrib.149_0.yB10eruUJPZlil3","decl":"/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n","proof":":= (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp","declId":"PFR.Mathlib.Probability.IdentDistrib.167_0.yB10eruUJPZlil3","decl":"/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n","proof":":= (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp","declId":"PFR.Mathlib.Probability.IdentDistrib.177_0.yB10eruUJPZlil3","decl":"/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n","proof":":= by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩","declId":"PFR.Mathlib.Probability.IdentDistrib.187_0.yB10eruUJPZlil3","decl":"/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n","proof":":= by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]","declId":"PFR.Mathlib.Probability.IdentDistrib.199_0.yB10eruUJPZlil3","decl":"/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n","proof":":= by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]","declId":"PFR.Mathlib.Probability.IdentDistrib.217_0.yB10eruUJPZlil3","decl":"/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n","proof":":= by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.IdentDistrib.238_0.yB10eruUJPZlil3","decl":"/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ := by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n","proof":":= by\n  let Ω₁' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_2 u_3 u_4} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_3 u_4} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_4} Ω₃\n  let Ω₄' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_3} Ω₄\n  let Ω : Fin 4 → Type (max u_1 u_2 u_3 u_4) := ![Ω₁', Ω₂', Ω₃', Ω₄']\n  let mΩ : (i : Fin 4) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₄') Fin.rec0\n  let X : (i : Fin 4) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <|\n    Fin.cases (X₃ ∘ ULift.down) <| Fin.cases (X₄ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 4), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <| Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) <| Fin.cases (hX₄.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 4) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <| Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) <| Fin.cases (μ₄.comap ULift.down) Fin.rec0\n  let hμ : (i : Fin 4) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, X' 3, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1, (hX' 3).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans ((identDistrib_ulift_self hX₂).symm),\n    (hX' 2).2.trans ((identDistrib_ulift_self hX₃).symm),\n    (hX' 3).2.trans ((identDistrib_ulift_self hX₄).symm)⟩\n  convert hi; ext i; fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.IdentDistrib.284_0.yB10eruUJPZlil3","decl":"/-- A version with exactly 4 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies4_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂]\n    [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂]\n    [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄] :\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n    Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧\n    IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧\n    IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ := by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- A version with exactly 4 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies4_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂]\n    [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂]\n    [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄] :\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n    Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧\n    IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧\n    IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ := by\n  let Ω₁' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_2 u_3 u_4} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_3 u_4} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_4} Ω₃\n  let Ω₄' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_3} Ω₄\n  let Ω : Fin 4 → Type (max u_1 u_2 u_3 u_4) := ![Ω₁', Ω₂', Ω₃', Ω₄']\n  let mΩ : (i : Fin 4) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₄') Fin.rec0\n  let X : (i : Fin 4) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <|\n    Fin.cases (X₃ ∘ ULift.down) <| Fin.cases (X₄ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 4), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <| Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) <| Fin.cases (hX₄.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 4) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <| Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) <| Fin.cases (μ₄.comap ULift.down) Fin.rec0\n  let hμ : (i : Fin 4) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, X' 3, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1, (hX' 3).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans ((identDistrib_ulift_self hX₂).symm),\n    (hX' 2).2.trans ((identDistrib_ulift_self hX₃).symm),\n    (hX' 3).2.trans ((identDistrib_ulift_self hX₄).symm)⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n","proof":":= by\n  set A := FiniteRange.toFinset X₀\n  classical\n  let X' (ω : Ω) : S := if (X ω ∈ A) then X ω else hS.some\n  use X'\n  constructor\n  . exact Measurable.ite (MeasurableSet.preimage (Finset.measurableSet A) hX) hX measurable_const\n  constructor\n  . apply finiteRange_of_finset X' (A ∪ {hS.some})\n    intro ω\n    simp\n    by_cases h: X ω ∈ A\n    . left; simp at h; simp [h]\n    right; intro ω₀ hω₀; rw [← hω₀] at h\n    simp at h\n  apply Filter.eventuallyEq_of_mem (s := X ⁻¹' A)\n  . simp [ae]\n    rw [← Set.preimage_compl, ← IdentDistrib.measure_preimage_eq hi]\n    . convert measure_empty\n      ext ω\n      simp\n    measurability\n  intro ω\n  simp; tauto","declId":"PFR.Mathlib.Probability.IdentDistrib.334_0.yB10eruUJPZlil3","decl":"/-- If `X` has identical distribution to `X₀`, and `X₀` has finite range, then `X` is almost everywhere equivalent to a random variable of finite range. -/\nlemma identDistrib_of_finiteRange {Ω Ω₀ S : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω₀] [MeasurableSpace S] [MeasurableSingletonClass S] [hS: Nonempty S] {μ: Measure Ω} {μ₀: Measure Ω₀} {X₀: Ω₀ → S} [FiniteRange X₀] {X : Ω → S} (hX: Measurable X) (hi : IdentDistrib X₀ X μ₀ μ) : ∃ X' : Ω → S, Measurable X' ∧ FiniteRange X' ∧ X' =ᵐ[μ] X "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ := by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- A version with exactly 4 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies4_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂]\n    [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂]\n    [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄] :\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n    Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧\n    IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧\n    IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ := by\n  let Ω₁' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_2 u_3 u_4} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_3 u_4} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_4} Ω₃\n  let Ω₄' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_3} Ω₄\n  let Ω : Fin 4 → Type (max u_1 u_2 u_3 u_4) := ![Ω₁', Ω₂', Ω₃', Ω₄']\n  let mΩ : (i : Fin 4) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₄') Fin.rec0\n  let X : (i : Fin 4) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <|\n    Fin.cases (X₃ ∘ ULift.down) <| Fin.cases (X₄ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 4), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <| Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) <| Fin.cases (hX₄.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 4) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <| Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) <| Fin.cases (μ₄.comap ULift.down) Fin.rec0\n  let hμ : (i : Fin 4) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, X' 3, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1, (hX' 3).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans ((identDistrib_ulift_self hX₂).symm),\n    (hX' 2).2.trans ((identDistrib_ulift_self hX₃).symm),\n    (hX' 3).2.trans ((identDistrib_ulift_self hX₄).symm)⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- If `X` has identical distribution to `X₀`, and `X₀` has finite range, then `X` is almost everywhere equivalent to a random variable of finite range. -/\nlemma identDistrib_of_finiteRange {Ω Ω₀ S : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω₀] [MeasurableSpace S] [MeasurableSingletonClass S] [hS: Nonempty S] {μ: Measure Ω} {μ₀: Measure Ω₀} {X₀: Ω₀ → S} [FiniteRange X₀] {X : Ω → S} (hX: Measurable X) (hi : IdentDistrib X₀ X μ₀ μ) : ∃ X' : Ω → S, Measurable X' ∧ FiniteRange X' ∧ X' =ᵐ[μ] X := by\n  set A := FiniteRange.toFinset X₀\n  classical\n  let X' (ω : Ω) : S := if (X ω ∈ A) then X ω else hS.some\n  use X'\n  constructor\n  . exact Measurable.ite (MeasurableSet.preimage (Finset.measurableSet A) hX) hX measurable_const\n  constructor\n  . apply finiteRange_of_finset X' (A ∪ {hS.some})\n    intro ω\n    simp\n    by_cases h: X ω ∈ A\n    . left; simp at h; simp [h]\n    right; intro ω₀ hω₀; rw [← hω₀] at h\n    simp at h\n  apply Filter.eventuallyEq_of_mem (s := X ⁻¹' A)\n  . simp [ae]\n    rw [← Set.preimage_compl, ← IdentDistrib.measure_preimage_eq hi]\n    . convert measure_empty\n      ext ω\n      simp\n    measurability\n  intro ω\n  simp; tauto\n\n","proof":":= by\n  obtain ⟨ν, X', Y', hν, hX', hY', hind, hIdX, hIdY⟩ := independent_copies hX hY μ μ'\n  rcases identDistrib_of_finiteRange hX' hIdX.symm with ⟨X'', hX'', hX''_finite, hX''_eq⟩\n  rcases identDistrib_of_finiteRange hY' hIdY.symm with ⟨Y'', hY'', hY''_finite, hY''_eq⟩\n  use ν, X'', Y''\n  refine ⟨hν, hX'', hY'', ?_, ?_, ?_, hX''_finite, hY''_finite⟩\n  . exact IndepFun.ae_eq' hind hX''_eq.symm hY''_eq.symm\n  . convert IdentDistrib.trans _ hIdX\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX'') hX''_eq\n  . convert IdentDistrib.trans _ hIdY\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hY'') hY''_eq","declId":"PFR.Mathlib.Probability.IdentDistrib.360_0.yB10eruUJPZlil3","decl":"/-- A version of `independent_copies` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies_finiteRange {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y]   [MeasurableSingletonClass α] [Nonempty α] [MeasurableSingletonClass β] [Nonempty β]\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃\n    Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' ∧ FiniteRange X' ∧ FiniteRange Y'  "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ := by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- A version with exactly 4 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies4_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂]\n    [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂]\n    [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄] :\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n    Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧\n    IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧\n    IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ := by\n  let Ω₁' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_2 u_3 u_4} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_3 u_4} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_4} Ω₃\n  let Ω₄' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_3} Ω₄\n  let Ω : Fin 4 → Type (max u_1 u_2 u_3 u_4) := ![Ω₁', Ω₂', Ω₃', Ω₄']\n  let mΩ : (i : Fin 4) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₄') Fin.rec0\n  let X : (i : Fin 4) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <|\n    Fin.cases (X₃ ∘ ULift.down) <| Fin.cases (X₄ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 4), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <| Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) <| Fin.cases (hX₄.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 4) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <| Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) <| Fin.cases (μ₄.comap ULift.down) Fin.rec0\n  let hμ : (i : Fin 4) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, X' 3, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1, (hX' 3).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans ((identDistrib_ulift_self hX₂).symm),\n    (hX' 2).2.trans ((identDistrib_ulift_self hX₃).symm),\n    (hX' 3).2.trans ((identDistrib_ulift_self hX₄).symm)⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- If `X` has identical distribution to `X₀`, and `X₀` has finite range, then `X` is almost everywhere equivalent to a random variable of finite range. -/\nlemma identDistrib_of_finiteRange {Ω Ω₀ S : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω₀] [MeasurableSpace S] [MeasurableSingletonClass S] [hS: Nonempty S] {μ: Measure Ω} {μ₀: Measure Ω₀} {X₀: Ω₀ → S} [FiniteRange X₀] {X : Ω → S} (hX: Measurable X) (hi : IdentDistrib X₀ X μ₀ μ) : ∃ X' : Ω → S, Measurable X' ∧ FiniteRange X' ∧ X' =ᵐ[μ] X := by\n  set A := FiniteRange.toFinset X₀\n  classical\n  let X' (ω : Ω) : S := if (X ω ∈ A) then X ω else hS.some\n  use X'\n  constructor\n  . exact Measurable.ite (MeasurableSet.preimage (Finset.measurableSet A) hX) hX measurable_const\n  constructor\n  . apply finiteRange_of_finset X' (A ∪ {hS.some})\n    intro ω\n    simp\n    by_cases h: X ω ∈ A\n    . left; simp at h; simp [h]\n    right; intro ω₀ hω₀; rw [← hω₀] at h\n    simp at h\n  apply Filter.eventuallyEq_of_mem (s := X ⁻¹' A)\n  . simp [ae]\n    rw [← Set.preimage_compl, ← IdentDistrib.measure_preimage_eq hi]\n    . convert measure_empty\n      ext ω\n      simp\n    measurability\n  intro ω\n  simp; tauto\n\n/-- A version of `independent_copies` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies_finiteRange {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y]   [MeasurableSingletonClass α] [Nonempty α] [MeasurableSingletonClass β] [Nonempty β]\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃\n    Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' ∧ FiniteRange X' ∧ FiniteRange Y'  := by\n  obtain ⟨ν, X', Y', hν, hX', hY', hind, hIdX, hIdY⟩ := independent_copies hX hY μ μ'\n  rcases identDistrib_of_finiteRange hX' hIdX.symm with ⟨X'', hX'', hX''_finite, hX''_eq⟩\n  rcases identDistrib_of_finiteRange hY' hIdY.symm with ⟨Y'', hY'', hY''_finite, hY''_eq⟩\n  use ν, X'', Y''\n  refine ⟨hν, hX'', hY'', ?_, ?_, ?_, hX''_finite, hY''_finite⟩\n  . exact IndepFun.ae_eq' hind hX''_eq.symm hY''_eq.symm\n  . convert IdentDistrib.trans _ hIdX\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX'') hX''_eq\n  . convert IdentDistrib.trans _ hIdY\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hY'') hY''_eq\n\n","proof":":= by\n    obtain ⟨A, mA, μA, X₁', X₂', X₃', hμA, hind, hX₁, hX₂, hX₃, hId₁, hId₂, hId₃⟩ := independent_copies3_nondep hX₁ hX₂ hX₃ μ₁ μ₂ μ₃\n    rcases identDistrib_of_finiteRange hX₁ hId₁.symm with ⟨X₁'', hX₁'', hX₁''_finite, hX₁''_eq⟩\n    rcases identDistrib_of_finiteRange hX₂ hId₂.symm with ⟨X₂'', hX₂'', hX₂''_finite, hX₂''_eq⟩\n    rcases identDistrib_of_finiteRange hX₃ hId₃.symm with ⟨X₃'', hX₃'', hX₃''_finite, hX₃''_eq⟩\n    use A, mA, μA, X₁'', X₂'', X₃''\n    refine ⟨hμA, ?_, hX₁'', hX₂'', hX₃'', ?_, ?_, ?_, hX₁''_finite, hX₂''_finite, hX₃''_finite⟩\n    . apply iIndepFun.ae_eq hind\n      intro i; fin_cases i\n      all_goals simp [hX₁''_eq.symm, hX₂''_eq.symm, hX₃''_eq.symm]\n    . convert IdentDistrib.trans _ hId₁\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₁'') hX₁''_eq\n    . convert IdentDistrib.trans _ hId₂\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₂'') hX₂''_eq\n    convert IdentDistrib.trans _ hId₃\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₃'') hX₃''_eq","declId":"PFR.Mathlib.Probability.IdentDistrib.378_0.yB10eruUJPZlil3","decl":"/-- A version of `independent_copies3_nondep` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies3_nondep_finiteRange {α : Type u}\n    [mS : MeasurableSpace α] [MeasurableSingletonClass α] [Nonempty α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    [FiniteRange X₁] [FiniteRange X₂] [FiniteRange X₃]\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ ∧ FiniteRange X₁' ∧ FiniteRange X₂' ∧ FiniteRange X₃' "}
{"srcUpToDecl":"import Mathlib.Probability.IdentDistrib\nimport PFR.Mathlib.Data.Fin.Basic\nimport PFR.Mathlib.MeasureTheory.Constructions.Pi\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Independence.Basic\nimport PFR.ForMathlib.FiniteRange\n\n-- TODO: Change `ae_snd` to assume `Measurable p`\n\nnoncomputable section\n\nopen MeasureTheory Measure Filter Set\nopen scoped Topology BigOperators MeasureTheory ENNReal NNReal\n\nvariable {α β γ δ : Type*} [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]\n  [MeasurableSpace δ]\n\nnamespace ProbabilityTheory\nvariable {μ : Measure α} {ν : Measure β} {f f' : α → γ} {g g' : β → γ} {s : Set γ}\n\nattribute [mk_iff] IdentDistrib\n\nlemma identDistrib_id_left {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib id X (μ.map X) μ where\n  aemeasurable_fst := aemeasurable_id\n  aemeasurable_snd := hX\n  map_eq := by simp\n\nlemma identDistrib_id_right {X : α → β} (hX : AEMeasurable X μ) : IdentDistrib X id μ (μ.map X) :=\n  (identDistrib_id_left hX).symm\n\n@[simp] lemma identDistrib_id {μ ν : Measure α} : IdentDistrib id id μ ν ↔ μ = ν := by\n  simp [identDistrib_iff id id μ ν, aemeasurable_id]\n\n/-- The first projection in a product space with measure `μ.prod ν` is distributed like `μ`. -/\nlemma IdentDistrib.fst_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.fst id (μ.prod ν) μ := by\n  have : μ = (μ.prod ν).map Prod.fst := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_fst.aemeasurable\n\n/-- The second projection in a product space with measure `μ.prod ν` is distributed like `ν`. -/\nlemma IdentDistrib.snd_id\n    {μ : Measure α} {ν : Measure β} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    IdentDistrib Prod.snd id (μ.prod ν) ν := by\n  have : ν = (μ.prod ν).map Prod.snd := by simp\n  nth_rewrite 2 [this]\n  exact identDistrib_id_right measurable_snd.aemeasurable\n\nprotected lemma IdentDistrib.cond (hs : MeasurableSet s) (hf' : Measurable f') (hg' : Measurable g')\n    (hfg : IdentDistrib (fun a ↦ (f a, f' a)) (fun b ↦ (g b, g' b)) μ ν) :\n    IdentDistrib f g (μ[|f' ⁻¹' s]) (ν[|g' ⁻¹' s]) where\n  aemeasurable_fst := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_fst).mono_ac\n    cond_absolutelyContinuous\n  aemeasurable_snd := (measurable_fst.aemeasurable.comp_aemeasurable hfg.aemeasurable_snd).mono_ac\n    cond_absolutelyContinuous\n  map_eq := by\n    ext t ht\n    rw [map_apply₀ _ ht.nullMeasurableSet, map_apply₀ _ ht.nullMeasurableSet,\n      cond_apply _ (hg' hs), cond_apply _ (hf' hs)]\n    congr\n    · simpa only [map_apply₀ (hfg.comp measurable_snd).aemeasurable_fst hs.nullMeasurableSet,\n        map_apply₀ (hfg.comp measurable_snd).aemeasurable_snd hs.nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) (hfg.comp measurable_snd).map_eq) s\n    · rw [inter_comm, inter_comm (g' ⁻¹' _)]\n      simpa only [map_apply₀ hfg.aemeasurable_fst (ht.prod hs).nullMeasurableSet,\n        map_apply₀ hfg.aemeasurable_snd (ht.prod hs).nullMeasurableSet]\n        using congr_fun (congr_arg (⇑) hfg.map_eq) (t ×ˢ s)\n    · exact (hfg.comp measurable_fst).aemeasurable_snd.mono_ac cond_absolutelyContinuous\n    · exact (hfg.comp measurable_fst).aemeasurable_fst.mono_ac cond_absolutelyContinuous\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib (f ∘ i) f (μ.comap i) μ where\n  aemeasurable_fst := (hf.comp hi.measurable).aemeasurable\n  aemeasurable_snd := hf.aemeasurable\n  map_eq := by rw [← Measure.map_map hf hi.measurable, hi.map_comap, restrict_eq_self_of_ae_mem hi']\n\n/-- A function is identically distributed to itself composed with a measurable embedding of conull\nrange. -/\nlemma identDistrib_comp_right {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) : IdentDistrib f (f ∘ i) μ (μ.comap i) :=\n  (identDistrib_comp_left hi hi' hf).symm\n\n-- TODO: Can we get rid of the measurability assumption in the following two?\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/docs.23MeasureTheory.2EMeasure.2Emap_map\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_left {i : δ → α} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂μ, a ∈ range i)\n    (hf : Measurable f) (hfg : IdentDistrib f g μ ν) : IdentDistrib (f ∘ i) g (μ.comap i) ν :=\n  (identDistrib_comp_left hi hi' hf).trans hfg\n\n/-- Composing identically distributed functions with a measurable embedding of conull range\ngives identically distributed functions. -/\nlemma IdentDistrib.comp_right {i : δ → β} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ a ∂ν, a ∈ range i)\n    (hg : Measurable g) (hfg : IdentDistrib f g μ ν) : IdentDistrib f (g ∘ i) μ (ν.comap i) :=\n  hfg.trans $ identDistrib_comp_right hi hi' hg\n\nend ProbabilityTheory\n\nopen MeasureTheory ProbabilityTheory Function Set BigOperators\n\nnamespace ProbabilityTheory\nsection IdentDistrib\nvariable {Ω Ω' α ι β β' : Type*} {mΩ : MeasurableSpace Ω} {mΩ' : MeasurableSpace Ω'}\n  {mβ : MeasurableSpace β} {μ : Measure Ω} {ν : Measure Ω'} {f g : Ω → β} {f' g' : Ω' → β}\n\nvariable [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\ntheorem IdentDistrib.prod_mk (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (fun x ↦ (f x, g x)) (fun x ↦ (f' x, g' x)) μ ν where\n  aemeasurable_fst := hff'.aemeasurable_fst.prod_mk hgg'.aemeasurable_fst\n  aemeasurable_snd := hff'.aemeasurable_snd.prod_mk hgg'.aemeasurable_snd\n  map_eq := by\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_fst hgg'.aemeasurable_fst] at h\n    rw [indepFun_iff_map_prod_eq_prod_map_map' hff'.aemeasurable_snd hgg'.aemeasurable_snd] at h'\n    rw [h, h', hff'.map_eq, hgg'.map_eq]\n\nvariable [Mul β] [MeasurableMul₂ β] [IsFiniteMeasure μ] [IsFiniteMeasure ν] in\n@[to_additive]\ntheorem IdentDistrib.mul\n    (hff' : IdentDistrib f f' μ ν) (hgg' : IdentDistrib g g' μ ν)\n    (h : IndepFun f g μ) (h' : IndepFun f' g' ν) :\n    IdentDistrib (f * g) (f' * g') μ ν :=\n  hff'.prod_mk hgg' h h' |>.comp_of_aemeasurable measurable_mul.aemeasurable\n\nvariable [MeasurableSpace α] [MeasurableSpace β]\n\n/-- A random variable is identically distributed to its pullbacks. -/\nlemma identDistrib_map {X : Ω → α} (hX : Measurable X) {f : α → β} (hf : Measurable f)\n    (μ : Measure Ω) : IdentDistrib f (f ∘ X) (μ.map X) μ where\n  aemeasurable_fst := hf.aemeasurable\n  aemeasurable_snd := (hf.comp hX).aemeasurable\n  map_eq := map_map hf hX\n\nlemma identDistrib_ulift_self {X : Ω → α} (hX : Measurable X) :\n    IdentDistrib X (X ∘ ULift.down) μ (μ.comap ULift.down) := by\n  have hX' : Measurable (X ∘ ULift.down : ULift Ω → α) := hX.comp measurable_down\n  refine' ⟨hX.aemeasurable, hX'.aemeasurable, _⟩\n  ext s hs\n  rw [Measure.map_apply (μ := (μ.comap ULift.down)) hX' hs,\n    Measure.comap_apply _ ULift.down_injective _ _ (hX' hs), Set.preimage_comp,\n    Set.image_preimage_eq _ ULift.down_surjective, Measure.map_apply hX hs]\n  intro s hs\n  change MeasurableSet (ULift.down ⁻¹' (ULift.down '' s))\n  rwa [Set.preimage_image_eq _ ULift.down_injective]\n\n/-- To show identical distribution of two random variables on a mixture of probability measures, it suffices to do so on each non-trivial component. -/\n-- in fact this is an if and only if\nlemma identDistrib_of_sum {X : Ω → α} {Y : Ω' → α} [Fintype T] {μ : T → Measure Ω}\n    {μ' : T → Measure Ω'} {w : T → ENNReal} (hX : Measurable X) (hY : Measurable Y)\n    (h_ident : ∀ y, w y ≠ 0 → IdentDistrib X Y (μ y) (μ' y)) :\n    IdentDistrib X Y (∑ y : T, (w y) • (μ y)) (∑ y : T, (w y) • (μ' y)) where\n  aemeasurable_fst := hX.aemeasurable\n  aemeasurable_snd := hY.aemeasurable\n  map_eq := by\n    rw [← Measure.mapₗ_apply_of_measurable hX, ← Measure.mapₗ_apply_of_measurable hY]\n    simp\n    congr with y E _\n    rcases eq_or_ne (w y) 0 with hy | hy\n    . simp [hy]\n    congr 3\n    rw [Measure.mapₗ_apply_of_measurable hX, Measure.mapₗ_apply_of_measurable hY]\n    exact (h_ident y hy).map_eq\n\n/-- A random variable is identically distributed to its lift to a product space (in the first factor). -/\nlemma identDistrib_comp_fst {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.fst) X (μ.prod μ') μ where\n  aemeasurable_fst := (hX.comp measurable_fst).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_fst, Measure.map_fst_prod]\n    congr\n    simp\n\n/-- A random variable is identically distributed to its lift to a product space (in the second factor). -/\nlemma identDistrib_comp_snd {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) (μ' : Measure Ω')\n  [SigmaFinite μ][IsProbabilityMeasure μ'] : IdentDistrib (X ∘ Prod.snd) X (μ'.prod μ) μ where\n  aemeasurable_fst := (hX.comp measurable_snd).aemeasurable\n  aemeasurable_snd := hX.aemeasurable\n  map_eq := by\n    rw [← Measure.map_map hX measurable_snd, Measure.map_snd_prod]\n    congr\n    simp\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. -/\nlemma independent_copies {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃ Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' := by\n  have := MeasureTheory.isProbabilityMeasure_map hX.aemeasurable (μ := μ)\n  have := MeasureTheory.isProbabilityMeasure_map hY.aemeasurable (μ := μ')\n  exact ⟨(μ.map X).prod (μ'.map Y), _, _, inferInstance, measurable_fst, measurable_snd,\n    indepFun_fst_snd, ⟨measurable_fst.aemeasurable, hX.aemeasurable, by simp⟩,\n    measurable_snd.aemeasurable, hY.aemeasurable, by simp⟩\n\n/-- For $X, Y$ random variables, one can find independent copies $X', Y'$ of $X, Y$. Version\nformulated in spaces with a canonical measures. -/\nlemma independent_copies_two {Ω : Type u} {Ω' : Type v} [MeasureSpace Ω] [MeasureSpace Ω']\n    [IsProbabilityMeasure (ℙ : Measure Ω)] [IsProbabilityMeasure (ℙ : Measure Ω')]\n    {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) :\n    ∃ (Ω'' : Type (max u v)) (m'' : MeasureSpace Ω'') (X' : Ω'' → α) (Y' : Ω'' → β),\n    IsProbabilityMeasure (ℙ : Measure Ω'') ∧ Measurable X' ∧ Measurable Y' ∧\n      IndepFun X' Y' ∧ IdentDistrib X' X ∧ IdentDistrib Y' Y := by\n  refine ⟨Ω × Ω', by infer_instance, X ∘ Prod.fst, Y ∘ Prod.snd, by infer_instance,\n    hX.comp measurable_fst, hY.comp measurable_snd, ?_, ?_, ?_⟩\n  · exact indepFun_fst_snd.comp hX hY\n  · refine ⟨(hX.comp measurable_fst).aemeasurable, hX.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hX measurable_fst, this]\n  · refine ⟨(hY.comp measurable_snd).aemeasurable, hY.aemeasurable, ?_⟩\n    have : (ℙ : Measure (Ω × Ω')) = (ℙ : Measure Ω).prod (ℙ : Measure Ω') := rfl\n    simp [← Measure.map_map hY measurable_snd, this]\n\n/-- Let $X_i : \\Omega_i \\to S_i$ be random variables for $i=1,\\dots,k$.\nThen there exist jointly independent random variables $X'_i : \\Omega' \\to S_i$ for $i=1,\\dots,k$\nsuch that each $X'_i$ is a copy of $X_i$. -/\nlemma independent_copies' {I : Type u} [Fintype I] {α : I → Type u'}\n    [mS : ∀ i : I, MeasurableSpace (α i)] {Ω : I → Type v}\n    [mΩ : ∀ i : I, MeasurableSpace (Ω i)] (X : ∀ i : I, Ω i → α i) (hX : ∀ i : I, Measurable (X i))\n    (μ : ∀ i : I, Measure (Ω i)) [∀ i, IsProbabilityMeasure (μ i)] :\n    ∃ (A : Type (max u v)) (mA : MeasurableSpace A) (μA : Measure A) (X' : ∀ i, A → α i),\n    IsProbabilityMeasure μA ∧\n    iIndepFun mS X' μA ∧\n    ∀ i : I, Measurable (X' i) ∧ IdentDistrib (X' i) (X i) μA (μ i) := by\n  refine ⟨Π i, Ω i, inferInstance, .pi μ, fun i ↦ X i ∘ eval i, inferInstance, ?_, fun i ↦ ⟨?_, ?_⟩⟩\n  · rw [iIndepFun_iff]\n    intro t s hs\n    choose! u _ hus using hs\n    simp (config := {contextual := true}) [← hus, preimage_comp]\n    simp_rw [← Finset.mem_coe, ← Set.pi_def, pi_pi_finset]\n  · exact (hX i).comp (measurable_pi_apply i)\n  · refine ⟨(hX i).comp (measurable_pi_apply i) |>.aemeasurable, (hX i).aemeasurable, ?_⟩\n    rw [← Measure.map_map (hX i) (measurable_pi_apply i), Measure.map_eval_pi]\n\n/-- A version with exactly 3 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies3_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ := by\n  let Ω₁' : Type (max u_1 u_2 u_3) := ULift.{max u_2 u_3} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_3} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3) := ULift.{max u_1 u_2} Ω₃\n  let Ω : Fin 3 → Type (max u_1 u_2 u_3) := ![Ω₁', Ω₂', Ω₃']\n  let mΩ : (i : Fin 3) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') Fin.rec0\n  let X : (i : Fin 3) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <| Fin.cases (X₃ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 3), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <|\n    Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 3) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <|\n    Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) Fin.rec0\n  have hμ : (i : Fin 3) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans (identDistrib_ulift_self hX₂).symm,\n    (hX' 2).2.trans (identDistrib_ulift_self hX₃).symm⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- A version with exactly 4 random variables that have the same codomain.\nIt's unfortunately incredibly painful to prove this from the general case. -/\nlemma independent_copies4_nondep {α : Type u}\n    [mS : MeasurableSpace α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [mΩ₁ : MeasurableSpace Ω₁] [mΩ₂ : MeasurableSpace Ω₂]\n    [mΩ₃ : MeasurableSpace Ω₃] [mΩ₄ : MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂]\n    [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄] :\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n    Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧\n    IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧\n    IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ := by\n  let Ω₁' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_2 u_3 u_4} Ω₁\n  let Ω₂' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_3 u_4} Ω₂\n  let Ω₃' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_4} Ω₃\n  let Ω₄' : Type (max u_1 u_2 u_3 u_4) := ULift.{max u_1 u_2 u_3} Ω₄\n  let Ω : Fin 4 → Type (max u_1 u_2 u_3 u_4) := ![Ω₁', Ω₂', Ω₃', Ω₄']\n  let mΩ : (i : Fin 4) → MeasurableSpace (Ω i) :=\n    Fin.cases (inferInstance : MeasurableSpace Ω₁') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₂') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₃') <|\n    Fin.cases (inferInstance : MeasurableSpace Ω₄') Fin.rec0\n  let X : (i : Fin 4) → Ω i → α :=\n    Fin.cases (X₁ ∘ ULift.down) <| Fin.cases (X₂ ∘ ULift.down) <|\n    Fin.cases (X₃ ∘ ULift.down) <| Fin.cases (X₄ ∘ ULift.down) Fin.rec0\n  have hX : ∀ (i : Fin 4), @Measurable _ _ (mΩ i) mS (X i) :=\n    Fin.cases (hX₁.comp measurable_down) <| Fin.cases (hX₂.comp measurable_down) <|\n    Fin.cases (hX₃.comp measurable_down) <| Fin.cases (hX₄.comp measurable_down) Fin.rec0\n  let μ : (i : Fin 4) → @Measure (Ω i) (mΩ i) :=\n    Fin.cases (μ₁.comap ULift.down) <| Fin.cases (μ₂.comap ULift.down) <|\n    Fin.cases (μ₃.comap ULift.down) <| Fin.cases (μ₄.comap ULift.down) Fin.rec0\n  let hμ : (i : Fin 4) → IsProbabilityMeasure (μ i) :=\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down <|\n    Fin.cases isProbabilityMeasure_comap_down <| Fin.cases isProbabilityMeasure_comap_down Fin.rec0\n  obtain ⟨A, mA, μA, X', hμ, hi, hX'⟩ := independent_copies' X hX μ\n  refine ⟨A, mA, μA, X' 0, X' 1, X' 2, X' 3, hμ, ?_,\n    (hX' 0).1, (hX' 1).1, (hX' 2).1, (hX' 3).1,\n    (hX' 0).2.trans ((identDistrib_ulift_self hX₁).symm),\n    (hX' 1).2.trans ((identDistrib_ulift_self hX₂).symm),\n    (hX' 2).2.trans ((identDistrib_ulift_self hX₃).symm),\n    (hX' 3).2.trans ((identDistrib_ulift_self hX₄).symm)⟩\n  convert hi; ext i; fin_cases i <;> rfl\n\n/-- If `X` has identical distribution to `X₀`, and `X₀` has finite range, then `X` is almost everywhere equivalent to a random variable of finite range. -/\nlemma identDistrib_of_finiteRange {Ω Ω₀ S : Type*} [MeasurableSpace Ω] [MeasurableSpace Ω₀] [MeasurableSpace S] [MeasurableSingletonClass S] [hS: Nonempty S] {μ: Measure Ω} {μ₀: Measure Ω₀} {X₀: Ω₀ → S} [FiniteRange X₀] {X : Ω → S} (hX: Measurable X) (hi : IdentDistrib X₀ X μ₀ μ) : ∃ X' : Ω → S, Measurable X' ∧ FiniteRange X' ∧ X' =ᵐ[μ] X := by\n  set A := FiniteRange.toFinset X₀\n  classical\n  let X' (ω : Ω) : S := if (X ω ∈ A) then X ω else hS.some\n  use X'\n  constructor\n  . exact Measurable.ite (MeasurableSet.preimage (Finset.measurableSet A) hX) hX measurable_const\n  constructor\n  . apply finiteRange_of_finset X' (A ∪ {hS.some})\n    intro ω\n    simp\n    by_cases h: X ω ∈ A\n    . left; simp at h; simp [h]\n    right; intro ω₀ hω₀; rw [← hω₀] at h\n    simp at h\n  apply Filter.eventuallyEq_of_mem (s := X ⁻¹' A)\n  . simp [ae]\n    rw [← Set.preimage_compl, ← IdentDistrib.measure_preimage_eq hi]\n    . convert measure_empty\n      ext ω\n      simp\n    measurability\n  intro ω\n  simp; tauto\n\n/-- A version of `independent_copies` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies_finiteRange {X : Ω → α} {Y : Ω' → β} (hX : Measurable X) (hY : Measurable Y) [FiniteRange X] [FiniteRange Y]   [MeasurableSingletonClass α] [Nonempty α] [MeasurableSingletonClass β] [Nonempty β]\n    (μ : Measure Ω) (μ' : Measure Ω') [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    ∃ ν : Measure (α × β), ∃ X' : α × β → α, ∃\n    Y' : α × β → β, IsProbabilityMeasure ν\n      ∧ Measurable X' ∧ Measurable Y' ∧ IndepFun X' Y' ν\n      ∧ IdentDistrib X' X ν μ ∧ IdentDistrib Y' Y ν μ' ∧ FiniteRange X' ∧ FiniteRange Y'  := by\n  obtain ⟨ν, X', Y', hν, hX', hY', hind, hIdX, hIdY⟩ := independent_copies hX hY μ μ'\n  rcases identDistrib_of_finiteRange hX' hIdX.symm with ⟨X'', hX'', hX''_finite, hX''_eq⟩\n  rcases identDistrib_of_finiteRange hY' hIdY.symm with ⟨Y'', hY'', hY''_finite, hY''_eq⟩\n  use ν, X'', Y''\n  refine ⟨hν, hX'', hY'', ?_, ?_, ?_, hX''_finite, hY''_finite⟩\n  . exact IndepFun.ae_eq' hind hX''_eq.symm hY''_eq.symm\n  . convert IdentDistrib.trans _ hIdX\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX'') hX''_eq\n  . convert IdentDistrib.trans _ hIdY\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hY'') hY''_eq\n\n/-- A version of `independent_copies3_nondep` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies3_nondep_finiteRange {α : Type u}\n    [mS : MeasurableSpace α] [MeasurableSingletonClass α] [Nonempty α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃)\n    [FiniteRange X₁] [FiniteRange X₂] [FiniteRange X₃]\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] :\n    ∃ (A : Type (max u_1 u_2 u_3)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧\n      IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ ∧ FiniteRange X₁' ∧ FiniteRange X₂' ∧ FiniteRange X₃' := by\n    obtain ⟨A, mA, μA, X₁', X₂', X₃', hμA, hind, hX₁, hX₂, hX₃, hId₁, hId₂, hId₃⟩ := independent_copies3_nondep hX₁ hX₂ hX₃ μ₁ μ₂ μ₃\n    rcases identDistrib_of_finiteRange hX₁ hId₁.symm with ⟨X₁'', hX₁'', hX₁''_finite, hX₁''_eq⟩\n    rcases identDistrib_of_finiteRange hX₂ hId₂.symm with ⟨X₂'', hX₂'', hX₂''_finite, hX₂''_eq⟩\n    rcases identDistrib_of_finiteRange hX₃ hId₃.symm with ⟨X₃'', hX₃'', hX₃''_finite, hX₃''_eq⟩\n    use A, mA, μA, X₁'', X₂'', X₃''\n    refine ⟨hμA, ?_, hX₁'', hX₂'', hX₃'', ?_, ?_, ?_, hX₁''_finite, hX₂''_finite, hX₃''_finite⟩\n    . apply iIndepFun.ae_eq hind\n      intro i; fin_cases i\n      all_goals simp [hX₁''_eq.symm, hX₂''_eq.symm, hX₃''_eq.symm]\n    . convert IdentDistrib.trans _ hId₁\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₁'') hX₁''_eq\n    . convert IdentDistrib.trans _ hId₂\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₂'') hX₂''_eq\n    convert IdentDistrib.trans _ hId₃\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₃'') hX₃''_eq\n\n","proof":":= by\n    obtain ⟨A, mA, μA, X₁', X₂', X₃', X₄', hμA, hind, hX₁, hX₂, hX₃, hX₄, hId₁, hId₂, hId₃, hId₄⟩ := independent_copies4_nondep hX₁ hX₂ hX₃ hX₄ μ₁ μ₂ μ₃ μ₄\n    rcases identDistrib_of_finiteRange hX₁ hId₁.symm with ⟨X₁'', hX₁'', hX₁''_finite, hX₁''_eq⟩\n    rcases identDistrib_of_finiteRange hX₂ hId₂.symm with ⟨X₂'', hX₂'', hX₂''_finite, hX₂''_eq⟩\n    rcases identDistrib_of_finiteRange hX₃ hId₃.symm with ⟨X₃'', hX₃'', hX₃''_finite, hX₃''_eq⟩\n    rcases identDistrib_of_finiteRange hX₄ hId₄.symm with ⟨X₄'', hX₄'', hX₄''_finite, hX₄''_eq⟩\n    use A, mA, μA, X₁'', X₂'', X₃'', X₄''\n    refine ⟨hμA, ?_, hX₁'', hX₂'', hX₃'', hX₄'', ?_, ?_, ?_, ?_, hX₁''_finite, hX₂''_finite, hX₃''_finite, hX₄''_finite⟩\n    . apply iIndepFun.ae_eq hind\n      intro i; fin_cases i\n      all_goals simp [hX₁''_eq.symm, hX₂''_eq.symm, hX₃''_eq.symm, hX₄''_eq.symm]\n    . convert IdentDistrib.trans _ hId₁\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₁'') hX₁''_eq\n    . convert IdentDistrib.trans _ hId₂\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₂'') hX₂''_eq\n    . convert IdentDistrib.trans _ hId₃\n      exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₃'') hX₃''_eq\n    convert IdentDistrib.trans _ hId₄\n    exact IdentDistrib.of_ae_eq (Measurable.aemeasurable hX₄'') hX₄''_eq","declId":"PFR.Mathlib.Probability.IdentDistrib.410_0.yB10eruUJPZlil3","decl":"/-- A version of `independent_copies4_nondep` that guarantees that the copies have `FiniteRange` if the original variables do. -/\nlemma independent_copies4_nondep_finiteRange {α : Type u}\n    [mS : MeasurableSpace α] [MeasurableSingletonClass α] [Nonempty α]\n    {Ω₁ : Type u_1} {Ω₂ : Type u_2} {Ω₃ : Type u_3} {Ω₄ : Type u_4}\n    [MeasurableSpace Ω₁] [MeasurableSpace Ω₂] [MeasurableSpace Ω₃] [MeasurableSpace Ω₄]\n    {X₁ : Ω₁ → α} {X₂ : Ω₂ → α} {X₃ : Ω₃ → α} {X₄ : Ω₄ → α}\n    (hX₁ : Measurable X₁) (hX₂ : Measurable X₂) (hX₃ : Measurable X₃) (hX₄ : Measurable X₄)\n    [FiniteRange X₁] [FiniteRange X₂] [FiniteRange X₃] [FiniteRange X₄]\n    (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) (μ₃ : Measure Ω₃) (μ₄ : Measure Ω₄)\n    [hμ₁ : IsProbabilityMeasure μ₁] [hμ₂ : IsProbabilityMeasure μ₂] [hμ₃ : IsProbabilityMeasure μ₃] [hμ₄ : IsProbabilityMeasure μ₄]:\n    ∃ (A : Type (max u_1 u_2 u_3 u_4)) (mA : MeasurableSpace A) (μA : Measure A)\n      (X₁' X₂' X₃' X₄' : A → α),\n    IsProbabilityMeasure μA ∧\n    iIndepFun (fun _ ↦ mS) ![X₁', X₂', X₃', X₄'] μA ∧\n      Measurable X₁' ∧ Measurable X₂' ∧ Measurable X₃' ∧ Measurable X₄' ∧ IdentDistrib X₁' X₁ μA μ₁ ∧ IdentDistrib X₂' X₂ μA μ₂ ∧ IdentDistrib X₃' X₃ μA μ₃ ∧ IdentDistrib X₄' X₄ μA μ₄ ∧ FiniteRange X₁' ∧ FiniteRange X₂' ∧ FiniteRange X₃' ∧ FiniteRange X₄' "}
