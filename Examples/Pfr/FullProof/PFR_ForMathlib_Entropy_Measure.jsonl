{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n","proof":":= by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal","declId":"PFR.ForMathlib.Entropy.Measure.38_0.KBK7AD4u6u7sJBr","decl":"/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.Measure.49_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\n","proof":":= by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]","declId":"PFR.ForMathlib.Entropy.Measure.52_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n","proof":":= by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)","declId":"PFR.ForMathlib.Entropy.Measure.61_0.KBK7AD4u6u7sJBr","decl":"/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\n","proof":":=\n  hμ.finite.choose","declId":"PFR.ForMathlib.Entropy.Measure.65_0.KBK7AD4u6u7sJBr","decl":"noncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\n","proof":":= hμ.finite.choose_spec","declId":"PFR.ForMathlib.Entropy.Measure.69_0.KBK7AD4u6u7sJBr","decl":"lemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\n","proof":":= ⟨(∅ : Finset S), by simp⟩","declId":"PFR.ForMathlib.Entropy.Measure.72_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n","proof":":= by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0","declId":"PFR.ForMathlib.Entropy.Measure.75_0.KBK7AD4u6u7sJBr","decl":"/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\n","proof":":= by\n  use Finset.univ\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.80_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\n","proof":":= by\n  use μ.support\n  simp [measure_compl_support]","declId":"PFR.ForMathlib.Entropy.Measure.84_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\n","proof":":= by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x","declId":"PFR.ForMathlib.Entropy.Measure.89_0.KBK7AD4u6u7sJBr","decl":"lemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\n","proof":":= by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]","declId":"PFR.ForMathlib.Entropy.Measure.97_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n","proof":":= by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.101_0.KBK7AD4u6u7sJBr","decl":"/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\n","proof":":= by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X","declId":"PFR.ForMathlib.Entropy.Measure.112_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\n","proof":":= by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]","declId":"PFR.ForMathlib.Entropy.Measure.117_0.KBK7AD4u6u7sJBr","decl":"lemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\n","proof":":= by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this","declId":"PFR.ForMathlib.Entropy.Measure.126_0.KBK7AD4u6u7sJBr","decl":"lemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\n","proof":":= by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)","declId":"PFR.ForMathlib.Entropy.Measure.132_0.KBK7AD4u6u7sJBr","decl":"instance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n","proof":":= by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable","declId":"PFR.ForMathlib.Entropy.Measure.138_0.KBK7AD4u6u7sJBr","decl":"/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\n","proof":":= by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]","declId":"PFR.ForMathlib.Entropy.Measure.171_0.KBK7AD4u6u7sJBr","decl":"lemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n","proof":":= by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]","declId":"PFR.ForMathlib.Entropy.Measure.181_0.KBK7AD4u6u7sJBr","decl":"/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\n","proof":":= by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]","declId":"PFR.ForMathlib.Entropy.Measure.210_0.KBK7AD4u6u7sJBr","decl":"theorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\n","proof":":= by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa","declId":"PFR.ForMathlib.Entropy.Measure.221_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\n","proof":":= by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]","declId":"PFR.ForMathlib.Entropy.Measure.230_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n","proof":":= by simp [measureEntropy]","declId":"PFR.ForMathlib.Entropy.Measure.237_0.KBK7AD4u6u7sJBr","decl":"@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n","proof":":= by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]","declId":"PFR.ForMathlib.Entropy.Measure.240_0.KBK7AD4u6u7sJBr","decl":"@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\n","proof":":= by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]","declId":"PFR.ForMathlib.Entropy.Measure.251_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\n","proof":":= by\n  simp [measureEntropy]","declId":"PFR.ForMathlib.Entropy.Measure.254_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\n","proof":":=\n  measureEntropy_of_isProbabilityMeasure μ","declId":"PFR.ForMathlib.Entropy.Measure.258_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\n","proof":":= by\n  rw [measureEntropy_def_finite hA]\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.262_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\n","proof":":=\n  measureEntropy_of_isProbabilityMeasure_finite hA","declId":"PFR.ForMathlib.Entropy.Measure.268_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\n","proof":":= by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _","declId":"PFR.ForMathlib.Entropy.Measure.273_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\n","proof":":= by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one","declId":"PFR.ForMathlib.Entropy.Measure.291_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\n","proof":":= by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']","declId":"PFR.ForMathlib.Entropy.Measure.303_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\n","proof":":= by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp","declId":"PFR.ForMathlib.Entropy.Measure.334_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\n","proof":":= by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.360_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\n","proof":":= by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A","declId":"PFR.ForMathlib.Entropy.Measure.369_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\n","proof":":= by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl","declId":"PFR.ForMathlib.Entropy.Measure.384_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\n","proof":":= by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl","declId":"PFR.ForMathlib.Entropy.Measure.390_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\n","proof":":= by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness","declId":"PFR.ForMathlib.Entropy.Measure.401_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\n","proof":":= by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff","declId":"PFR.ForMathlib.Entropy.Measure.415_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\n","proof":":= by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective","declId":"PFR.ForMathlib.Entropy.Measure.440_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\n","proof":":= by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]","declId":"PFR.ForMathlib.Entropy.Measure.466_0.KBK7AD4u6u7sJBr","decl":"lemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n","proof":":= by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring","declId":"PFR.ForMathlib.Entropy.Measure.473_0.KBK7AD4u6u7sJBr","decl":"/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n","proof":":= by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]","declId":"PFR.ForMathlib.Entropy.Measure.509_0.KBK7AD4u6u7sJBr","decl":"/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.Measure.517_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n","proof":":= by\n  simp [measureMutualInfo]","declId":"PFR.ForMathlib.Entropy.Measure.523_0.KBK7AD4u6u7sJBr","decl":"@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\n","proof":":= by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective","declId":"PFR.ForMathlib.Entropy.Measure.527_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n","proof":":= by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.544_0.KBK7AD4u6u7sJBr","decl":"@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 := by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp\n\n","proof":":= by\n  have : IsProbabilityMeasure (μ.map Prod.fst) :=\n    isProbabilityMeasure_map measurable_fst.aemeasurable\n  have : IsProbabilityMeasure (μ.map Prod.snd) :=\n    isProbabilityMeasure_map measurable_snd.aemeasurable\n  let E := μ.support\n  have hE := measure_compl_support μ\n  classical\n  set E1 : Finset S := Finset.image Prod.fst E\n  set E2 : Finset U := Finset.image Prod.snd E\n  have hE' : μ (E1 ×ˢ E2 : Finset (S × U))ᶜ = 0 := by\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    contrapose!\n    intro h\n    simp at h ⊢\n    constructor; use u; use s\n  have hE1 : (μ.map Prod.fst) E1ᶜ = 0 := by\n    rw [Measure.map_apply measurable_fst (MeasurableSet.compl (Finset.measurableSet E1))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use u\n  have hE1' : (μ.map Prod.fst).real E1 = 1 := by\n    suffices : (μ.map Prod.fst) E1 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E1)] at hE1\n    . simp at hE1; convert hE1; simp\n    exact measure_ne_top _ _\n  have hE2 : (μ.map Prod.snd) E2ᶜ = 0 := by\n    rw [Measure.map_apply measurable_snd (MeasurableSet.compl (Finset.measurableSet E2))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use s\n  have hE2' : (μ.map Prod.snd).real E2 = 1 := by\n    suffices : (μ.map Prod.snd) E2 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E2)] at hE2\n    . simp at hE2; convert hE2; simp\n    exact measure_ne_top _ _\n  have h_fst_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.fst).real {p.1} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h_snd_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.snd).real {p.2} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h1 y : (μ.map Prod.fst).real {y} = ∑ z in E2, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; exact h1; use s\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.1\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  have h2 z : (μ.map Prod.snd).real {z} = ∑ y in E1, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; use u; exact h1\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.2\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  let w (p : S × U) := (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}\n  let f (p : S × U) := ((μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2})⁻¹ * μ.real {p}\n  have hw1 : ∀ p ∈ (E1 ×ˢ E2), 0 ≤ w p := by intros; positivity\n  have hw2 : ∑ p in (E1 ×ˢ E2), w p = 1 := by\n    rw [Finset.sum_product]\n    simp [← Finset.mul_sum]\n    rw [← Finset.sum_mul]\n    rw [show (1:ℝ) = 1 * 1 by norm_num]\n    congr\n    . convert hE1'; simp\n    convert hE2'; simp\n  have hf : ∀ p ∈ E1 ×ˢ E2, 0 ≤ f p := by intros; positivity\n  have H :=\n  calc\n    ∑ p in (E1 ×ˢ E2), w p * f p\n        = ∑ p in (E1 ×ˢ E2), μ.real {p} := by\n          congr with p\n          by_cases hp : μ.real {p} = 0\n          · simp [hp]\n          field_simp [h_fst_ne_zero p hp, h_snd_ne_zero p hp]\n          ring\n      _ = 1 := by\n        simp\n        rw [show 1 = μ.real Set.univ by simp]\n        apply measureReal_congr\n        simp\n        convert hE'\n        simp\n  have H1 : -measureMutualInfo (μ := μ) = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p) :=\n  calc\n    _ = ∑ p in (E1 ×ˢ E2),\n          (-(μ.real {p} * log (μ.real {p}))\n          + (μ.real {p} * log ((μ.map Prod.snd).real {p.2})\n            + μ.real {p} * log ((μ.map Prod.fst).real {p.1}))) := by\n        have H0 : Hm[μ] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log (μ.real {p})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE', negMulLog, neg_mul, Finset.sum_neg_distrib]\n          rfl\n        have H1 : Hm[μ.map Prod.fst] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.fst).real {p.1})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE1, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product, ← Finset.sum_mul]\n          congr! with s _\n          exact h1 s\n        have H2 : Hm[μ.map Prod.snd] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.snd).real {p.2})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE2, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product_right, ← Finset.sum_mul]\n          congr! with s _\n          exact h2 s\n        simp_rw [measureMutualInfo_def, H0, H1, H2]\n        simp [Finset.sum_add_distrib]\n    _ = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p)\n    := by\n        congr! 1 with p _\n        by_cases hp : μ.real {p} = 0\n        · simp [hp]\n        have := h_fst_ne_zero p hp\n        have := h_snd_ne_zero p hp\n        rw [negMulLog, log_mul, log_inv, log_mul]\n        · field_simp\n          ring\n        all_goals positivity\n  have H2 : 0 = negMulLog (∑ s in (E1 ×ˢ E2), w s * f s) := by\n    rw [H, negMulLog_one]\n  constructor\n  · rw [← neg_nonpos, H1]\n    convert sum_negMulLog_le (s := E1 ×ˢ E2) hw1 hw2 hf\n  rw [← neg_eq_zero, H1, H2, sum_negMulLog_eq_iff' hw1 hw2 hf]\n  have w0 (p : S × U) (hp: w p = 0) : μ.real {p} = 0 := by\n    simp at hp\n    rcases hp with hp | hp\n    . contrapose! hp; exact (h_fst_ne_zero p) hp\n    contrapose! hp; exact (h_snd_ne_zero p) hp\n  constructor\n  . intro hyp p\n    by_cases hp1 : p.1 ∈ E1\n    . by_cases hp2 : p.2 ∈ E2\n      . have hp : p ∈ E1 ×ˢ E2 := Finset.mem_product.mpr ⟨hp1, hp2⟩\n        by_cases hw : w p = 0\n        . rw [w0 p hw]\n          exact hw.symm\n        replace hyp := hyp p hp hw\n        rw [H] at hyp\n        have := inv_mul_eq_one₀' hyp\n        convert this.symm\n      have : {p.2} ⊆ (E2 : Set U)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp2\n      replace : (Measure.map Prod.snd μ).real {p.2} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE2\n      have hp : μ.real {p} = 0 := by contrapose! this; exact (h_snd_ne_zero p) this\n      simp [hp, this]\n    have : {p.1} ⊆ (E1 : Set S)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp1\n    replace : (Measure.map Prod.fst μ).real {p.1} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE1\n    have hp : μ.real {p} = 0 := by contrapose! this; exact (h_fst_ne_zero p) this\n    simp [hp, this]\n  intro hyp ⟨s, u⟩ _ hw\n  rw [H]\n  show (w (s,u))⁻¹ * (μ.real {(s,u)}) = 1\n  have : w (s,u) ≠ 0 := by exact hw\n  field_simp [this]\n  rw [hyp (s,u)]","declId":"PFR.ForMathlib.Entropy.Measure.551_0.KBK7AD4u6u7sJBr","decl":"/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\nlemma measureMutualInfo_nonneg_aux {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    0 ≤ Im[μ] ∧\n    (Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}) "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 := by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\nlemma measureMutualInfo_nonneg_aux {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    0 ≤ Im[μ] ∧\n    (Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}) := by\n  have : IsProbabilityMeasure (μ.map Prod.fst) :=\n    isProbabilityMeasure_map measurable_fst.aemeasurable\n  have : IsProbabilityMeasure (μ.map Prod.snd) :=\n    isProbabilityMeasure_map measurable_snd.aemeasurable\n  let E := μ.support\n  have hE := measure_compl_support μ\n  classical\n  set E1 : Finset S := Finset.image Prod.fst E\n  set E2 : Finset U := Finset.image Prod.snd E\n  have hE' : μ (E1 ×ˢ E2 : Finset (S × U))ᶜ = 0 := by\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    contrapose!\n    intro h\n    simp at h ⊢\n    constructor; use u; use s\n  have hE1 : (μ.map Prod.fst) E1ᶜ = 0 := by\n    rw [Measure.map_apply measurable_fst (MeasurableSet.compl (Finset.measurableSet E1))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use u\n  have hE1' : (μ.map Prod.fst).real E1 = 1 := by\n    suffices : (μ.map Prod.fst) E1 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E1)] at hE1\n    . simp at hE1; convert hE1; simp\n    exact measure_ne_top _ _\n  have hE2 : (μ.map Prod.snd) E2ᶜ = 0 := by\n    rw [Measure.map_apply measurable_snd (MeasurableSet.compl (Finset.measurableSet E2))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use s\n  have hE2' : (μ.map Prod.snd).real E2 = 1 := by\n    suffices : (μ.map Prod.snd) E2 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E2)] at hE2\n    . simp at hE2; convert hE2; simp\n    exact measure_ne_top _ _\n  have h_fst_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.fst).real {p.1} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h_snd_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.snd).real {p.2} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h1 y : (μ.map Prod.fst).real {y} = ∑ z in E2, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; exact h1; use s\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.1\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  have h2 z : (μ.map Prod.snd).real {z} = ∑ y in E1, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; use u; exact h1\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.2\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  let w (p : S × U) := (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}\n  let f (p : S × U) := ((μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2})⁻¹ * μ.real {p}\n  have hw1 : ∀ p ∈ (E1 ×ˢ E2), 0 ≤ w p := by intros; positivity\n  have hw2 : ∑ p in (E1 ×ˢ E2), w p = 1 := by\n    rw [Finset.sum_product]\n    simp [← Finset.mul_sum]\n    rw [← Finset.sum_mul]\n    rw [show (1:ℝ) = 1 * 1 by norm_num]\n    congr\n    . convert hE1'; simp\n    convert hE2'; simp\n  have hf : ∀ p ∈ E1 ×ˢ E2, 0 ≤ f p := by intros; positivity\n  have H :=\n  calc\n    ∑ p in (E1 ×ˢ E2), w p * f p\n        = ∑ p in (E1 ×ˢ E2), μ.real {p} := by\n          congr with p\n          by_cases hp : μ.real {p} = 0\n          · simp [hp]\n          field_simp [h_fst_ne_zero p hp, h_snd_ne_zero p hp]\n          ring\n      _ = 1 := by\n        simp\n        rw [show 1 = μ.real Set.univ by simp]\n        apply measureReal_congr\n        simp\n        convert hE'\n        simp\n  have H1 : -measureMutualInfo (μ := μ) = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p) :=\n  calc\n    _ = ∑ p in (E1 ×ˢ E2),\n          (-(μ.real {p} * log (μ.real {p}))\n          + (μ.real {p} * log ((μ.map Prod.snd).real {p.2})\n            + μ.real {p} * log ((μ.map Prod.fst).real {p.1}))) := by\n        have H0 : Hm[μ] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log (μ.real {p})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE', negMulLog, neg_mul, Finset.sum_neg_distrib]\n          rfl\n        have H1 : Hm[μ.map Prod.fst] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.fst).real {p.1})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE1, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product, ← Finset.sum_mul]\n          congr! with s _\n          exact h1 s\n        have H2 : Hm[μ.map Prod.snd] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.snd).real {p.2})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE2, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product_right, ← Finset.sum_mul]\n          congr! with s _\n          exact h2 s\n        simp_rw [measureMutualInfo_def, H0, H1, H2]\n        simp [Finset.sum_add_distrib]\n    _ = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p)\n    := by\n        congr! 1 with p _\n        by_cases hp : μ.real {p} = 0\n        · simp [hp]\n        have := h_fst_ne_zero p hp\n        have := h_snd_ne_zero p hp\n        rw [negMulLog, log_mul, log_inv, log_mul]\n        · field_simp\n          ring\n        all_goals positivity\n  have H2 : 0 = negMulLog (∑ s in (E1 ×ˢ E2), w s * f s) := by\n    rw [H, negMulLog_one]\n  constructor\n  · rw [← neg_nonpos, H1]\n    convert sum_negMulLog_le (s := E1 ×ˢ E2) hw1 hw2 hf\n  rw [← neg_eq_zero, H1, H2, sum_negMulLog_eq_iff' hw1 hw2 hf]\n  have w0 (p : S × U) (hp: w p = 0) : μ.real {p} = 0 := by\n    simp at hp\n    rcases hp with hp | hp\n    . contrapose! hp; exact (h_fst_ne_zero p) hp\n    contrapose! hp; exact (h_snd_ne_zero p) hp\n  constructor\n  . intro hyp p\n    by_cases hp1 : p.1 ∈ E1\n    . by_cases hp2 : p.2 ∈ E2\n      . have hp : p ∈ E1 ×ˢ E2 := Finset.mem_product.mpr ⟨hp1, hp2⟩\n        by_cases hw : w p = 0\n        . rw [w0 p hw]\n          exact hw.symm\n        replace hyp := hyp p hp hw\n        rw [H] at hyp\n        have := inv_mul_eq_one₀' hyp\n        convert this.symm\n      have : {p.2} ⊆ (E2 : Set U)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp2\n      replace : (Measure.map Prod.snd μ).real {p.2} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE2\n      have hp : μ.real {p} = 0 := by contrapose! this; exact (h_snd_ne_zero p) this\n      simp [hp, this]\n    have : {p.1} ⊆ (E1 : Set S)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp1\n    replace : (Measure.map Prod.fst μ).real {p.1} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE1\n    have hp : μ.real {p} = 0 := by contrapose! this; exact (h_fst_ne_zero p) this\n    simp [hp, this]\n  intro hyp ⟨s, u⟩ _ hw\n  rw [H]\n  show (w (s,u))⁻¹ * (μ.real {(s,u)}) = 1\n  have : w (s,u) ≠ 0 := by exact hw\n  field_simp [this]\n  rw [hyp (s,u)]\n\n","proof":":= by\n  rw [measureMutualInfo_def]\n  have h1 : ¬ IsFiniteMeasure (μ.map Prod.fst) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  have h2 : ¬ IsFiniteMeasure (μ.map Prod.snd) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  rw [measureEntropy_of_not_isFiniteMeasure h, measureEntropy_of_not_isFiniteMeasure h1,\n    measureEntropy_of_not_isFiniteMeasure h2]\n  simp","declId":"PFR.ForMathlib.Entropy.Measure.744_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_of_not_isFiniteMeasure {μ : Measure (S × U)} (h : ¬ IsFiniteMeasure μ) :\n    Im[μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 := by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\nlemma measureMutualInfo_nonneg_aux {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    0 ≤ Im[μ] ∧\n    (Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}) := by\n  have : IsProbabilityMeasure (μ.map Prod.fst) :=\n    isProbabilityMeasure_map measurable_fst.aemeasurable\n  have : IsProbabilityMeasure (μ.map Prod.snd) :=\n    isProbabilityMeasure_map measurable_snd.aemeasurable\n  let E := μ.support\n  have hE := measure_compl_support μ\n  classical\n  set E1 : Finset S := Finset.image Prod.fst E\n  set E2 : Finset U := Finset.image Prod.snd E\n  have hE' : μ (E1 ×ˢ E2 : Finset (S × U))ᶜ = 0 := by\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    contrapose!\n    intro h\n    simp at h ⊢\n    constructor; use u; use s\n  have hE1 : (μ.map Prod.fst) E1ᶜ = 0 := by\n    rw [Measure.map_apply measurable_fst (MeasurableSet.compl (Finset.measurableSet E1))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use u\n  have hE1' : (μ.map Prod.fst).real E1 = 1 := by\n    suffices : (μ.map Prod.fst) E1 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E1)] at hE1\n    . simp at hE1; convert hE1; simp\n    exact measure_ne_top _ _\n  have hE2 : (μ.map Prod.snd) E2ᶜ = 0 := by\n    rw [Measure.map_apply measurable_snd (MeasurableSet.compl (Finset.measurableSet E2))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use s\n  have hE2' : (μ.map Prod.snd).real E2 = 1 := by\n    suffices : (μ.map Prod.snd) E2 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E2)] at hE2\n    . simp at hE2; convert hE2; simp\n    exact measure_ne_top _ _\n  have h_fst_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.fst).real {p.1} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h_snd_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.snd).real {p.2} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h1 y : (μ.map Prod.fst).real {y} = ∑ z in E2, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; exact h1; use s\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.1\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  have h2 z : (μ.map Prod.snd).real {z} = ∑ y in E1, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; use u; exact h1\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.2\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  let w (p : S × U) := (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}\n  let f (p : S × U) := ((μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2})⁻¹ * μ.real {p}\n  have hw1 : ∀ p ∈ (E1 ×ˢ E2), 0 ≤ w p := by intros; positivity\n  have hw2 : ∑ p in (E1 ×ˢ E2), w p = 1 := by\n    rw [Finset.sum_product]\n    simp [← Finset.mul_sum]\n    rw [← Finset.sum_mul]\n    rw [show (1:ℝ) = 1 * 1 by norm_num]\n    congr\n    . convert hE1'; simp\n    convert hE2'; simp\n  have hf : ∀ p ∈ E1 ×ˢ E2, 0 ≤ f p := by intros; positivity\n  have H :=\n  calc\n    ∑ p in (E1 ×ˢ E2), w p * f p\n        = ∑ p in (E1 ×ˢ E2), μ.real {p} := by\n          congr with p\n          by_cases hp : μ.real {p} = 0\n          · simp [hp]\n          field_simp [h_fst_ne_zero p hp, h_snd_ne_zero p hp]\n          ring\n      _ = 1 := by\n        simp\n        rw [show 1 = μ.real Set.univ by simp]\n        apply measureReal_congr\n        simp\n        convert hE'\n        simp\n  have H1 : -measureMutualInfo (μ := μ) = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p) :=\n  calc\n    _ = ∑ p in (E1 ×ˢ E2),\n          (-(μ.real {p} * log (μ.real {p}))\n          + (μ.real {p} * log ((μ.map Prod.snd).real {p.2})\n            + μ.real {p} * log ((μ.map Prod.fst).real {p.1}))) := by\n        have H0 : Hm[μ] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log (μ.real {p})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE', negMulLog, neg_mul, Finset.sum_neg_distrib]\n          rfl\n        have H1 : Hm[μ.map Prod.fst] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.fst).real {p.1})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE1, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product, ← Finset.sum_mul]\n          congr! with s _\n          exact h1 s\n        have H2 : Hm[μ.map Prod.snd] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.snd).real {p.2})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE2, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product_right, ← Finset.sum_mul]\n          congr! with s _\n          exact h2 s\n        simp_rw [measureMutualInfo_def, H0, H1, H2]\n        simp [Finset.sum_add_distrib]\n    _ = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p)\n    := by\n        congr! 1 with p _\n        by_cases hp : μ.real {p} = 0\n        · simp [hp]\n        have := h_fst_ne_zero p hp\n        have := h_snd_ne_zero p hp\n        rw [negMulLog, log_mul, log_inv, log_mul]\n        · field_simp\n          ring\n        all_goals positivity\n  have H2 : 0 = negMulLog (∑ s in (E1 ×ˢ E2), w s * f s) := by\n    rw [H, negMulLog_one]\n  constructor\n  · rw [← neg_nonpos, H1]\n    convert sum_negMulLog_le (s := E1 ×ˢ E2) hw1 hw2 hf\n  rw [← neg_eq_zero, H1, H2, sum_negMulLog_eq_iff' hw1 hw2 hf]\n  have w0 (p : S × U) (hp: w p = 0) : μ.real {p} = 0 := by\n    simp at hp\n    rcases hp with hp | hp\n    . contrapose! hp; exact (h_fst_ne_zero p) hp\n    contrapose! hp; exact (h_snd_ne_zero p) hp\n  constructor\n  . intro hyp p\n    by_cases hp1 : p.1 ∈ E1\n    . by_cases hp2 : p.2 ∈ E2\n      . have hp : p ∈ E1 ×ˢ E2 := Finset.mem_product.mpr ⟨hp1, hp2⟩\n        by_cases hw : w p = 0\n        . rw [w0 p hw]\n          exact hw.symm\n        replace hyp := hyp p hp hw\n        rw [H] at hyp\n        have := inv_mul_eq_one₀' hyp\n        convert this.symm\n      have : {p.2} ⊆ (E2 : Set U)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp2\n      replace : (Measure.map Prod.snd μ).real {p.2} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE2\n      have hp : μ.real {p} = 0 := by contrapose! this; exact (h_snd_ne_zero p) this\n      simp [hp, this]\n    have : {p.1} ⊆ (E1 : Set S)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp1\n    replace : (Measure.map Prod.fst μ).real {p.1} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE1\n    have hp : μ.real {p} = 0 := by contrapose! this; exact (h_fst_ne_zero p) this\n    simp [hp, this]\n  intro hyp ⟨s, u⟩ _ hw\n  rw [H]\n  show (w (s,u))⁻¹ * (μ.real {(s,u)}) = 1\n  have : w (s,u) ≠ 0 := by exact hw\n  field_simp [this]\n  rw [hyp (s,u)]\n\nlemma measureMutualInfo_of_not_isFiniteMeasure {μ : Measure (S × U)} (h : ¬ IsFiniteMeasure μ) :\n    Im[μ] = 0 := by\n  rw [measureMutualInfo_def]\n  have h1 : ¬ IsFiniteMeasure (μ.map Prod.fst) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  have h2 : ¬ IsFiniteMeasure (μ.map Prod.snd) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  rw [measureEntropy_of_not_isFiniteMeasure h, measureEntropy_of_not_isFiniteMeasure h1,\n    measureEntropy_of_not_isFiniteMeasure h2]\n  simp\n\n","proof":":= by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureMutualInfo_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  rcases eq_zero_or_neZero μ with hμ | _\n  . simp [hμ]\n  rw [measureMutualInfo_def, measureMutualInfo_def]\n  congr 1; congr 1\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  convert measureEntropy_univ_smul","declId":"PFR.ForMathlib.Entropy.Measure.759_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_univ_smul (μ : Measure (S × U)) : Im[(μ Set.univ)⁻¹ • μ] = Im[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 := by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\nlemma measureMutualInfo_nonneg_aux {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    0 ≤ Im[μ] ∧\n    (Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}) := by\n  have : IsProbabilityMeasure (μ.map Prod.fst) :=\n    isProbabilityMeasure_map measurable_fst.aemeasurable\n  have : IsProbabilityMeasure (μ.map Prod.snd) :=\n    isProbabilityMeasure_map measurable_snd.aemeasurable\n  let E := μ.support\n  have hE := measure_compl_support μ\n  classical\n  set E1 : Finset S := Finset.image Prod.fst E\n  set E2 : Finset U := Finset.image Prod.snd E\n  have hE' : μ (E1 ×ˢ E2 : Finset (S × U))ᶜ = 0 := by\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    contrapose!\n    intro h\n    simp at h ⊢\n    constructor; use u; use s\n  have hE1 : (μ.map Prod.fst) E1ᶜ = 0 := by\n    rw [Measure.map_apply measurable_fst (MeasurableSet.compl (Finset.measurableSet E1))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use u\n  have hE1' : (μ.map Prod.fst).real E1 = 1 := by\n    suffices : (μ.map Prod.fst) E1 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E1)] at hE1\n    . simp at hE1; convert hE1; simp\n    exact measure_ne_top _ _\n  have hE2 : (μ.map Prod.snd) E2ᶜ = 0 := by\n    rw [Measure.map_apply measurable_snd (MeasurableSet.compl (Finset.measurableSet E2))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use s\n  have hE2' : (μ.map Prod.snd).real E2 = 1 := by\n    suffices : (μ.map Prod.snd) E2 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E2)] at hE2\n    . simp at hE2; convert hE2; simp\n    exact measure_ne_top _ _\n  have h_fst_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.fst).real {p.1} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h_snd_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.snd).real {p.2} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h1 y : (μ.map Prod.fst).real {y} = ∑ z in E2, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; exact h1; use s\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.1\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  have h2 z : (μ.map Prod.snd).real {z} = ∑ y in E1, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; use u; exact h1\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.2\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  let w (p : S × U) := (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}\n  let f (p : S × U) := ((μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2})⁻¹ * μ.real {p}\n  have hw1 : ∀ p ∈ (E1 ×ˢ E2), 0 ≤ w p := by intros; positivity\n  have hw2 : ∑ p in (E1 ×ˢ E2), w p = 1 := by\n    rw [Finset.sum_product]\n    simp [← Finset.mul_sum]\n    rw [← Finset.sum_mul]\n    rw [show (1:ℝ) = 1 * 1 by norm_num]\n    congr\n    . convert hE1'; simp\n    convert hE2'; simp\n  have hf : ∀ p ∈ E1 ×ˢ E2, 0 ≤ f p := by intros; positivity\n  have H :=\n  calc\n    ∑ p in (E1 ×ˢ E2), w p * f p\n        = ∑ p in (E1 ×ˢ E2), μ.real {p} := by\n          congr with p\n          by_cases hp : μ.real {p} = 0\n          · simp [hp]\n          field_simp [h_fst_ne_zero p hp, h_snd_ne_zero p hp]\n          ring\n      _ = 1 := by\n        simp\n        rw [show 1 = μ.real Set.univ by simp]\n        apply measureReal_congr\n        simp\n        convert hE'\n        simp\n  have H1 : -measureMutualInfo (μ := μ) = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p) :=\n  calc\n    _ = ∑ p in (E1 ×ˢ E2),\n          (-(μ.real {p} * log (μ.real {p}))\n          + (μ.real {p} * log ((μ.map Prod.snd).real {p.2})\n            + μ.real {p} * log ((μ.map Prod.fst).real {p.1}))) := by\n        have H0 : Hm[μ] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log (μ.real {p})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE', negMulLog, neg_mul, Finset.sum_neg_distrib]\n          rfl\n        have H1 : Hm[μ.map Prod.fst] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.fst).real {p.1})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE1, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product, ← Finset.sum_mul]\n          congr! with s _\n          exact h1 s\n        have H2 : Hm[μ.map Prod.snd] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.snd).real {p.2})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE2, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product_right, ← Finset.sum_mul]\n          congr! with s _\n          exact h2 s\n        simp_rw [measureMutualInfo_def, H0, H1, H2]\n        simp [Finset.sum_add_distrib]\n    _ = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p)\n    := by\n        congr! 1 with p _\n        by_cases hp : μ.real {p} = 0\n        · simp [hp]\n        have := h_fst_ne_zero p hp\n        have := h_snd_ne_zero p hp\n        rw [negMulLog, log_mul, log_inv, log_mul]\n        · field_simp\n          ring\n        all_goals positivity\n  have H2 : 0 = negMulLog (∑ s in (E1 ×ˢ E2), w s * f s) := by\n    rw [H, negMulLog_one]\n  constructor\n  · rw [← neg_nonpos, H1]\n    convert sum_negMulLog_le (s := E1 ×ˢ E2) hw1 hw2 hf\n  rw [← neg_eq_zero, H1, H2, sum_negMulLog_eq_iff' hw1 hw2 hf]\n  have w0 (p : S × U) (hp: w p = 0) : μ.real {p} = 0 := by\n    simp at hp\n    rcases hp with hp | hp\n    . contrapose! hp; exact (h_fst_ne_zero p) hp\n    contrapose! hp; exact (h_snd_ne_zero p) hp\n  constructor\n  . intro hyp p\n    by_cases hp1 : p.1 ∈ E1\n    . by_cases hp2 : p.2 ∈ E2\n      . have hp : p ∈ E1 ×ˢ E2 := Finset.mem_product.mpr ⟨hp1, hp2⟩\n        by_cases hw : w p = 0\n        . rw [w0 p hw]\n          exact hw.symm\n        replace hyp := hyp p hp hw\n        rw [H] at hyp\n        have := inv_mul_eq_one₀' hyp\n        convert this.symm\n      have : {p.2} ⊆ (E2 : Set U)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp2\n      replace : (Measure.map Prod.snd μ).real {p.2} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE2\n      have hp : μ.real {p} = 0 := by contrapose! this; exact (h_snd_ne_zero p) this\n      simp [hp, this]\n    have : {p.1} ⊆ (E1 : Set S)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp1\n    replace : (Measure.map Prod.fst μ).real {p.1} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE1\n    have hp : μ.real {p} = 0 := by contrapose! this; exact (h_fst_ne_zero p) this\n    simp [hp, this]\n  intro hyp ⟨s, u⟩ _ hw\n  rw [H]\n  show (w (s,u))⁻¹ * (μ.real {(s,u)}) = 1\n  have : w (s,u) ≠ 0 := by exact hw\n  field_simp [this]\n  rw [hyp (s,u)]\n\nlemma measureMutualInfo_of_not_isFiniteMeasure {μ : Measure (S × U)} (h : ¬ IsFiniteMeasure μ) :\n    Im[μ] = 0 := by\n  rw [measureMutualInfo_def]\n  have h1 : ¬ IsFiniteMeasure (μ.map Prod.fst) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  have h2 : ¬ IsFiniteMeasure (μ.map Prod.snd) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  rw [measureEntropy_of_not_isFiniteMeasure h, measureEntropy_of_not_isFiniteMeasure h1,\n    measureEntropy_of_not_isFiniteMeasure h2]\n  simp\n\nlemma measureMutualInfo_univ_smul (μ : Measure (S × U)) : Im[(μ Set.univ)⁻¹ • μ] = Im[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureMutualInfo_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  rcases eq_zero_or_neZero μ with hμ | _\n  . simp [hμ]\n  rw [measureMutualInfo_def, measureMutualInfo_def]\n  congr 1; congr 1\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  convert measureEntropy_univ_smul\n\n","proof":":= by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  . rcases eq_zero_or_neZero μ with hμ|hμ\n    . simp [hμ]\n    rw [← measureMutualInfo_univ_smul μ]\n    apply measureMutualInfo_nonneg_aux.1\n  rw [measureMutualInfo_of_not_isFiniteMeasure hμ_fin]","declId":"PFR.ForMathlib.Entropy.Measure.777_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_nonneg {μ : Measure (S × U)} [FiniteSupport μ] :\n    0 ≤ Im[μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.FiniteRange\nimport PFR.ForMathlib.MeasureReal\nimport PFR.Mathlib.Algebra.GroupWithZero.Units.Lemmas\nimport PFR.Mathlib.Analysis.SpecialFunctions.NegMulLog\nimport PFR.Mathlib.Data.Fintype.Card\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.MeasureTheory.Integral.SetIntegral\n\n\n/-!\n# Entropy of a measure\n\n## Main definitions\n\n* `measureEntropy`: entropy of a measure `μ`, denoted by `Hm[μ]`\n* `measureMutualInfo`: mutual information of a measure over a product space, denoted by `Im[μ]`,\n  equal to `Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]`\n\n## Notations\n\n* `Hm[μ] = measureEntropy μ`\n* `Im[μ] = measureMutualInfo μ`\n\n-/\n\nopen Real MeasureTheory\nopen scoped ENNReal NNReal Topology BigOperators\n\nnamespace ProbabilityTheory\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [MeasurableSpace S] [MeasurableSingletonClass S]\n  [MeasurableSpace T] [MeasurableSingletonClass T]\n  [MeasurableSpace U] [MeasurableSingletonClass U]\n\nsection measureEntropy\nvariable {μ : Measure S}\n\n/-- Entropy of a measure on a finite measurable space.\n\nWe normalize the measure by `(μ Set.univ)⁻¹` to extend the entropy definition to finite measures.\nWhat we really want to do is deal with `μ=0` or `IsProbabilityMeasure μ`, but we don't have\na typeclass for that (we could create one though).\nThe added complexity in the expression is not an issue because if `μ` is a probability measure,\na call to `simp` will simplify `(μ Set.univ)⁻¹ • μ` to `μ`. -/\nnoncomputable\ndef measureEntropy (μ : Measure S := by volume_tac) : ℝ :=\n  ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal\n\nlemma measureEntropy_def (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := rfl\n\nlemma measureEntropy_def' (μ : Measure S) :\n    measureEntropy μ = ∑' s, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n  rw [measureEntropy_def]\n  congr! with s\n  simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[inherit_doc measureEntropy] notation:100 \"Hm[\" μ \"]\" => measureEntropy μ\n\n/-- A measure has finite support if there exsists a finite set whose complement has zero measure. -/\nclass FiniteSupport (μ : Measure S := by volume_tac) : Prop :=\n(finite : ∃ A : Finset S, μ Aᶜ = 0)\n\nnoncomputable\ndef _root_.MeasureTheory.Measure.support (μ : Measure S) [hμ : FiniteSupport μ] : Finset S :=\n  hμ.finite.choose\n\nlemma measure_compl_support (μ : Measure S) [hμ : FiniteSupport μ] :\n  μ μ.supportᶜ = 0 := hμ.finite.choose_spec\n\ninstance finiteSupport_zero : FiniteSupport (0 : Measure S) where\n  finite := ⟨(∅ : Finset S), by simp⟩\n\n/-- TODO: replace FiniteSupport hypotheses in these files with FiniteEntropy hypotheses. -/\nnoncomputable def FiniteEntropy (μ : Measure S := by volume_tac) : Prop :=\n  Summable (fun s ↦ negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal) ∧\n  ∃ A : Set S, Countable A ∧ μ Aᶜ = 0\n\ninstance finiteSupport_of_fintype {μ : Measure S} [Fintype S] : FiniteSupport μ := by\n  use Finset.univ\n  simp\n\ninstance finiteSupport_of_mul {μ : Measure S} [FiniteSupport μ] (c : ℝ≥0∞) :\n    FiniteSupport (c • μ) := by\n  use μ.support\n  simp [measure_compl_support]\n\nlemma finiteSupport_of_comp {μ : Measure Ω} [FiniteSupport μ] {X : Ω → S} (hX: Measurable X) :\n    FiniteSupport (μ.map X) := by\n  classical\n  use Finset.image X μ.support\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  refine measure_mono_null ?_ (measure_compl_support μ)\n  intro x; contrapose!; simp; intro hx; use x\n\ninstance finiteSupport_of_dirac (x : S) : FiniteSupport (Measure.dirac x) := by\n  use {x}\n  simp [Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, MeasurableSet.singleton]\n\n/-- duplicate of `FiniteRange.null_of_compl` -/\nlemma full_measure_of_finiteRange {μ : Measure Ω} {X : Ω → S}\n    (hX : Measurable X) [hX' : FiniteRange X] :\n    (μ.map X) (hX'.toFinset)ᶜ = 0 := by\n  rw [Measure.map_apply hX (MeasurableSet.compl (Finset.measurableSet _))]\n  convert measure_empty\n  ext x\n  simp [FiniteRange.toFinset]\n  rw [@Set.mem_toFinset S _ hX'.fintype]\n  simp\n\ninstance finiteSupport_of_finiteRange {μ : Measure Ω} {X : Ω → S} [hX' : FiniteRange X] :\n    FiniteSupport (μ.map X) := by\n  use hX'.toFinset\n  exact FiniteRange.null_of_compl μ X\n\nlemma prod_of_full_measure_finSet {μ : Measure S} {ν : Measure T} [SigmaFinite ν]\n    {A : Finset S} {B : Finset T} (hA : μ Aᶜ = 0) (hB : ν Bᶜ = 0) :\n    (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n  have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by\n    ext ⟨s, t⟩\n    simp; tauto\n  rw [this]\n  simp [hA, hB]\n\nlemma full_measure_of_null_compl {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n    μ A = μ Set.univ := by\n  have := measure_add_measure_compl (μ := μ) (s := A) (by measurability)\n  simp [hA] at this\n  exact this\n\ninstance finiteSupport_of_prod {μ : Measure S} [FiniteSupport μ] {ν : Measure T} [SigmaFinite ν]\n    [FiniteSupport ν] :\n    FiniteSupport (μ.prod ν) := by\n  use μ.support ×ˢ ν.support\n  exact prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support ν)\n\n/-- The countability hypothesis can probably be dropped here. Proof is unwieldy and can probably\nbe golfed. -/\nlemma integrable_of_finiteSupport (μ : Measure S) [FiniteSupport μ]\n    {β : Type*} [NormedAddCommGroup β] [IsFiniteMeasure μ] [Countable S] {f : S → β} :\n    Integrable f μ := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  by_cases hA' : A = ∅\n  . simp [hA'] at hA\n    rw [hA]\n    exact integrable_zero_measure\n  have : ∃ s₀, s₀ ∈ A := by\n    contrapose! hA'\n    ext s\n    simp\n    exact hA' s\n  rcases this with ⟨s₀, hs₀⟩\n  let f' : A → β := fun a ↦ f a\n  classical\n  let g : S → A := fun s ↦ if h : s ∈ A then ⟨s, h⟩ else ⟨s₀, hs₀⟩\n  have : (f' ∘ g) =ᶠ[MeasureTheory.Measure.ae μ] f := by\n    apply Filter.eventuallyEq_of_mem (s := A)\n    . unfold Measure.ae\n      simp [hA]\n    intro a ha\n    simp\n    congr\n    simp at ha\n    simp [ha]\n  apply Integrable.congr _ this\n  apply Integrable.comp_measurable (integrable_of_fintype _ _)\n  apply measurable_of_countable\n\nlemma integral_congr_finiteSupport {μ : Measure Ω} {G : Type*} [MeasurableSingletonClass Ω]\n    [NormedAddCommGroup G] [NormedSpace ℝ G] [CompleteSpace G] {f g : Ω → G}\n    [FiniteSupport μ] [IsFiniteMeasure μ] (hfg : ∀ x, μ {x} ≠ 0 → f x = g x) :\n    ∫ x, f x ∂μ = ∫ x, g x ∂μ := by\n  rw [integral_eq_sum' μ (measure_compl_support μ), integral_eq_sum' μ (measure_compl_support μ)]\n  congr with x\n  by_cases hx : μ {x} = 0\n  . simp [hx]\n  rw [hfg x hx]\n\n/-- This generalizes Measure.ext_iff_singleton in MeasureReal -/\ntheorem Measure.ext_iff_singleton_finiteSupport [MeasurableSpace S] [MeasurableSingletonClass S]\n    {μ1 μ2 : Measure S} [FiniteSupport μ1] [FiniteSupport μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1 {x} = μ2 {x} := by\n  classical\n  constructor\n  · rintro rfl\n    simp\n  · let A1 := μ1.support\n    have hA1 := measure_compl_support μ1\n    let A2 := μ2.support\n    have hA2 := measure_compl_support μ2\n    intro h\n    ext s\n    have h1 : μ1 s = μ1 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA1\n      intro x; simp; tauto\n    have h2 : μ2 s = μ2 (s ∩ (A1 ∪ A2)) := by\n      apply (measure_eq_measure_of_null_diff _ _).symm\n      . simp\n      refine measure_mono_null ?_ hA2\n      intro x; simp; tauto\n    rw [h1, h2]\n    have hs : Set.Finite (s ∩ (A1 ∪ A2)) :=  Set.toFinite (s ∩ (↑A1 ∪ ↑A2))\n    rw [← hs.coe_toFinset, ← Finset.sum_measure_singleton μ1, ← Finset.sum_measure_singleton μ2]\n    simp_rw [h]\n\ntheorem Measure.ext_iff_measureReal_singleton_finiteSupport [MeasurableSpace S]\n    [MeasurableSingletonClass S] {μ1 μ2 : Measure S}\n    [FiniteSupport μ1] [FiniteSupport μ2] [IsFiniteMeasure μ1] [IsFiniteMeasure μ2] :\n    μ1 = μ2 ↔ ∀ x, μ1.real {x} = μ2.real {x} := by\n  rw [Measure.ext_iff_singleton_finiteSupport]\n  congr! with x\n  have h1 : μ1 {x} ≠ ⊤ := by finiteness\n  have h2 : μ2 {x} ≠ ⊤ := by finiteness\n  rw [measureReal_def, measureReal_def, ENNReal.toReal_eq_toReal_iff]\n  simp [h1, h2]\n\nlemma measureEntropy_def_finite {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0) :\n   Hm[ μ ] = ∑ s in A, negMulLog (((μ Set.univ)⁻¹ • μ) {s}).toReal := by\n  unfold measureEntropy\n  rw [tsum_eq_sum]\n  intro s hs\n  suffices μ { s } = 0 by simp [this]\n  apply measure_mono_null _ hA\n  simpa\n\nlemma measureEntropy_def_finite' {μ : Measure S} {A : Finset S} (hA : μ Aᶜ = 0):\n    Hm[ μ ] = ∑ s in A, negMulLog (((μ.real Set.univ) ⁻¹ • μ.real) {s}) := by\n    rw [measureEntropy_def_finite hA]\n    congr! with s\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n    ENNReal.toReal_mul, measureReal_def, ENNReal.toReal_inv]\n\n@[simp]\nlemma measureEntropy_zero : Hm[(0 : Measure S)] = 0 := by simp [measureEntropy]\n\n@[simp]\nlemma measureEntropy_dirac (x : S) : Hm[Measure.dirac x] = 0 := by\n  rw [measureEntropy_def]\n  simp only [MeasurableSet.univ, Measure.dirac_apply', Set.mem_univ, Set.indicator_of_mem,\n    Pi.one_apply, inv_one, one_smul, MeasurableSet.singleton, Set.mem_singleton_iff]\n  rw [tsum_eq_single x]\n  · simp\n  · simp only [Finset.mem_univ, ne_eq, Set.mem_singleton_iff, forall_true_left]\n    intro b hb\n    simp [Ne.symm hb]\n\nlemma measureEntropy_of_not_isFiniteMeasure (h : ¬ IsFiniteMeasure μ) : Hm[μ] = 0 := by\n  simp [measureEntropy, not_isFiniteMeasure_iff.mp h]\n\nlemma measureEntropy_of_isProbabilityMeasure (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ {s}).toReal := by\n  simp [measureEntropy]\n\nlemma measureEntropy_of_isProbabilityMeasure' (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = ∑' s, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure μ\n\nlemma measureEntropy_of_isProbabilityMeasure_finite {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ {s}).toReal := by\n  rw [measureEntropy_def_finite hA]\n  simp\n\nlemma measureEntropy_of_isProbabilityMeasure_finite' {μ : Measure S} {A : Finset S} (hA: μ Aᶜ = 0)\n    [IsProbabilityMeasure μ] :\n    Hm[ μ ] = ∑ s in A, negMulLog (μ.real {s}) :=\n  measureEntropy_of_isProbabilityMeasure_finite hA\n\nlemma measureEntropy_univ_smul : Hm[(μ Set.univ)⁻¹ • μ] = Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ =>\n    rw [measureEntropy_def]\n    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply, smul_eq_mul,\n      ENNReal.toReal_mul]\n    rw [ENNReal.inv_mul_cancel]\n    · simp only [inv_one, ENNReal.one_toReal, one_mul]\n      simp [measureEntropy]\n    · simp [hμ.out]\n    · exact measure_ne_top _ _\n\nlemma measureEntropy_nonneg (μ : Measure S) : 0 ≤ Hm[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap; · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n  apply tsum_nonneg\n  intro s\n  apply negMulLog_nonneg (by positivity)\n  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_\n  rw [ENNReal.ofReal_one]\n  cases eq_zero_or_neZero μ with\n  | inl hμ => simp [hμ]\n  | inr hμ => exact prob_le_one\n\nlemma measureEntropy_le_card_aux {μ : Measure S} [IsProbabilityMeasure μ]\n    (A : Finset S) (hμ : μ Aᶜ = 0) :\n    Hm[μ] ≤ log A.card := by\n  have μA : μ A = 1 := by\n    rw [← compl_compl (A : Set S), measure_compl A.measurableSet.compl (measure_ne_top _ _), hμ]\n    simp\n  let N := A.card\n  have N_pos : (0 : ℝ) < N := by\n    rcases Finset.eq_empty_or_nonempty A with rfl|hA\n    · simp at μA\n    · simpa using Finset.card_pos.mpr hA\n  simp only [measureEntropy_def, measure_univ, inv_one, one_smul]\n  calc\n  ∑' x, negMulLog (μ {x}).toReal\n    = ∑ x in A, negMulLog (μ {x}).toReal := by\n      apply tsum_eq_sum\n      intro i hi\n      have : μ {i} = 0 :=\n        le_antisymm ((measure_mono (by simpa using hi)).trans (le_of_eq hμ)) bot_le\n      simp [this]\n  _ = N * ∑ x in A, (N : ℝ)⁻¹ * negMulLog (μ {x}).toReal := by\n      rw [Finset.mul_sum]\n      congr with x\n      rw [← mul_assoc, mul_inv_cancel, one_mul]\n      exact N_pos.ne'\n  _ ≤ N * negMulLog (∑ x in A, (N : ℝ)⁻¹ * (μ {x}).toReal) :=\n       mul_le_mul_of_nonneg_left\n         (sum_negMulLog_le (by simp) (by simp [mul_inv_cancel N_pos.ne']) (by simp)) (by positivity)\n  _ = N * negMulLog ((N : ℝ)⁻¹) := by simp [← Finset.mul_sum, μA]\n  _ = log A.card := by simp [negMulLog, ← mul_assoc, mul_inv_cancel N_pos.ne']\n\nlemma measureEntropy_eq_card_iff_measureReal_eq_aux [MeasurableSingletonClass S] [Fintype S]\n    (μ : Measure S) [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔∀ s : S, μ.real {s} = (Fintype.card S : ℝ)⁻¹ := by\n  cases isEmpty_or_nonempty S with\n  | inl h =>\n    have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  | inr h =>\n    -- multiply LHS equation through by `N⁻¹`\n    set N := Fintype.card S\n    have hN : (N:ℝ)⁻¹ ≠ 0 := by positivity\n    rw [← mul_right_inj' hN]\n    -- setup to use equality case of Jensen\n    let w (_ : S) := (N:ℝ)⁻¹\n    have hw1 : ∀ s ∈ Finset.univ, 0 < w s := by intros; positivity\n    have hw2 : ∑ s : S, w s = 1 := by simp [Finset.card_univ]\n    let p (s : S) := μ.real {s}\n    have hp : ∀ s ∈ Finset.univ, 0 ≤ p s := by intros; positivity\n    -- use equality case of Jensen\n    convert sum_negMulLog_eq_iff hw1 hw2 hp using 2\n    · rw [measureEntropy_def', tsum_fintype, Finset.mul_sum]\n      simp\n    · simp [negMulLog, ← Finset.mul_sum]\n    · rw [← Finset.mul_sum]\n      simp\n\nlemma measureEntropy_eq_card_iff_measure_eq_aux\n    (μ : Measure S) [Fintype S] [IsProbabilityMeasure μ] :\n    Hm[μ] = log (Fintype.card S) ↔ (∀ s : S, μ {s} = (Fintype.card S : ℝ≥0)⁻¹) := by\n  rw [measureEntropy_eq_card_iff_measureReal_eq_aux]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  congr!\n  simp\n\nlemma measureEntropy_le_log_card_of_mem {A : Finset S} (μ : Measure S) (hμA : μ Aᶜ = 0) :\n    Hm[μ] ≤ log (Nat.card A) := by\n  have h_log_card_nonneg : 0 ≤ log (Nat.card A) := log_nat_cast_nonneg (Nat.card ↑A)\n  rcases eq_zero_or_neZero μ with rfl|hμ\n  · simp [h_log_card_nonneg]; positivity\n  · by_cases hμ_fin : IsFiniteMeasure μ\n    swap;\n    · rw [measureEntropy_of_not_isFiniteMeasure hμ_fin]\n      exact h_log_card_nonneg\n    rw [← measureEntropy_univ_smul]\n    have : ((μ Set.univ) ⁻¹ • μ) (Aᶜ) = 0 := by simp [hμA]\n    convert measureEntropy_le_card_aux A this using 3\n    rw [Nat.card_eq_fintype_card]\n    exact Fintype.card_coe A\n\nlemma measureEntropy_le_log_card [Fintype S] (μ : Measure S) : Hm[μ] ≤ log (Fintype.card S) := by\n  convert measureEntropy_le_log_card_of_mem (A := (Finset.univ : Finset S)) μ (by simp)\n  simp [Nat.card_eq_fintype_card]\n  rw [Fintype.subtype_card]\n  simp; rfl\n\nlemma measureEntropy_eq_card_iff_measureReal_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ.real {s} = μ.real Set.univ / Fintype.card S) := by\n  rw [← measureEntropy_univ_smul]\n  convert measureEntropy_eq_card_iff_measureReal_eq_aux ((μ Set.univ)⁻¹ • μ) using 2 with s\n  simp only [measureReal_smul_apply, smul_eq_mul]\n  rw [ENNReal.toReal_inv, inv_mul_eq_iff_eq_mul₀ (by exact measureReal_univ_ne_zero),\n    div_eq_mul_inv]\n  rfl\n\nlemma measureEntropy_eq_card_iff_measure_eq [MeasurableSingletonClass S] [Fintype S] [IsFiniteMeasure μ]\n    [NeZero μ] :\n    Hm[μ] = log (Fintype.card S) ↔\n    (∀ s : S, μ {s} = μ Set.univ / Fintype.card S) := by\n  obtain h | h := isEmpty_or_nonempty S\n  · have : μ = 0 := Subsingleton.elim _ _\n    simp [Fintype.card_eq_zero, this]\n  rw [div_eq_mul_inv, measureEntropy_eq_card_iff_measureReal_eq]\n  congr! with s\n  rw [measureReal_def, ← ENNReal.toReal_eq_toReal_iff' (measure_ne_top μ {s})]\n  · rw [ENNReal.toReal_mul, ENNReal.toReal_inv]\n    rfl\n  · finiteness\n\nlemma measureEntropy_map_of_injective\n    (μ : Measure S) (f : S → T) (hf_m : Measurable f) (hf : Function.Injective f) :\n    Hm[μ.map f] = Hm[μ] := by\n  have : μ.map f Set.univ = μ Set.univ := by\n      rw [Measure.map_apply hf_m MeasurableSet.univ]\n      simp\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.map_apply hf_m (measurableSet_singleton _)]\n  rw [this]\n  classical\n  let F : T → ℝ := fun x ↦ negMulLog ((μ Set.univ)⁻¹ • μ (f ⁻¹' {x})).toReal\n  have : ∑' x : T, F x\n      = ∑' x : (f '' Set.univ), F x := by\n    apply (tsum_subtype_eq_of_support_subset _).symm\n    intro x hx\n    contrapose hx\n    suffices f ⁻¹' {x} = ∅ by simp [this]\n    contrapose! hx\n    rw [Set.image_univ]\n    exact hx\n  rw [this, tsum_image _ (Set.injective_iff_injOn_univ.mp hf), tsum_univ (fun x ↦ F (f x))]\n  congr! with s\n  ext s'; simp\n  exact hf.eq_iff\n\nlemma measureEntropy_comap (μ : Measure S) (f : T → S) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ) :\n    Hm[μ.comap f] = Hm[μ] := by\n  simp_rw [measureEntropy_def, Measure.smul_apply,\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ (measurableSet_singleton _),\n    Measure.comap_apply f hf.injective hf.measurableSet_image' _ MeasurableSet.univ]\n  simp only [Set.image_univ, Set.image_singleton, smul_eq_mul, ENNReal.toReal_mul]\n  classical\n  rw [← tsum_range\n    (f := fun x ↦ negMulLog (((μ (Set.range f))⁻¹).toReal * (μ {x}).toReal)) (g := f),measure_congr hf_range]\n  let F : S → ℝ := fun x ↦ negMulLog (((μ (Set.univ))⁻¹).toReal * (μ {x}).toReal)\n  show ∑' x : (Set.range f), F x = ∑' x : S, F x\n  apply tsum_subtype_eq_of_support_subset\n  . intro x hx\n    contrapose hx\n    suffices μ {x} = 0 by simp [this]\n    refine measure_mono_null ?_ hf_range\n    intro y'\n    simp only [Set.mem_singleton_iff, Set.mem_compl_iff, Set.mem_range, not_exists]\n    intro h\n    simp [h]\n    contrapose! hx\n    have : Set.univ x := by exact trivial\n    rwa [← hx] at this\n  exact hf.injective\n\nlemma measureEntropy_comap_equiv (μ : Measure S) (f : T ≃ᵐ S) :\n    Hm[μ.comap f] = Hm[μ] := by\n  refine measureEntropy_comap μ f f.measurableEmbedding ?_\n  simp only [ae_eq_univ]\n  have : Set.range f = Set.univ := Equiv.range_eq_univ _\n  simp [this]\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy. -/\n@[simp]\nlemma measureEntropy_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Hm[μ.prod ν] = Hm[μ] + Hm[ν] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  let B := ν.support\n  have hB := measure_compl_support ν\n  have hC : (μ.prod ν) (A ×ˢ B : Finset (S × T))ᶜ = 0 := by\n    have : ((A ×ˢ B : Finset (S × T)) : Set (S × T))ᶜ = ((A : Set S)ᶜ ×ˢ Set.univ) ∪ (Set.univ ×ˢ (B : Set T)ᶜ) := by ext ⟨a, b⟩; simp; tauto\n    rw [this]\n    simp [hA, hB]\n  have h1 : Hm[μ] = ∑ p in (A ×ˢ B), (negMulLog (μ.real {p.1})) * (ν.real {p.2}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hA, Finset.sum_product]\n    congr with s\n    simp; rw [← Finset.mul_sum]; simp\n    suffices ν.real B = ν.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hB]\n  have h2 : Hm[ν] = ∑ p in (A ×ˢ B), (negMulLog (ν.real {p.2})) * (μ.real {p.1}) := by\n    rw [measureEntropy_of_isProbabilityMeasure_finite' hB, Finset.sum_product_right]\n    congr with t\n    simp; rw [← Finset.mul_sum]; simp\n    suffices μ.real A = μ.real Set.univ by simp at this; simp [this]\n    apply measureReal_congr\n    simp [hA]\n  rw [measureEntropy_of_isProbabilityMeasure_finite' hC, h1, h2, ← Finset.sum_add_distrib]\n  congr with ⟨s, t⟩\n  simp_rw [← Set.singleton_prod_singleton, measureReal_prod_prod, negMulLog_mul]\n  ring\n\nend measureEntropy\n\nsection measureMutualInfo\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnoncomputable\ndef measureMutualInfo (μ : Measure (S × T) := by volume_tac) : ℝ :=\n  Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ]\n\n/-- The mutual information between the marginals of a measure on a product space. -/\nnotation:100 \"Im[\" μ \"]\" => measureMutualInfo μ\n\nlemma measureMutualInfo_def (μ : Measure (S × T)) :\n    Im[μ] = Hm[μ.map Prod.fst] + Hm[μ.map Prod.snd] - Hm[μ] := rfl\n\n--todo: do this in mathlib? Others: Measure.withDensity, Measure.map\nattribute [pp_dot] ENNReal.toReal\n\n@[simp]\nlemma measureMutualInfo_zero_measure : Im[(0 : Measure (S × T))] = 0 := by\n  simp [measureMutualInfo]\n\nlemma measureMutualInfo_swap (μ : Measure (S × T)) :\n    Im[μ.map Prod.swap] = Im[μ] := by\n  rw [measureMutualInfo_def, add_comm, Measure.map_map measurable_snd measurable_swap,\n    Measure.map_map measurable_fst measurable_swap]\n  congr 1\n  simp_rw [measureEntropy_def, Measure.map_apply measurable_swap MeasurableSet.univ]\n  simp only [Set.preimage_univ, Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n    smul_eq_mul, ENNReal.toReal_mul, Fintype.sum_prod_type]\n  simp_rw [Measure.map_apply measurable_swap (measurableSet_singleton _)]\n  have : Set.range (Prod.swap : S × T → T × S) = Set.univ := Set.range_iff_surjective.mpr Prod.swap_surjective\n  rw [← tsum_univ, ← this, tsum_range (fun x ↦ negMulLog (((μ Set.univ)⁻¹).toReal * (μ (Prod.swap⁻¹' {x}) ).toReal))]\n  congr! with ⟨s, t⟩\n  simp\n  convert Function.Injective.preimage_image _ _\n  simp\n  all_goals exact Prod.swap_injective\n\n@[simp]\nlemma measureMutualInfo_prod {μ : Measure S} {ν : Measure T} [FiniteSupport μ] [FiniteSupport ν]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν] :\n    Im[μ.prod ν] = 0 := by\n  rw [measureMutualInfo_def, measureEntropy_prod]\n  simp\n\n/-- An ambitious goal would be to replace FiniteSupport with finite entropy.  Proof is long and slow; needs to be optimized -/\nlemma measureMutualInfo_nonneg_aux {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    0 ≤ Im[μ] ∧\n    (Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}) := by\n  have : IsProbabilityMeasure (μ.map Prod.fst) :=\n    isProbabilityMeasure_map measurable_fst.aemeasurable\n  have : IsProbabilityMeasure (μ.map Prod.snd) :=\n    isProbabilityMeasure_map measurable_snd.aemeasurable\n  let E := μ.support\n  have hE := measure_compl_support μ\n  classical\n  set E1 : Finset S := Finset.image Prod.fst E\n  set E2 : Finset U := Finset.image Prod.snd E\n  have hE' : μ (E1 ×ˢ E2 : Finset (S × U))ᶜ = 0 := by\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    contrapose!\n    intro h\n    simp at h ⊢\n    constructor; use u; use s\n  have hE1 : (μ.map Prod.fst) E1ᶜ = 0 := by\n    rw [Measure.map_apply measurable_fst (MeasurableSet.compl (Finset.measurableSet E1))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use u\n  have hE1' : (μ.map Prod.fst).real E1 = 1 := by\n    suffices : (μ.map Prod.fst) E1 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E1)] at hE1\n    . simp at hE1; convert hE1; simp\n    exact measure_ne_top _ _\n  have hE2 : (μ.map Prod.snd) E2ᶜ = 0 := by\n    rw [Measure.map_apply measurable_snd (MeasurableSet.compl (Finset.measurableSet E2))]\n    refine measure_mono_null ?_ hE\n    intro ⟨s, u⟩\n    simp\n    contrapose!\n    intro h; use s\n  have hE2' : (μ.map Prod.snd).real E2 = 1 := by\n    suffices : (μ.map Prod.snd) E2 = 1\n    . unfold Measure.real; rw [this]; norm_num\n    rw [measure_compl (Finset.measurableSet E2)] at hE2\n    . simp at hE2; convert hE2; simp\n    exact measure_ne_top _ _\n  have h_fst_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.fst).real {p.1} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h_snd_ne_zero : ∀ p, μ.real {p} ≠ 0 → (μ.map Prod.snd).real {p.2} ≠ 0 := by\n    intro p hp\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _)]\n    simp only [Set.mem_singleton_iff, ne_eq, ENNReal.toReal_eq_zero_iff, measure_ne_top μ,\n      or_false]\n    refine fun h_eq_zero ↦ hp ?_\n    refine measureReal_mono_null ?_ h_eq_zero\n    simp\n  have h1 y : (μ.map Prod.fst).real {y} = ∑ z in E2, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_fst (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; exact h1; use s\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.1\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  have h2 z : (μ.map Prod.snd).real {z} = ∑ y in E1, μ.real {(y, z)} := by\n    rw [map_measureReal_apply measurable_snd (measurableSet_singleton _), ← measureReal_biUnion_finset]\n    . apply measureReal_congr\n      rw [MeasureTheory.ae_eq_set]\n      constructor\n      . refine measure_mono_null ?_ hE\n        intro ⟨s, u⟩ ⟨h1, h2⟩\n        contrapose! h2\n        simp at h1 h2 ⊢\n        constructor; use u; exact h1\n      convert measure_empty\n      rw [Set.diff_eq_empty]\n      intro ⟨s, u⟩ h\n      simp at h ⊢\n      exact h.2\n    . intro s1 _ s2 _ h; simp [h]\n    intros; exact measurableSet_singleton _\n  let w (p : S × U) := (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2}\n  let f (p : S × U) := ((μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2})⁻¹ * μ.real {p}\n  have hw1 : ∀ p ∈ (E1 ×ˢ E2), 0 ≤ w p := by intros; positivity\n  have hw2 : ∑ p in (E1 ×ˢ E2), w p = 1 := by\n    rw [Finset.sum_product]\n    simp [← Finset.mul_sum]\n    rw [← Finset.sum_mul]\n    rw [show (1:ℝ) = 1 * 1 by norm_num]\n    congr\n    . convert hE1'; simp\n    convert hE2'; simp\n  have hf : ∀ p ∈ E1 ×ˢ E2, 0 ≤ f p := by intros; positivity\n  have H :=\n  calc\n    ∑ p in (E1 ×ˢ E2), w p * f p\n        = ∑ p in (E1 ×ˢ E2), μ.real {p} := by\n          congr with p\n          by_cases hp : μ.real {p} = 0\n          · simp [hp]\n          field_simp [h_fst_ne_zero p hp, h_snd_ne_zero p hp]\n          ring\n      _ = 1 := by\n        simp\n        rw [show 1 = μ.real Set.univ by simp]\n        apply measureReal_congr\n        simp\n        convert hE'\n        simp\n  have H1 : -measureMutualInfo (μ := μ) = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p) :=\n  calc\n    _ = ∑ p in (E1 ×ˢ E2),\n          (-(μ.real {p} * log (μ.real {p}))\n          + (μ.real {p} * log ((μ.map Prod.snd).real {p.2})\n            + μ.real {p} * log ((μ.map Prod.fst).real {p.1}))) := by\n        have H0 : Hm[μ] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log (μ.real {p})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE', negMulLog, neg_mul, Finset.sum_neg_distrib]\n          rfl\n        have H1 : Hm[μ.map Prod.fst] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.fst).real {p.1})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE1, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product, ← Finset.sum_mul]\n          congr! with s _\n          exact h1 s\n        have H2 : Hm[μ.map Prod.snd] = -∑ p in (E1 ×ˢ E2), (μ.real {p} * log ((μ.map Prod.snd).real {p.2})) := by\n          simp_rw [measureEntropy_of_isProbabilityMeasure_finite hE2, negMulLog, neg_mul, Finset.sum_neg_distrib, Finset.sum_product_right, ← Finset.sum_mul]\n          congr! with s _\n          exact h2 s\n        simp_rw [measureMutualInfo_def, H0, H1, H2]\n        simp [Finset.sum_add_distrib]\n    _ = ∑ p in (E1 ×ˢ E2), w p * negMulLog (f p)\n    := by\n        congr! 1 with p _\n        by_cases hp : μ.real {p} = 0\n        · simp [hp]\n        have := h_fst_ne_zero p hp\n        have := h_snd_ne_zero p hp\n        rw [negMulLog, log_mul, log_inv, log_mul]\n        · field_simp\n          ring\n        all_goals positivity\n  have H2 : 0 = negMulLog (∑ s in (E1 ×ˢ E2), w s * f s) := by\n    rw [H, negMulLog_one]\n  constructor\n  · rw [← neg_nonpos, H1]\n    convert sum_negMulLog_le (s := E1 ×ˢ E2) hw1 hw2 hf\n  rw [← neg_eq_zero, H1, H2, sum_negMulLog_eq_iff' hw1 hw2 hf]\n  have w0 (p : S × U) (hp: w p = 0) : μ.real {p} = 0 := by\n    simp at hp\n    rcases hp with hp | hp\n    . contrapose! hp; exact (h_fst_ne_zero p) hp\n    contrapose! hp; exact (h_snd_ne_zero p) hp\n  constructor\n  . intro hyp p\n    by_cases hp1 : p.1 ∈ E1\n    . by_cases hp2 : p.2 ∈ E2\n      . have hp : p ∈ E1 ×ˢ E2 := Finset.mem_product.mpr ⟨hp1, hp2⟩\n        by_cases hw : w p = 0\n        . rw [w0 p hw]\n          exact hw.symm\n        replace hyp := hyp p hp hw\n        rw [H] at hyp\n        have := inv_mul_eq_one₀' hyp\n        convert this.symm\n      have : {p.2} ⊆ (E2 : Set U)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp2\n      replace : (Measure.map Prod.snd μ).real {p.2} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE2\n      have hp : μ.real {p} = 0 := by contrapose! this; exact (h_snd_ne_zero p) this\n      simp [hp, this]\n    have : {p.1} ⊆ (E1 : Set S)ᶜ := by simp only [Set.singleton_subset_iff, Set.mem_compl_iff, Finset.mem_coe]; convert hp1\n    replace : (Measure.map Prod.fst μ).real {p.1} = 0 := by rw [measureReal_eq_zero_iff]; exact measure_mono_null this hE1\n    have hp : μ.real {p} = 0 := by contrapose! this; exact (h_fst_ne_zero p) this\n    simp [hp, this]\n  intro hyp ⟨s, u⟩ _ hw\n  rw [H]\n  show (w (s,u))⁻¹ * (μ.real {(s,u)}) = 1\n  have : w (s,u) ≠ 0 := by exact hw\n  field_simp [this]\n  rw [hyp (s,u)]\n\nlemma measureMutualInfo_of_not_isFiniteMeasure {μ : Measure (S × U)} (h : ¬ IsFiniteMeasure μ) :\n    Im[μ] = 0 := by\n  rw [measureMutualInfo_def]\n  have h1 : ¬ IsFiniteMeasure (μ.map Prod.fst) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  have h2 : ¬ IsFiniteMeasure (μ.map Prod.snd) := by\n    rw [not_isFiniteMeasure_iff] at h ⊢\n    rw [← h]\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  rw [measureEntropy_of_not_isFiniteMeasure h, measureEntropy_of_not_isFiniteMeasure h1,\n    measureEntropy_of_not_isFiniteMeasure h2]\n  simp\n\nlemma measureMutualInfo_univ_smul (μ : Measure (S × U)) : Im[(μ Set.univ)⁻¹ • μ] = Im[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  swap\n  · rw [measureMutualInfo_of_not_isFiniteMeasure hμ_fin]\n    rw [not_isFiniteMeasure_iff] at hμ_fin\n    simp [hμ_fin]\n  rcases eq_zero_or_neZero μ with hμ | _\n  . simp [hμ]\n  rw [measureMutualInfo_def, measureMutualInfo_def]\n  congr 1; congr 1\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_fst MeasurableSet.univ\n  . convert measureEntropy_univ_smul\n    simp; congr; symm\n    convert Measure.map_apply measurable_snd MeasurableSet.univ\n  convert measureEntropy_univ_smul\n\nlemma measureMutualInfo_nonneg {μ : Measure (S × U)} [FiniteSupport μ] :\n    0 ≤ Im[μ] := by\n  by_cases hμ_fin : IsFiniteMeasure μ\n  . rcases eq_zero_or_neZero μ with hμ|hμ\n    . simp [hμ]\n    rw [← measureMutualInfo_univ_smul μ]\n    apply measureMutualInfo_nonneg_aux.1\n  rw [measureMutualInfo_of_not_isFiniteMeasure hμ_fin]\n\n","proof":":=\n  measureMutualInfo_nonneg_aux.2","declId":"PFR.ForMathlib.Entropy.Measure.786_0.KBK7AD4u6u7sJBr","decl":"lemma measureMutualInfo_eq_zero_iff {μ : Measure (S × U)} [FiniteSupport μ]\n    [IsProbabilityMeasure μ] :\n    Im[μ] = 0 ↔ ∀ p, μ.real {p} = (μ.map Prod.fst).real {p.1} * (μ.map Prod.snd).real {p.2} "}
