{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n","proof":":=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.32_0.2L1Uflhmlhotb94","decl":"/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n","proof":":=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.38_0.2L1Uflhmlhotb94","decl":"/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\n","proof":":= by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.48_0.2L1Uflhmlhotb94","decl":"lemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\n","proof":":= by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.60_0.2L1Uflhmlhotb94","decl":"lemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\n","proof":":= by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.71_0.2L1Uflhmlhotb94","decl":"lemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n","proof":":= by\n  simp [rdist]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.81_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n","proof":":= by\n  simp [rdist]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.85_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n","proof":":= by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.89_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n","proof":":= by\n  rw [rdist_symm, rdist_zero_kernel_right]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.104_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n","proof":":= by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.110_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n","proof":":= by\n  rw [rdist_symm, rdist_dirac_zero_right]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.139_0.2L1Uflhmlhotb94","decl":"@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\n","proof":":= by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.145_0.2L1Uflhmlhotb94","decl":"lemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\n","proof":":= by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.156_0.2L1Uflhmlhotb94","decl":"lemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\nlemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] := by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]\n\n","proof":":= by\n  suffices 0 ≤ 2 * dk[κ ; μ # η ; ν] by linarith\n  calc 0 ≤ |Hk[κ, μ] - Hk[η, ν]| := abs_nonneg _\n  _ ≤ 2 * dk[κ ; μ # η ; ν] := abs_sub_entropy_le_rdist hκ hη","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.170_0.2L1Uflhmlhotb94","decl":"lemma rdist_nonneg {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    0 ≤ dk[κ ; μ # η ; ν] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\nlemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] := by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]\n\nlemma rdist_nonneg {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    0 ≤ dk[κ ; μ # η ; ν] := by\n  suffices 0 ≤ 2 * dk[κ ; μ # η ; ν] by linarith\n  calc 0 ≤ |Hk[κ, μ] - Hk[η, ν]| := abs_nonneg _\n  _ ≤ 2 * dk[κ ; μ # η ; ν] := abs_sub_entropy_le_rdist hκ hη\n\n-- Kernel equivalent of `H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ]`\n-- `κ` is `⟨X,Y⟩`, `η` is `Z`. Independence is expressed through the product `×ₖ`.\n","proof":":= by\n  have hκη := kernel.finiteKernelSupport_of_prod hκ hη\n  have h1 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n        (measurable_of_countable _), μ] + Hk[map κ (fun p ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n        + Hk[map κ (fun p ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ] := by\n    have h := entropy_triple_add_entropy_le\n      (map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) (measurable_of_countable _)) μ\n    simp only [snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h\n    rw [deleteMiddle_map_prod _ (measurable_of_countable _) (measurable_of_countable _)\n        (measurable_of_countable _)] at h\n    have : map (κ ×ₖ η) (fun x ↦ x.1.1 - x.1.2) (measurable_of_countable _)\n        = map κ (fun p ↦ p.1 - p.2) measurable_sub := by\n      have : (fun x : (G × G) × G ↦ x.1.1 - x.1.2)\n        = (fun x ↦ x.1 - x.2) ∘ Prod.fst := by ext1 y; simp\n      rw [this, ← map_map, ← kernel.fst, fst_prod]\n    rw [this] at h\n    refine (h ?_).trans_eq ?_\n    . apply FiniteKernelSupport.aefiniteKernelSupport\n      apply kernel.finiteKernelSupport_of_map\n      exact kernel.finiteKernelSupport_of_prod hκ hη\n    congr 2\n    have : (fun x : (G × G) × G ↦ (x.1.2, x.1.1 - x.1.2))\n      = (fun x ↦ (x.2, x.1 - x.2)) ∘ Prod.fst := by ext1 y; simp\n    rw [this, ← map_map, ← kernel.fst, fst_prod]\n  have h2 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n    calc Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) (measurable_of_countable _), μ] := by\n          have : (fun p : (G × G) × G ↦ (p.1.1 - p.2, p.1.1 - p.1.2))\n            = (fun p ↦ (p.1, p.1 - p.2)) ∘ (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) := by ext1; simp\n          rw [this, ← map_map]\n          apply entropy_map_le _ _\n          apply FiniteKernelSupport.aefiniteKernelSupport\n          apply kernel.finiteKernelSupport_of_map hκη\n    _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n          have h : 0 ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n              + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ]\n              - Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _), μ] := by\n            have h' := mutualInfo_nonneg (κ := map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _)) (μ := μ) ?_\n            rwa [mutualInfo, fst_map_prod _ (measurable_of_countable _) (measurable_of_countable _),\n              snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h'\n            apply FiniteKernelSupport.aefiniteKernelSupport\n            apply kernel.finiteKernelSupport_of_map hκη\n          linarith\n  have h3 : Hk[map κ (fun p : G × G ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ]\n      ≤ Hk[κ, μ] := by\n    exact entropy_map_le _ (hκ.aefiniteKernelSupport _)\n  have h4 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n      (measurable_of_countable _), μ] = Hk[κ ×ₖ η, μ] := by\n    refine entropy_of_map_eq_of_map\n      (fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n      (fun p : (G × G) × G ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) ?_ ?_ ?_\n        (hκη.aefiniteKernelSupport _)\n    · rw [map_map]\n      suffices ((fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n          ∘ fun p ↦ (p.1.1 - p.2, p.1.2, p.1.1 - p.1.2)) = id by\n        simp_rw [this, map_id]\n      ext1 p\n      simp\n    · rfl\n    apply FiniteKernelSupport.aefiniteKernelSupport\n    apply kernel.finiteKernelSupport_of_map hκη\n  have h5 : Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n    rw [entropy_prod (hκ.aefiniteKernelSupport _) (hη.aefiniteKernelSupport _)]\n  rw [h4, h5] at h1\n  calc Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n    ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        linarith\n  _ = Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        congr 2\n        rw [← entropy_neg, map_map]\n        congr with p\n        simp\n  _ = Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      - Hk[η, μ] := by\n        congr 3\n        · ext x s hs\n          rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply', prod_apply', lintegral_fst]\n          · congr with x\n          · exact measurable_of_countable _\n          · exact measurable_sub hs\n          · exact measurable_of_countable _ hs\n        · exact ruzsa_triangle_aux κ η","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.182_0.2L1Uflhmlhotb94","decl":"/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (κ : kernel T (G × G)) (η : kernel T G) [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        - Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\nlemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] := by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]\n\nlemma rdist_nonneg {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    0 ≤ dk[κ ; μ # η ; ν] := by\n  suffices 0 ≤ 2 * dk[κ ; μ # η ; ν] by linarith\n  calc 0 ≤ |Hk[κ, μ] - Hk[η, ν]| := abs_nonneg _\n  _ ≤ 2 * dk[κ ; μ # η ; ν] := abs_sub_entropy_le_rdist hκ hη\n\n-- Kernel equivalent of `H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ]`\n-- `κ` is `⟨X,Y⟩`, `η` is `Z`. Independence is expressed through the product `×ₖ`.\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (κ : kernel T (G × G)) (η : kernel T G) [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        - Hk[η, μ] := by\n  have hκη := kernel.finiteKernelSupport_of_prod hκ hη\n  have h1 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n        (measurable_of_countable _), μ] + Hk[map κ (fun p ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n        + Hk[map κ (fun p ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ] := by\n    have h := entropy_triple_add_entropy_le\n      (map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) (measurable_of_countable _)) μ\n    simp only [snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h\n    rw [deleteMiddle_map_prod _ (measurable_of_countable _) (measurable_of_countable _)\n        (measurable_of_countable _)] at h\n    have : map (κ ×ₖ η) (fun x ↦ x.1.1 - x.1.2) (measurable_of_countable _)\n        = map κ (fun p ↦ p.1 - p.2) measurable_sub := by\n      have : (fun x : (G × G) × G ↦ x.1.1 - x.1.2)\n        = (fun x ↦ x.1 - x.2) ∘ Prod.fst := by ext1 y; simp\n      rw [this, ← map_map, ← kernel.fst, fst_prod]\n    rw [this] at h\n    refine (h ?_).trans_eq ?_\n    . apply FiniteKernelSupport.aefiniteKernelSupport\n      apply kernel.finiteKernelSupport_of_map\n      exact kernel.finiteKernelSupport_of_prod hκ hη\n    congr 2\n    have : (fun x : (G × G) × G ↦ (x.1.2, x.1.1 - x.1.2))\n      = (fun x ↦ (x.2, x.1 - x.2)) ∘ Prod.fst := by ext1 y; simp\n    rw [this, ← map_map, ← kernel.fst, fst_prod]\n  have h2 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n    calc Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) (measurable_of_countable _), μ] := by\n          have : (fun p : (G × G) × G ↦ (p.1.1 - p.2, p.1.1 - p.1.2))\n            = (fun p ↦ (p.1, p.1 - p.2)) ∘ (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) := by ext1; simp\n          rw [this, ← map_map]\n          apply entropy_map_le _ _\n          apply FiniteKernelSupport.aefiniteKernelSupport\n          apply kernel.finiteKernelSupport_of_map hκη\n    _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n          have h : 0 ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n              + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ]\n              - Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _), μ] := by\n            have h' := mutualInfo_nonneg (κ := map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _)) (μ := μ) ?_\n            rwa [mutualInfo, fst_map_prod _ (measurable_of_countable _) (measurable_of_countable _),\n              snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h'\n            apply FiniteKernelSupport.aefiniteKernelSupport\n            apply kernel.finiteKernelSupport_of_map hκη\n          linarith\n  have h3 : Hk[map κ (fun p : G × G ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ]\n      ≤ Hk[κ, μ] := by\n    exact entropy_map_le _ (hκ.aefiniteKernelSupport _)\n  have h4 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n      (measurable_of_countable _), μ] = Hk[κ ×ₖ η, μ] := by\n    refine entropy_of_map_eq_of_map\n      (fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n      (fun p : (G × G) × G ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) ?_ ?_ ?_\n        (hκη.aefiniteKernelSupport _)\n    · rw [map_map]\n      suffices ((fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n          ∘ fun p ↦ (p.1.1 - p.2, p.1.2, p.1.1 - p.1.2)) = id by\n        simp_rw [this, map_id]\n      ext1 p\n      simp\n    · rfl\n    apply FiniteKernelSupport.aefiniteKernelSupport\n    apply kernel.finiteKernelSupport_of_map hκη\n  have h5 : Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n    rw [entropy_prod (hκ.aefiniteKernelSupport _) (hη.aefiniteKernelSupport _)]\n  rw [h4, h5] at h1\n  calc Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n    ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        linarith\n  _ = Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        congr 2\n        rw [← entropy_neg, map_map]\n        congr with p\n        simp\n  _ = Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      - Hk[η, μ] := by\n        congr 3\n        · ext x s hs\n          rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply', prod_apply', lintegral_fst]\n          · congr with x\n          · exact measurable_of_countable _\n          · exact measurable_sub hs\n          · exact measurable_of_countable _ hs\n        · exact ruzsa_triangle_aux κ η\n\n-- note : Measure.prod should be made to use dot notation in the infoview\n\n","proof":":= by\n  have hAB : (μ.prod μ') ((μ.support ×ˢ μ'.support : Finset (T × T')) : Set (T × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ')\n  have hAC : (μ.prod μ'') ((μ.support ×ˢ μ''.support : Finset (T × T'')) : Set (T × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ'')\n  have hACB : (μ.prod μ'').prod μ'\n      (((μ.support ×ˢ μ''.support) ×ˢ μ'.support : Finset ((T × T'') × T')) : Set ((T × T'') × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet hAC (measure_compl_support μ')\n\n  simp_rw [entropy, integral_eq_sum' _ hAB, integral_eq_sum' _ hACB, smul_eq_mul,\n    Measure.prod_apply_singleton, Finset.sum_product, ENNReal.toReal_mul, mul_assoc,\n    ← Finset.mul_sum]\n  congr with x\n  have : ∀ z y, map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n        (fun p ↦ p.1 - p.2) measurable_sub ((x, z), y)\n      = map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun p ↦ p.1 - p.2) measurable_sub (x, y) := by\n    intro z y\n    ext s hs\n    rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply, prod_apply]\n    simp\n  simp_rw [this, ← Finset.sum_mul, Finset.sum_toReal_measure_singleton,\n    full_measure_of_null_compl (measure_compl_support μ'')]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.283_0.2L1Uflhmlhotb94","decl":"lemma rdist_triangle_aux1 (κ : kernel T G) (η : kernel T' G)\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ''] :\n    Hk[map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n          (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ.prod μ'] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\nlemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] := by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]\n\nlemma rdist_nonneg {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    0 ≤ dk[κ ; μ # η ; ν] := by\n  suffices 0 ≤ 2 * dk[κ ; μ # η ; ν] by linarith\n  calc 0 ≤ |Hk[κ, μ] - Hk[η, ν]| := abs_nonneg _\n  _ ≤ 2 * dk[κ ; μ # η ; ν] := abs_sub_entropy_le_rdist hκ hη\n\n-- Kernel equivalent of `H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ]`\n-- `κ` is `⟨X,Y⟩`, `η` is `Z`. Independence is expressed through the product `×ₖ`.\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (κ : kernel T (G × G)) (η : kernel T G) [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        - Hk[η, μ] := by\n  have hκη := kernel.finiteKernelSupport_of_prod hκ hη\n  have h1 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n        (measurable_of_countable _), μ] + Hk[map κ (fun p ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n        + Hk[map κ (fun p ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ] := by\n    have h := entropy_triple_add_entropy_le\n      (map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) (measurable_of_countable _)) μ\n    simp only [snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h\n    rw [deleteMiddle_map_prod _ (measurable_of_countable _) (measurable_of_countable _)\n        (measurable_of_countable _)] at h\n    have : map (κ ×ₖ η) (fun x ↦ x.1.1 - x.1.2) (measurable_of_countable _)\n        = map κ (fun p ↦ p.1 - p.2) measurable_sub := by\n      have : (fun x : (G × G) × G ↦ x.1.1 - x.1.2)\n        = (fun x ↦ x.1 - x.2) ∘ Prod.fst := by ext1 y; simp\n      rw [this, ← map_map, ← kernel.fst, fst_prod]\n    rw [this] at h\n    refine (h ?_).trans_eq ?_\n    . apply FiniteKernelSupport.aefiniteKernelSupport\n      apply kernel.finiteKernelSupport_of_map\n      exact kernel.finiteKernelSupport_of_prod hκ hη\n    congr 2\n    have : (fun x : (G × G) × G ↦ (x.1.2, x.1.1 - x.1.2))\n      = (fun x ↦ (x.2, x.1 - x.2)) ∘ Prod.fst := by ext1 y; simp\n    rw [this, ← map_map, ← kernel.fst, fst_prod]\n  have h2 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n    calc Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) (measurable_of_countable _), μ] := by\n          have : (fun p : (G × G) × G ↦ (p.1.1 - p.2, p.1.1 - p.1.2))\n            = (fun p ↦ (p.1, p.1 - p.2)) ∘ (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) := by ext1; simp\n          rw [this, ← map_map]\n          apply entropy_map_le _ _\n          apply FiniteKernelSupport.aefiniteKernelSupport\n          apply kernel.finiteKernelSupport_of_map hκη\n    _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n          have h : 0 ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n              + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ]\n              - Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _), μ] := by\n            have h' := mutualInfo_nonneg (κ := map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _)) (μ := μ) ?_\n            rwa [mutualInfo, fst_map_prod _ (measurable_of_countable _) (measurable_of_countable _),\n              snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h'\n            apply FiniteKernelSupport.aefiniteKernelSupport\n            apply kernel.finiteKernelSupport_of_map hκη\n          linarith\n  have h3 : Hk[map κ (fun p : G × G ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ]\n      ≤ Hk[κ, μ] := by\n    exact entropy_map_le _ (hκ.aefiniteKernelSupport _)\n  have h4 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n      (measurable_of_countable _), μ] = Hk[κ ×ₖ η, μ] := by\n    refine entropy_of_map_eq_of_map\n      (fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n      (fun p : (G × G) × G ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) ?_ ?_ ?_\n        (hκη.aefiniteKernelSupport _)\n    · rw [map_map]\n      suffices ((fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n          ∘ fun p ↦ (p.1.1 - p.2, p.1.2, p.1.1 - p.1.2)) = id by\n        simp_rw [this, map_id]\n      ext1 p\n      simp\n    · rfl\n    apply FiniteKernelSupport.aefiniteKernelSupport\n    apply kernel.finiteKernelSupport_of_map hκη\n  have h5 : Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n    rw [entropy_prod (hκ.aefiniteKernelSupport _) (hη.aefiniteKernelSupport _)]\n  rw [h4, h5] at h1\n  calc Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n    ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        linarith\n  _ = Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        congr 2\n        rw [← entropy_neg, map_map]\n        congr with p\n        simp\n  _ = Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      - Hk[η, μ] := by\n        congr 3\n        · ext x s hs\n          rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply', prod_apply', lintegral_fst]\n          · congr with x\n          · exact measurable_of_countable _\n          · exact measurable_sub hs\n          · exact measurable_of_countable _ hs\n        · exact ruzsa_triangle_aux κ η\n\n-- note : Measure.prod should be made to use dot notation in the infoview\n\nlemma rdist_triangle_aux1 (κ : kernel T G) (η : kernel T' G)\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ''] :\n    Hk[map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n          (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ.prod μ'] := by\n  have hAB : (μ.prod μ') ((μ.support ×ˢ μ'.support : Finset (T × T')) : Set (T × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ')\n  have hAC : (μ.prod μ'') ((μ.support ×ˢ μ''.support : Finset (T × T'')) : Set (T × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ'')\n  have hACB : (μ.prod μ'').prod μ'\n      (((μ.support ×ˢ μ''.support) ×ˢ μ'.support : Finset ((T × T'') × T')) : Set ((T × T'') × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet hAC (measure_compl_support μ')\n\n  simp_rw [entropy, integral_eq_sum' _ hAB, integral_eq_sum' _ hACB, smul_eq_mul,\n    Measure.prod_apply_singleton, Finset.sum_product, ENNReal.toReal_mul, mul_assoc,\n    ← Finset.mul_sum]\n  congr with x\n  have : ∀ z y, map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n        (fun p ↦ p.1 - p.2) measurable_sub ((x, z), y)\n      = map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun p ↦ p.1 - p.2) measurable_sub (x, y) := by\n    intro z y\n    ext s hs\n    rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply, prod_apply]\n    simp\n  simp_rw [this, ← Finset.sum_mul, Finset.sum_toReal_measure_singleton,\n    full_measure_of_null_compl (measure_compl_support μ'')]\n  simp\n\n","proof":":= by\n  have hBC: (μ'.prod μ'') ((μ'.support ×ˢ μ''.support : Finset (T' × T'')):Set (T' × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ') (measure_compl_support μ'')\n  have hAC: (μ.prod μ'') ((μ.support ×ˢ μ''.support : Finset (T × T'')):Set (T × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ'')\n  have hACB: (μ.prod μ'').prod μ' (((μ.support ×ˢ μ''.support) ×ˢ μ'.support : Finset ((T × T'') × T')):Set ((T × T'') × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet hAC (measure_compl_support μ')\n\n  simp_rw [entropy, integral_eq_sum' _ hACB, integral_eq_sum' _ hBC, smul_eq_mul, Measure.prod_apply_singleton]\n  conv_rhs => rw [Finset.sum_product_right]\n  conv_lhs => rw [Finset.sum_product, Finset.sum_product_right]\n  simp_rw [ENNReal.toReal_mul, mul_assoc, ← Finset.mul_sum]\n  congr with z\n  have : ∀ x y, map (prodMkLeft (T × T'') η ×ₖ prodMkRight T' (prodMkLeft T ξ))\n        (fun p ↦ p.1 - p.2) measurable_sub ((x, z), y)\n      = map (prodMkLeft T'' η ×ₖ prodMkRight T' ξ) (fun p ↦ p.1 - p.2) measurable_sub (z, y) := by\n    intro x y\n    ext s hs\n    rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply, prod_apply]\n    simp\n  simp_rw [this, ← Finset.sum_mul, Finset.sum_toReal_measure_singleton,\n    full_measure_of_null_compl (measure_compl_support μ), measure_univ, ENNReal.one_toReal,\n    one_mul, ← mul_assoc, mul_comm _ (μ'' {z}).toReal, mul_assoc, ← Finset.mul_sum, map_apply]\n  congr with y\n  congr 2 with s hs\n  rw [Measure.map_apply measurable_sub hs, Measure.map_apply measurable_sub hs, prod_apply,\n    prod_apply]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.315_0.2L1Uflhmlhotb94","decl":"lemma rdist_triangle_aux2 (η : kernel T' G) (ξ : kernel T'' G)\n    [IsMarkovKernel η] [IsMarkovKernel ξ]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ''] :\n    Hk[map (prodMkLeft (T × T'') η ×ₖ prodMkRight T' (prodMkLeft T ξ))\n      (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n    = Hk[map (prodMkRight T'' η ×ₖ prodMkLeft T' ξ) (fun x ↦ x.1 - x.2) measurable_sub,\n      μ'.prod μ''] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Kernel.Group\n\n/-!\n# Ruzsa distance between kernels\n\n## Main definitions\n\n*\n\n## Notations\n\n* `dk[κ ; μ # η ; ν] = `\n\n-/\n\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {T T' T'' G : Type*}\n  [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n  [Countable T'] [Nonempty T'] [MeasurableSpace T'] [MeasurableSingletonClass T']\n  [Countable T''] [Nonempty T''] [MeasurableSpace T''] [MeasurableSingletonClass T'']\n  [Countable G] [Nonempty G] [MeasurableSpace G] [MeasurableSingletonClass G]\n  [AddCommGroup G] [MeasurableSub₂ G] [MeasurableAdd₂ G]\n  {μ : Measure T} {ν : Measure T'}\n\n/-- The Rusza distance between two measures, defined as `H[X - Y] - H[X]/2 - H[Y]/2` where `X`\nand `Y` are independent variables distributed according to the two measures. -/\nnoncomputable\ndef rdistm (μ : Measure G) (ν : Measure G) : ℝ :=\n    Hm[(μ.prod ν).map (fun x ↦ x.1 - x.2)] - Hm[μ]/2 - Hm[ν]/2\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnoncomputable\ndef rdist (κ : kernel T G) (η : kernel T' G) (μ : Measure T) (ν : Measure T') : ℝ :=\n  (μ.prod ν)[fun p ↦ rdistm (κ p.1) (η p.2)]\n\n/-- The Rusza distance between two kernels taking values in the same space, defined as the average\nRusza distance between the image measures. -/\nnotation3:max \"dk[\" κ \" ; \" μ \" # \" η \" ; \" μ' \"]\" => rdist κ η μ μ'\n\nlemma rdist_eq {κ : kernel T G} {η : kernel T' G} {μ : Measure T} {ν : Measure T'}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = (μ.prod ν)[fun p ↦ Hm[((κ p.1).prod (η p.2)).map (fun x ↦ x.1 - x.2)]]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist]\n  simp_rw [rdistm]\n  rw [integral_sub, integral_sub]\n  · simp_rw [div_eq_mul_inv, integral_mul_right, integral_prod _ (integrable_of_finiteSupport _)]\n    simp [entropy]\n  all_goals { exact integrable_of_finiteSupport _ }\n\nlemma rdist_eq' {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] =\n      Hk[map ((prodMkRight T' κ) ×ₖ (prodMkLeft T η)) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod ν]\n      - Hk[κ, μ]/2 - Hk[η, ν]/2 := by\n  rw [rdist_eq]\n  congr with p\n  simp only\n  rw [map_apply, prod_apply, prodMkLeft_apply, prodMkRight_apply]\n\nlemma rdist_symm {κ : kernel T G} {η : kernel T' G} [IsFiniteKernel κ] [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # η ; ν] = dk[η ; ν # κ ; μ] := by\n  rw [rdist_eq', rdist_eq', sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_comap_swap, comap_map_comm, entropy_sub_comm, Measure.comap_swap, Measure.prod_swap,\n    comap_prod_swap, map_map]\n  congr\n\n@[simp] lemma rdist_zero_right (κ : kernel T G) (η : kernel T' G) (μ : Measure T) :\n    dk[κ ; μ # η ; 0] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_left (κ : kernel T G) (η : kernel T' G) (ν' : Measure T') :\n    dk[κ ; 0 # η ; ν'] = 0 := by\n  simp [rdist]\n\n@[simp] lemma rdist_zero_kernel_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # 0 ; ν] = - Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [prodMkLeft_zero, entropy_zero_kernel, zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ 0) (fun x ↦ x.1 - x.2) measurable_sub\n      = 0 := by\n    ext1 x\n    rw [map_apply, prod_apply]\n    simp\n  rw [this, entropy_zero_kernel]\n\n@[simp] lemma rdist_zero_kernel_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[0 ; μ # η ; ν] = - Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_zero_kernel_right]\n\n@[simp] lemma rdist_dirac_zero_right {κ : kernel T G} [IsFiniteKernel κ]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[κ ; μ # const T' (Measure.dirac 0) ; ν] = Hk[κ, μ] / 2 := by\n  rw [rdist_eq']\n  simp only [entropy_const, measure_univ, ENNReal.one_toReal, measureEntropy_dirac, mul_zero,\n    zero_div, sub_zero]\n  rw [sub_eq_iff_eq_add]\n  ring_nf\n  have : map (prodMkRight T' κ ×ₖ prodMkLeft T (const T' (Measure.dirac 0)))\n        (fun x ↦ x.1 - x.2) measurable_sub\n      = prodMkRight T' κ := by\n    ext x s hs\n    rw [prodMkRight_apply, map_apply, prod_apply, prodMkLeft_apply, const_apply,\n      prodMkRight_apply, Measure.map_apply measurable_sub hs,\n      Measure.prod_apply (measurable_sub hs)]\n    simp only [Set.mem_preimage, sub_zero, Measure.dirac_apply]\n    have : ∀ x : G, Prod.mk x ⁻¹' ((fun p : G × G ↦ p.1 - p.2) ⁻¹' s) = {y | x - y ∈ s} := by\n      intro x\n      ext y\n      simp\n    simp_rw [this]\n    have : ∀ x : G, Set.indicator {y | x - y ∈ s} (1 : G → ℝ≥0∞) 0 = s.indicator (fun _ ↦ 1) x := by\n      intro x\n      by_cases hx : x ∈ s <;> simp [hx]\n    simp_rw [this]\n    rw [lintegral_indicator_const hs, one_mul]\n  rw [this, entropy_prodMkRight']\n\n@[simp] lemma rdist_dirac_zero_left {η : kernel T' G} [IsFiniteKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    dk[const T (Measure.dirac 0) ; μ # η ; ν] = Hk[η, ν] / 2 := by\n  rw [rdist_symm, rdist_dirac_zero_right]\n\nlemma ruzsa_triangle_aux (κ : kernel T (G × G)) (η : kernel T G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] :\n    map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _)\n      = map (η ×ₖ snd κ) (fun p ↦ p.1 - p.2) (measurable_of_countable _) := by\n  have : (fun p : G × G ↦ p.1 - p.2) = (fun p ↦ p.2 - p.1) ∘ Prod.swap := by ext1 p; simp\n  rw [this, ← map_map _ measurable_swap (measurable_of_countable _), map_prod_swap]\n  ext x s hs\n  rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply' _ _ _ (measurable_of_countable _ hs),\n    prod_apply' _ _ _ (measurable_of_countable _ hs), lintegral_snd _ _ (measurable_of_countable _)]\n  congr\n\nlemma abs_sub_entropy_le_rdist {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    |Hk[κ, μ] - Hk[η, ν]| ≤ 2 * dk[κ ; μ # η ; ν] := by\n  have h := max_entropy_le_entropy_sub_prod (prodMkRight T' κ) (prodMkLeft T η) (μ.prod ν)\n    (hκ.prodMkRight ν) (hη.prodMkLeft μ)\n  rw [entropy_prodMkRight', entropy_prodMkLeft] at h\n  rw [rdist_eq', abs_le]\n  constructor\n  · linarith [le_max_right (Hk[κ, μ]) (Hk[η, ν])]\n  · linarith [le_max_left (Hk[κ, μ]) (Hk[η, ν])]\n\nlemma rdist_nonneg {κ : kernel T G} {η : kernel T' G}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} {ν : Measure T'} [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η ν) :\n    0 ≤ dk[κ ; μ # η ; ν] := by\n  suffices 0 ≤ 2 * dk[κ ; μ # η ; ν] by linarith\n  calc 0 ≤ |Hk[κ, μ] - Hk[η, ν]| := abs_nonneg _\n  _ ≤ 2 * dk[κ ; μ # η ; ν] := abs_sub_entropy_le_rdist hκ hη\n\n-- Kernel equivalent of `H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ]`\n-- `κ` is `⟨X,Y⟩`, `η` is `Z`. Independence is expressed through the product `×ₖ`.\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (κ : kernel T (G × G)) (η : kernel T G) [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n        - Hk[η, μ] := by\n  have hκη := kernel.finiteKernelSupport_of_prod hκ hη\n  have h1 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n        (measurable_of_countable _), μ] + Hk[map κ (fun p ↦ p.1 - p.2) measurable_sub, μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n        + Hk[map κ (fun p ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ] := by\n    have h := entropy_triple_add_entropy_le\n      (map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) (measurable_of_countable _)) μ\n    simp only [snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h\n    rw [deleteMiddle_map_prod _ (measurable_of_countable _) (measurable_of_countable _)\n        (measurable_of_countable _)] at h\n    have : map (κ ×ₖ η) (fun x ↦ x.1.1 - x.1.2) (measurable_of_countable _)\n        = map κ (fun p ↦ p.1 - p.2) measurable_sub := by\n      have : (fun x : (G × G) × G ↦ x.1.1 - x.1.2)\n        = (fun x ↦ x.1 - x.2) ∘ Prod.fst := by ext1 y; simp\n      rw [this, ← map_map, ← kernel.fst, fst_prod]\n    rw [this] at h\n    refine (h ?_).trans_eq ?_\n    . apply FiniteKernelSupport.aefiniteKernelSupport\n      apply kernel.finiteKernelSupport_of_map\n      exact kernel.finiteKernelSupport_of_prod hκ hη\n    congr 2\n    have : (fun x : (G × G) × G ↦ (x.1.2, x.1.1 - x.1.2))\n      = (fun x ↦ (x.2, x.1 - x.2)) ∘ Prod.fst := by ext1 y; simp\n    rw [this, ← map_map, ← kernel.fst, fst_prod]\n  have h2 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n    calc Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.1 - p.1.2)) (measurable_of_countable _), μ]\n      ≤ Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) (measurable_of_countable _), μ] := by\n          have : (fun p : (G × G) × G ↦ (p.1.1 - p.2, p.1.1 - p.1.2))\n            = (fun p ↦ (p.1, p.1 - p.2)) ∘ (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2)) := by ext1; simp\n          rw [this, ← map_map]\n          apply entropy_map_le _ _\n          apply FiniteKernelSupport.aefiniteKernelSupport\n          apply kernel.finiteKernelSupport_of_map hκη\n    _ ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n        + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] := by\n          have h : 0 ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n              + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ]\n              - Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _), μ] := by\n            have h' := mutualInfo_nonneg (κ := map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, p.1.2 - p.2))\n                (measurable_of_countable _)) (μ := μ) ?_\n            rwa [mutualInfo, fst_map_prod _ (measurable_of_countable _) (measurable_of_countable _),\n              snd_map_prod _ (measurable_of_countable _) (measurable_of_countable _)] at h'\n            apply FiniteKernelSupport.aefiniteKernelSupport\n            apply kernel.finiteKernelSupport_of_map hκη\n          linarith\n  have h3 : Hk[map κ (fun p : G × G ↦ (p.2, p.1 - p.2)) (measurable_of_countable _), μ]\n      ≤ Hk[κ, μ] := by\n    exact entropy_map_le _ (hκ.aefiniteKernelSupport _)\n  have h4 : Hk[map (κ ×ₖ η) (fun p ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2)))\n      (measurable_of_countable _), μ] = Hk[κ ×ₖ η, μ] := by\n    refine entropy_of_map_eq_of_map\n      (fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n      (fun p : (G × G) × G ↦ (p.1.1 - p.2, (p.1.2, p.1.1 - p.1.2))) ?_ ?_ ?_\n        (hκη.aefiniteKernelSupport _)\n    · rw [map_map]\n      suffices ((fun p : G × G × G ↦ ((p.2.2 + p.2.1, p.2.1), -p.1 + p.2.2 + p.2.1))\n          ∘ fun p ↦ (p.1.1 - p.2, p.1.2, p.1.1 - p.1.2)) = id by\n        simp_rw [this, map_id]\n      ext1 p\n      simp\n    · rfl\n    apply FiniteKernelSupport.aefiniteKernelSupport\n    apply kernel.finiteKernelSupport_of_map hκη\n  have h5 : Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n    rw [entropy_prod (hκ.aefiniteKernelSupport _) (hη.aefiniteKernelSupport _)]\n  rw [h4, h5] at h1\n  calc Hk[map κ (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n    ≤ Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.1.2 - p.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        linarith\n  _ = Hk[map (κ ×ₖ η) (fun p ↦ p.1.1 - p.2) (measurable_of_countable _), μ]\n      + Hk[map (κ ×ₖ η) (fun p ↦ p.2 - p.1.2) (measurable_of_countable _), μ] - Hk[η, μ] := by\n        congr 2\n        rw [← entropy_neg, map_map]\n        congr with p\n        simp\n  _ = Hk[map ((fst κ) ×ₖ η) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      + Hk[map (η ×ₖ (snd κ)) (fun p : G × G ↦ p.1 - p.2) measurable_sub, μ]\n      - Hk[η, μ] := by\n        congr 3\n        · ext x s hs\n          rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply', prod_apply', lintegral_fst]\n          · congr with x\n          · exact measurable_of_countable _\n          · exact measurable_sub hs\n          · exact measurable_of_countable _ hs\n        · exact ruzsa_triangle_aux κ η\n\n-- note : Measure.prod should be made to use dot notation in the infoview\n\nlemma rdist_triangle_aux1 (κ : kernel T G) (η : kernel T' G)\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ''] :\n    Hk[map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n          (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ.prod μ'] := by\n  have hAB : (μ.prod μ') ((μ.support ×ˢ μ'.support : Finset (T × T')) : Set (T × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ')\n  have hAC : (μ.prod μ'') ((μ.support ×ˢ μ''.support : Finset (T × T'')) : Set (T × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ'')\n  have hACB : (μ.prod μ'').prod μ'\n      (((μ.support ×ˢ μ''.support) ×ˢ μ'.support : Finset ((T × T'') × T')) : Set ((T × T'') × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet hAC (measure_compl_support μ')\n\n  simp_rw [entropy, integral_eq_sum' _ hAB, integral_eq_sum' _ hACB, smul_eq_mul,\n    Measure.prod_apply_singleton, Finset.sum_product, ENNReal.toReal_mul, mul_assoc,\n    ← Finset.mul_sum]\n  congr with x\n  have : ∀ z y, map (prodMkRight T' (prodMkRight T'' κ) ×ₖ prodMkLeft (T × T'') η)\n        (fun p ↦ p.1 - p.2) measurable_sub ((x, z), y)\n      = map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun p ↦ p.1 - p.2) measurable_sub (x, y) := by\n    intro z y\n    ext s hs\n    rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply, prod_apply]\n    simp\n  simp_rw [this, ← Finset.sum_mul, Finset.sum_toReal_measure_singleton,\n    full_measure_of_null_compl (measure_compl_support μ'')]\n  simp\n\nlemma rdist_triangle_aux2 (η : kernel T' G) (ξ : kernel T'' G)\n    [IsMarkovKernel η] [IsMarkovKernel ξ]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ''] :\n    Hk[map (prodMkLeft (T × T'') η ×ₖ prodMkRight T' (prodMkLeft T ξ))\n      (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n    = Hk[map (prodMkRight T'' η ×ₖ prodMkLeft T' ξ) (fun x ↦ x.1 - x.2) measurable_sub,\n      μ'.prod μ''] := by\n  have hBC: (μ'.prod μ'') ((μ'.support ×ˢ μ''.support : Finset (T' × T'')):Set (T' × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ') (measure_compl_support μ'')\n  have hAC: (μ.prod μ'') ((μ.support ×ˢ μ''.support : Finset (T × T'')):Set (T × T''))ᶜ = 0 :=\n    prod_of_full_measure_finSet (measure_compl_support μ) (measure_compl_support μ'')\n  have hACB: (μ.prod μ'').prod μ' (((μ.support ×ˢ μ''.support) ×ˢ μ'.support : Finset ((T × T'') × T')):Set ((T × T'') × T'))ᶜ = 0 :=\n    prod_of_full_measure_finSet hAC (measure_compl_support μ')\n\n  simp_rw [entropy, integral_eq_sum' _ hACB, integral_eq_sum' _ hBC, smul_eq_mul, Measure.prod_apply_singleton]\n  conv_rhs => rw [Finset.sum_product_right]\n  conv_lhs => rw [Finset.sum_product, Finset.sum_product_right]\n  simp_rw [ENNReal.toReal_mul, mul_assoc, ← Finset.mul_sum]\n  congr with z\n  have : ∀ x y, map (prodMkLeft (T × T'') η ×ₖ prodMkRight T' (prodMkLeft T ξ))\n        (fun p ↦ p.1 - p.2) measurable_sub ((x, z), y)\n      = map (prodMkLeft T'' η ×ₖ prodMkRight T' ξ) (fun p ↦ p.1 - p.2) measurable_sub (z, y) := by\n    intro x y\n    ext s hs\n    rw [map_apply' _ _ _ hs, map_apply' _ _ _ hs, prod_apply, prod_apply]\n    simp\n  simp_rw [this, ← Finset.sum_mul, Finset.sum_toReal_measure_singleton,\n    full_measure_of_null_compl (measure_compl_support μ), measure_univ, ENNReal.one_toReal,\n    one_mul, ← mul_assoc, mul_comm _ (μ'' {z}).toReal, mul_assoc, ← Finset.mul_sum, map_apply]\n  congr with y\n  congr 2 with s hs\n  rw [Measure.map_apply measurable_sub hs, Measure.map_apply measurable_sub hs, prod_apply,\n    prod_apply]\n  simp\n\n","proof":":= by\n  rw [rdist_eq', rdist_eq', rdist_eq']\n  have h := ent_of_diff_le (prodMkRight T' (prodMkRight T'' κ ×ₖ prodMkLeft T ξ))\n    (prodMkLeft (T × T'') η) ((μ.prod μ'').prod μ') ?_ ?_\n  rotate_left\n  . apply kernel.finiteKernelSupport_of_prodMkRight\n    apply kernel.finiteKernelSupport_of_prod\n    . exact kernel.finiteKernelSupport_of_prodMkRight hκ\n    exact kernel.finiteKernelSupport_of_prodMkLeft hξ\n  . apply kernel.finiteKernelSupport_of_prodMkLeft hη\n  have h1 : Hk[map (prodMkRight T' (prodMkRight T'' κ ×ₖ prodMkLeft T ξ)) (fun p ↦ p.1 - p.2)\n        measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T'' κ ×ₖ prodMkLeft T ξ) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ.prod μ''] := by\n    rw [map_prodMkRight, entropy_prodMkRight']\n  have h2 :\n      Hk[map (fst (prodMkRight T' (prodMkRight T'' κ ×ₖ prodMkLeft T ξ)) ×ₖ prodMkLeft (T × T'') η)\n          (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ.prod μ'] := by\n    rw [fst_prodMkRight, fst_prod]\n    exact rdist_triangle_aux1 _ _ _ _ _\n  have h3 :\n      Hk[map (prodMkLeft (T × T'') η ×ₖ snd (prodMkRight T' (prodMkRight T'' κ ×ₖ prodMkLeft T ξ)))\n        (fun p ↦ p.1 - p.2) measurable_sub, (μ.prod μ'').prod μ']\n      = Hk[map (prodMkRight T'' η ×ₖ prodMkLeft T' ξ) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ'.prod μ''] := by\n    rw [snd_prodMkRight, snd_prod]\n    exact rdist_triangle_aux2 _ _ _ _ _\n  have h4 : Hk[prodMkLeft (T × T'') η, (μ.prod μ'').prod μ'] = Hk[η, μ'] := entropy_prodMkLeft\n  rw [h1, h2, h3, h4] at h\n  calc Hk[map (prodMkRight T'' κ ×ₖ prodMkLeft T ξ) (fun x ↦ x.1 - x.2) _ , μ.prod μ'']\n      - Hk[κ , μ] / 2 - Hk[ξ , μ''] / 2\n    ≤ Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) measurable_sub, μ.prod μ']\n      + Hk[map (prodMkRight T'' η ×ₖ prodMkLeft T' ξ) (fun x ↦ x.1 - x.2) measurable_sub,\n        μ'.prod μ'']\n      - Hk[η, μ'] - Hk[κ , μ] / 2 - Hk[ξ , μ''] / 2 := by gcongr\n  _ = Hk[map (prodMkRight T' κ ×ₖ prodMkLeft T η) (fun x ↦ x.1 - x.2) _ , μ.prod μ']\n      - Hk[κ , μ] / 2 - Hk[η , μ'] / 2\n      + (Hk[map (prodMkRight T'' η ×ₖ prodMkLeft T' ξ) (fun x ↦ x.1 - x.2) _ , μ'.prod μ'']\n      - Hk[η , μ'] / 2 - Hk[ξ , μ''] / 2) := by ring","declId":"PFR.ForMathlib.Entropy.Kernel.RuzsaDist.352_0.2L1Uflhmlhotb94","decl":"lemma rdist_triangle (κ : kernel T G) (η : kernel T' G) (ξ : kernel T'' G)\n    [IsMarkovKernel κ] [IsMarkovKernel η] [IsMarkovKernel ξ]\n    (μ : Measure T) (μ' : Measure T') (μ'' : Measure T'')\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [IsProbabilityMeasure μ'']\n    [FiniteSupport μ] [FiniteSupport μ'] [FiniteSupport μ'']\n    (hκ: FiniteKernelSupport κ) (hη: FiniteKernelSupport η) (hξ: FiniteKernelSupport ξ) :\n    dk[κ ; μ # ξ ; μ''] ≤ dk[κ ; μ # η ; μ'] + dk[η ; μ' # ξ ; μ''] "}
