{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\n","proof":":= h_indep","declId":"PFR.Mathlib.Probability.Independence.FourVariables.14_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.17_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.29_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.41_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.53_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.65_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.77_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.89_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.101_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.113_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.125_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.137_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.149_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.161_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.173_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 0, 2],\n    invFun := ![2, 1, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.185_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_dbac :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₁, Z₃] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbac :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 0, 2],\n    invFun := ![2, 1, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\n","proof":":= by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 2, 0],\n    invFun := ![3, 1, 2, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.197_0.AJxyLf7D9YDARxH","decl":"lemma reindex_four_dbca :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₃, Z₁] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbac :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 0, 2],\n    invFun := ![2, 1, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbca :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 2, 0],\n    invFun := ![3, 1, 2, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nabbrev κ : Fin 3 → Type\n  | 0 | 1 => Fin 1\n  | 2     => Fin 2\n\n","proof":":= fun x ↦ match x with\n    | Sigma.mk 0 _ => 0\n    | Sigma.mk 1 _ => 1\n    | Sigma.mk 2 ⟨0, _⟩ => 2\n    | Sigma.mk 2 ⟨1, _⟩ => 3\n  invFun := ![Sigma.mk 0 ⟨0, zero_lt_one⟩, Sigma.mk 1 ⟨0, zero_lt_one⟩,\n    Sigma.mk 2 ⟨0, zero_lt_two⟩, Sigma.mk 2 ⟨1, one_lt_two⟩]\n  left_inv := by rintro ⟨i, j⟩; fin_cases i <;> fin_cases j <;> rfl\n  right_inv := by intro i; fin_cases i <;> rfl","declId":"PFR.Mathlib.Probability.Independence.FourVariables.213_0.AJxyLf7D9YDARxH","decl":"private def κ_equiv : (Σ i, κ i) ≃ Fin 4 where\n  toFun "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbac :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 0, 2],\n    invFun := ![2, 1, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbca :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 2, 0],\n    invFun := ![3, 1, 2, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nabbrev κ : Fin 3 → Type\n  | 0 | 1 => Fin 1\n  | 2     => Fin 2\n\nprivate def κ_equiv : (Σ i, κ i) ≃ Fin 4 where\n  toFun := fun x ↦ match x with\n    | Sigma.mk 0 _ => 0\n    | Sigma.mk 1 _ => 1\n    | Sigma.mk 2 ⟨0, _⟩ => 2\n    | Sigma.mk 2 ⟨1, _⟩ => 3\n  invFun := ![Sigma.mk 0 ⟨0, zero_lt_one⟩, Sigma.mk 1 ⟨0, zero_lt_one⟩,\n    Sigma.mk 2 ⟨0, zero_lt_two⟩, Sigma.mk 2 ⟨1, one_lt_two⟩]\n  left_inv := by rintro ⟨i, j⟩; fin_cases i <;> fin_cases j <;> rfl\n  right_inv := by intro i; fin_cases i <;> rfl\n\nprivate def fintype_kappa : ∀ (i : Fin 3), Fintype (κ i)\n  | 0 | 1 | 2 => inferInstanceAs (Fintype (Fin _))\n\nattribute [local instance] fintype_kappa in\n","proof":":= by\n  -- deduce from the assumption the independence of `Z₁`, `Z₂` and `(Z₃, Z₄)`.\n  have T := iIndepFun.pi' (m := fun  _ _ ↦ hG) ?_ (h_indep.reindex_symm κ_equiv); swap\n  · rintro ⟨i, j⟩; fin_cases i <;> fin_cases j <;> assumption\n  -- apply to this triplet of independent variables the function `phi` applied to `Z₃` and `Z₄`\n  -- which does not change the other variables. It retains independence, proving the conclusion.\n  let phi_third : ∀ (i : Fin 3), (κ i → G) → G\n    | 0 | 1 => (fun f ↦ f ⟨0, zero_lt_one⟩)\n    | 2     => (fun f ↦ phi (f ⟨0, zero_lt_two⟩) (f ⟨1, one_lt_two⟩))\n  convert T.comp phi_third ?_ with i\n  · fin_cases i <;> rfl\n  · intro i\n    match i with\n      | 0 | 1 => exact measurable_pi_apply _\n      | 2     => have : Measurable (fun (p : Fin 2 → G) ↦ (p 0, p 1)) := by measurability\n                 exact hphi.comp this","declId":"PFR.Mathlib.Probability.Independence.FourVariables.228_0.AJxyLf7D9YDARxH","decl":"/-- If `(Z₁, Z₂, Z₃, Z₄)` are independent, so are `(Z₁, Z₂, φ Z₃ Z₄)` for any measurable `φ`. -/\nlemma apply_two_last {phi : G → G → G} (hphi : Measurable phi.uncurry) :\n    iIndepFun (fun _ ↦ hG) ![Z₁, Z₂, (fun ω ↦ phi (Z₃ ω) (Z₄ ω))] "}
{"srcUpToDecl":"import PFR.Mathlib.Probability.Independence.Basic\nimport Mathlib.Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nnamespace ProbabilityTheory.iIndepFun\n\nvariable {Ω : Type*} [MeasureSpace Ω] [IsProbabilityMeasure (ℙ : Measure Ω)]\n  {G : Type*} [hG : MeasurableSpace G]\n\nvariable {Z₁ Z₂ Z₃ Z₄ : Ω → G} (h_indep : iIndepFun (fun _i => hG) ![Z₁, Z₂, Z₃, Z₄])\n  (hZ₁ : Measurable Z₁) (hZ₂ : Measurable Z₂) (hZ₃ : Measurable Z₃) (hZ₄ : Measurable Z₄)\n\nlemma reindex_four_abcd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₃, Z₄] := h_indep\n\nlemma reindex_four_abdc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₂, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 1, 3, 2],\n    invFun := ![0, 1, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acbd :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₂, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 1, 3],\n    invFun := ![0, 2, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_acdb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₃, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 2, 3, 1],\n    invFun := ![0, 3, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adbc :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 1, 2],\n    invFun := ![0, 2, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_adcb :\n    iIndepFun (fun _ => hG) ![Z₁, Z₄, Z₃, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![0, 3, 2, 1],\n    invFun := ![0, 3, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bacd :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₃, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 2, 3],\n    invFun := ![1, 0, 2, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_badc :\n    iIndepFun (fun _ => hG) ![Z₂, Z₁, Z₄, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 0, 3, 2],\n    invFun := ![1, 0, 3, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcad :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 0, 3],\n    invFun := ![2, 0, 1, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bcda :\n    iIndepFun (fun _ => hG) ![Z₂, Z₃, Z₄, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 2, 3, 0],\n    invFun := ![3, 0, 1, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdac :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 0, 2],\n    invFun := ![2, 0, 3, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_bdca :\n    iIndepFun (fun _ => hG) ![Z₂, Z₄, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![1, 3, 2, 0],\n    invFun := ![3, 0, 2, 1],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cadb :\n    iIndepFun (fun _ => hG) ![Z₃, Z₁, Z₄, Z₂] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 0, 3, 1],\n    invFun := ![1, 3, 0, 2],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_cbad :\n    iIndepFun (fun _ => hG) ![Z₃, Z₂, Z₁, Z₄] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![2, 1, 0, 3],\n    invFun := ![2, 1, 0, 3],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dabc :\n    iIndepFun (fun _ => hG) ![Z₄, Z₁, Z₂, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 0, 1, 2],\n    invFun := ![1, 2, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbac :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₁, Z₃] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 0, 2],\n    invFun := ![2, 1, 3, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nlemma reindex_four_dbca :\n    iIndepFun (fun _ => hG) ![Z₄, Z₂, Z₃, Z₁] := by\n  let σ : Fin 4 ≃ Fin 4 :=\n  { toFun := ![3, 1, 2, 0],\n    invFun := ![3, 1, 2, 0],\n    left_inv := by intro i; fin_cases i <;> rfl,\n    right_inv := by intro i; fin_cases i <;> rfl }\n  refine iIndepFun.reindex σ.symm ?_\n  convert h_indep using 1\n  ext i\n  fin_cases i <;> rfl\n\nabbrev κ : Fin 3 → Type\n  | 0 | 1 => Fin 1\n  | 2     => Fin 2\n\nprivate def κ_equiv : (Σ i, κ i) ≃ Fin 4 where\n  toFun := fun x ↦ match x with\n    | Sigma.mk 0 _ => 0\n    | Sigma.mk 1 _ => 1\n    | Sigma.mk 2 ⟨0, _⟩ => 2\n    | Sigma.mk 2 ⟨1, _⟩ => 3\n  invFun := ![Sigma.mk 0 ⟨0, zero_lt_one⟩, Sigma.mk 1 ⟨0, zero_lt_one⟩,\n    Sigma.mk 2 ⟨0, zero_lt_two⟩, Sigma.mk 2 ⟨1, one_lt_two⟩]\n  left_inv := by rintro ⟨i, j⟩; fin_cases i <;> fin_cases j <;> rfl\n  right_inv := by intro i; fin_cases i <;> rfl\n\nprivate def fintype_kappa : ∀ (i : Fin 3), Fintype (κ i)\n  | 0 | 1 | 2 => inferInstanceAs (Fintype (Fin _))\n\n","proof":":= by\n  -- deduce from the assumption the independence of `Z₁`, `Z₂` and `(Z₃, Z₄)`.\n  have T := iIndepFun.pi' (m := fun  _ _ ↦ hG) ?_ (h_indep.reindex_symm κ_equiv); swap\n  · rintro ⟨i, j⟩; fin_cases i <;> fin_cases j <;> assumption\n  -- apply to this triplet of independent variables the function `phi` applied to `Z₃` and `Z₄`\n  -- which does not change the other variables. It retains independence, proving the conclusion.\n  let phi_third : ∀ (i : Fin 3), (κ i → G) → G\n    | 0 | 1 => (fun f ↦ f ⟨0, zero_lt_one⟩)\n    | 2     => (fun f ↦ phi (f ⟨0, zero_lt_two⟩) (f ⟨1, one_lt_two⟩))\n  convert T.comp phi_third ?_ with i\n  · fin_cases i <;> rfl\n  · intro i\n    match i with\n      | 0 | 1 => exact measurable_pi_apply _\n      | 2     => have : Measurable (fun (p : Fin 2 → G) ↦ (p 0, p 1)) := by measurability\n                 exact hphi.comp this","declId":"PFR.Mathlib.Probability.Independence.FourVariables.227_0.AJxyLf7D9YDARxH","decl":"attribute [local instance] fintype_kappa in\n/-- If `(Z₁, Z₂, Z₃, Z₄)` are independent, so are `(Z₁, Z₂, φ Z₃ Z₄)` for any measurable `φ`. -/\nlemma apply_two_last {phi : G → G → G} (hphi : Measurable phi.uncurry) :\n    iIndepFun (fun _ ↦ hG) ![Z₁, Z₂, (fun ω ↦ phi (Z₃ ω) (Z₄ ω))] "}
