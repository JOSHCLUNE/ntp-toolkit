{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\n","proof":":= by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.38_0.ufBrwspFU8fxzAk","decl":"lemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\n","proof":":= by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.57_0.ufBrwspFU8fxzAk","decl":"lemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\n","proof":":= by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.75_0.ufBrwspFU8fxzAk","decl":"lemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\n","proof":":= by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.86_0.ufBrwspFU8fxzAk","decl":"lemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n","proof":":= μ[fun y ↦ Hm[κ y]]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.98_0.ufBrwspFU8fxzAk","decl":"/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n","proof":":= by simp [entropy]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.105_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n","proof":":= by simp [entropy]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.108_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\n","proof":":= by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.111_0.ufBrwspFU8fxzAk","decl":"lemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\n","proof":":= integral_nonneg (fun _ ↦ measureEntropy_nonneg _)","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.117_0.ufBrwspFU8fxzAk","decl":"lemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n","proof":":= by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.120_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n","proof":":=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.126_0.ufBrwspFU8fxzAk","decl":"/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\n","proof":":=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.130_0.ufBrwspFU8fxzAk","decl":"noncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\n","proof":":=\n  ae_of_all μ hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.133_0.ufBrwspFU8fxzAk","decl":"lemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\n","proof":":= by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.138_0.ufBrwspFU8fxzAk","decl":"noncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\n","proof":":= by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.145_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\n","proof":":= by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.156_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\n","proof":":= by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.162_0.ufBrwspFU8fxzAk","decl":"instance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\n","proof":":= by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.168_0.ufBrwspFU8fxzAk","decl":"lemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n","proof":":= by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.175_0.ufBrwspFU8fxzAk","decl":"/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n","proof":":= by\n  intro t\n  use Finset.univ\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.187_0.ufBrwspFU8fxzAk","decl":"/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n","proof":":= by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.193_0.ufBrwspFU8fxzAk","decl":"/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n","proof":":= by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.201_0.ufBrwspFU8fxzAk","decl":"/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n","proof":":= by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.213_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n","proof":":= by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.223_0.ufBrwspFU8fxzAk","decl":"/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\n","proof":":= by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.232_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n","proof":":=\n  finiteKernelSupport_of_map hκ measurable_fst","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.243_0.ufBrwspFU8fxzAk","decl":"/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\n","proof":":=\n  hκ.map measurable_fst","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.248_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n","proof":":=\n  finiteKernelSupport_of_map hκ measurable_snd","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.253_0.ufBrwspFU8fxzAk","decl":"/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\n","proof":":=\n  hκ.map measurable_snd","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.258_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n","proof":":= by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.263_0.ufBrwspFU8fxzAk","decl":"/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n","proof":":=\n  finiteKernelSupport_of_map hκ measurable_swap","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.289_0.ufBrwspFU8fxzAk","decl":"/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\n","proof":":=\n  hκ.map measurable_swap","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.294_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n","proof":":= by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.299_0.ufBrwspFU8fxzAk","decl":"/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n","proof":":= by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.306_0.ufBrwspFU8fxzAk","decl":"/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\n","proof":":= by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.321_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n","proof":":= by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.330_0.ufBrwspFU8fxzAk","decl":"/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\n","proof":":= by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.345_0.ufBrwspFU8fxzAk","decl":"lemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n","proof":":=\n  finiteKernelSupport_of_comap hκ _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.356_0.ufBrwspFU8fxzAk","decl":"/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\n","proof":":= by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.361_0.ufBrwspFU8fxzAk","decl":"protected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n","proof":":=\n  finiteKernelSupport_of_comap hκ _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.374_0.ufBrwspFU8fxzAk","decl":"/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\n","proof":":= by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.379_0.ufBrwspFU8fxzAk","decl":"protected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n","proof":":= by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.393_0.ufBrwspFU8fxzAk","decl":"/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\n","proof":":= by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.409_0.ufBrwspFU8fxzAk","decl":"lemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\n","proof":":= by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.415_0.ufBrwspFU8fxzAk","decl":"lemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\n","proof":":= by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.422_0.ufBrwspFU8fxzAk","decl":"lemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\n","proof":":= by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.429_0.ufBrwspFU8fxzAk","decl":"lemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\n","proof":":= by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.434_0.ufBrwspFU8fxzAk","decl":"lemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\n","proof":":= by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.451_0.ufBrwspFU8fxzAk","decl":"lemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\n","proof":":= entropy_map_of_injective κ μ Prod.swap_injective _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.456_0.ufBrwspFU8fxzAk","decl":"lemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\n","proof":":= by\n  rw [swapRight, entropy_map_swap]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.459_0.ufBrwspFU8fxzAk","decl":"lemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\n","proof":":= by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.463_0.ufBrwspFU8fxzAk","decl":"lemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\n","proof":":= by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.486_0.ufBrwspFU8fxzAk","decl":"lemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\n","proof":":= by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.499_0.ufBrwspFU8fxzAk","decl":"instance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\n","proof":":= by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.507_0.ufBrwspFU8fxzAk","decl":"lemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\n","proof":":=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.516_0.ufBrwspFU8fxzAk","decl":"lemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n","proof":":= fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.522_0.ufBrwspFU8fxzAk","decl":"/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\n","proof":":= by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.531_0.ufBrwspFU8fxzAk","decl":"lemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\n","proof":":= by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.539_0.ufBrwspFU8fxzAk","decl":"lemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\n","proof":":= by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.598_0.ufBrwspFU8fxzAk","decl":"lemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\n","proof":":= by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.610_0.ufBrwspFU8fxzAk","decl":"lemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n","proof":":= by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.625_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n","proof":":= by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.632_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\n","proof":":= by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.639_0.ufBrwspFU8fxzAk","decl":"lemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\n","proof":":= by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.646_0.ufBrwspFU8fxzAk","decl":"lemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n","proof":":= by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.653_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\n","proof":":= by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.664_0.ufBrwspFU8fxzAk","decl":"lemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\n","proof":":= by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.673_0.ufBrwspFU8fxzAk","decl":"lemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n","proof":":= by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.679_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp\n\n","proof":":= by\n  rw [chain_rule (hκ.prod hη), fst_prod,\n    entropy_congr (condKernel_prod_ae_eq _ _), entropy_prodMkRight hκ]","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.689_0.ufBrwspFU8fxzAk","decl":"@[simp]\nlemma entropy_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp\n\n@[simp]\nlemma entropy_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n  rw [chain_rule (hκ.prod hη), fst_prod,\n    entropy_congr (condKernel_prod_ae_eq _ _), entropy_prodMkRight hκ]\n\n","proof":":= by\n  have : Hk[κ, μ] = Hk[map κ (fun x ↦ (x, f x)) (measurable_of_countable _), μ] := by\n    refine (entropy_map_of_injective κ μ (f := fun x ↦ (x, f x)) ?_ ?_).symm\n    intro x y hxy\n    simp only [Prod.mk.injEq] at hxy\n    exact hxy.1\n  rw [this, chain_rule' (hκ.map _), snd_map_prod _ measurable_id', le_add_iff_nonneg_right]\n  exact entropy_nonneg _ _","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.697_0.ufBrwspFU8fxzAk","decl":"/-- Data-processing inequality for the kernel entropy. -/\nlemma entropy_map_le\n    {κ : kernel T S} [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[map κ f (measurable_of_countable f), μ] ≤ Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp\n\n@[simp]\nlemma entropy_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n  rw [chain_rule (hκ.prod hη), fst_prod,\n    entropy_congr (condKernel_prod_ae_eq _ _), entropy_prodMkRight hκ]\n\n/-- Data-processing inequality for the kernel entropy. -/\nlemma entropy_map_le\n    {κ : kernel T S} [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[map κ f (measurable_of_countable f), μ] ≤ Hk[κ, μ] := by\n  have : Hk[κ, μ] = Hk[map κ (fun x ↦ (x, f x)) (measurable_of_countable _), μ] := by\n    refine (entropy_map_of_injective κ μ (f := fun x ↦ (x, f x)) ?_ ?_).symm\n    intro x y hxy\n    simp only [Prod.mk.injEq] at hxy\n    exact hxy.1\n  rw [this, chain_rule' (hκ.map _), snd_map_prod _ measurable_id', le_add_iff_nonneg_right]\n  exact entropy_nonneg _ _\n\n","proof":":= by\n  refine le_antisymm ?_ ?_\n  · rw [h2]; exact entropy_map_le g hη\n  · rw [h1]; exact entropy_map_le f hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.710_0.ufBrwspFU8fxzAk","decl":"lemma entropy_of_map_eq_of_map {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U) (g : U → S)\n    (h1 : η = map κ f (measurable_of_countable _)) (h2 : κ = map η g (measurable_of_countable _))\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ, μ] = Hk[η, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp\n\n@[simp]\nlemma entropy_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n  rw [chain_rule (hκ.prod hη), fst_prod,\n    entropy_congr (condKernel_prod_ae_eq _ _), entropy_prodMkRight hκ]\n\n/-- Data-processing inequality for the kernel entropy. -/\nlemma entropy_map_le\n    {κ : kernel T S} [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[map κ f (measurable_of_countable f), μ] ≤ Hk[κ, μ] := by\n  have : Hk[κ, μ] = Hk[map κ (fun x ↦ (x, f x)) (measurable_of_countable _), μ] := by\n    refine (entropy_map_of_injective κ μ (f := fun x ↦ (x, f x)) ?_ ?_).symm\n    intro x y hxy\n    simp only [Prod.mk.injEq] at hxy\n    exact hxy.1\n  rw [this, chain_rule' (hκ.map _), snd_map_prod _ measurable_id', le_add_iff_nonneg_right]\n  exact entropy_nonneg _ _\n\nlemma entropy_of_map_eq_of_map {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U) (g : U → S)\n    (h1 : η = map κ f (measurable_of_countable _)) (h2 : κ = map η g (measurable_of_countable _))\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ, μ] = Hk[η, μ] := by\n  refine le_antisymm ?_ ?_\n  · rw [h2]; exact entropy_map_le g hη\n  · rw [h1]; exact entropy_map_le f hκ\n\n","proof":":=\n  entropy_map_le _ hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.720_0.ufBrwspFU8fxzAk","decl":"lemma entropy_snd_le {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] ≤ Hk[κ, μ] "}
{"srcUpToDecl":"import PFR.ForMathlib.Entropy.Measure\nimport PFR.Mathlib.MeasureTheory.Integral.Bochner\nimport PFR.Mathlib.Probability.Kernel.Disintegration\nimport Mathlib.MeasureTheory.Constructions.Prod.Integral\n\n/-!\n# Entropy of a kernel with respect to a measure\n\n## Main definitions\n\n* `kernel.entropy`: entropy of a kernel `κ` with respect to a measure `μ`,\n  `μ[fun t ↦ measureEntropy (κ t)]`. We use the notation `Hk[κ, μ]`.\n\n## Main statements\n\n* `chain_rule`: `Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)]`.\n* `entropy_map_le`: data-processing inequality for the kernel entropy\n\n## Notations\n\n* `Hk[κ, μ] = kernel.entropy κ μ`\n\n-/\n\nopen Real MeasureTheory\n\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n\nnamespace ProbabilityTheory.kernel\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n [Countable S] [Nonempty S] [MeasurableSpace S] [MeasurableSingletonClass S]\n [Countable T] [Nonempty T] [MeasurableSpace T] [MeasurableSingletonClass T]\n [Countable U] [Nonempty U] [MeasurableSpace U] [MeasurableSingletonClass U]\n [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n\nlemma _root_.MeasureTheory.Measure.compProd_apply_singleton (μ : Measure T) [SFinite μ]\n    (κ : kernel T S) [IsSFiniteKernel κ] (t : T) (s : S) :\n    (μ ⊗ₘ κ) {(t, s)} = κ t {s} * μ {t} := by\n  rw [Measure.compProd_apply (measurableSet_singleton _)]\n  have : ∀ a, κ a (Prod.mk a ⁻¹' {(t, s)}) = ({t} : Set T).indicator (fun _ ↦ κ t {s}) a := by\n    intro a\n    by_cases ha : a = t\n    · simp only [ha, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y\n      simp\n    · simp only [Set.mem_singleton_iff, ha, not_false_eq_true, Set.indicator_of_not_mem]\n      suffices Prod.mk a ⁻¹' {(t, s)} = ∅ by simp [this]\n      ext y\n      simp [ha]\n  simp_rw [this]\n  rw [lintegral_indicator _ (measurableSet_singleton _)]\n  simp\n\nlemma _root_.MeasureTheory.Measure.ae_of_compProd_eq_zero {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {s : Set (α × β)} (hs : (μ ⊗ₘ κ) s = 0) :\n    ∀ᵐ a ∂μ, κ a (Prod.mk a ⁻¹' s) = 0 := by\n  let t := toMeasurable (μ ⊗ₘ κ) s\n  have ht : (μ ⊗ₘ κ) t = 0 := by\n    unfold_let t\n    rwa [measure_toMeasurable]\n  rw [Measure.compProd_apply (measurableSet_toMeasurable _ _), lintegral_eq_zero_iff] at ht\n  swap; · exact measurable_kernel_prod_mk_left (measurableSet_toMeasurable _ _)\n  filter_upwards [ht] with a ha\n  refine measure_mono_null ?_ ha\n  intro y\n  simp only [Set.preimage_compl, Set.mem_compl_iff, Set.mem_preimage]\n  intro hy\n  exact subset_toMeasurable (μ ⊗ₘ κ) s hy\n\nlemma _root_.MeasureTheory.Measure.ae_of_ae_compProd {α β : Type*}\n    {mα : MeasurableSpace α} {mβ : MeasurableSpace β}\n    {μ : Measure α} [SFinite μ] {κ : kernel α β} [IsSFiniteKernel κ]\n    {p : α × β → Prop} (hp : ∀ᵐ x ∂(μ ⊗ₘ κ), p x) :\n    ∀ᵐ a ∂μ, ∀ᵐ b ∂(κ a), p (a, b) := by\n  rw [ae_iff] at hp\n  have hp' := Measure.ae_of_compProd_eq_zero hp\n  filter_upwards [hp'] with a ha\n  rw [ae_iff]\n  convert ha\n\nlemma compProd_congr [SFinite μ] {κ κ' : kernel T S} [IsMarkovKernel κ] [IsMarkovKernel κ']\n    {η η' : kernel (T × S) U} [IsMarkovKernel η] [IsMarkovKernel η']\n    (hκ : κ =ᵐ[μ] κ') (hη : η =ᵐ[μ ⊗ₘ κ] η') :\n    κ ⊗ₖ η =ᵐ[μ] κ' ⊗ₖ η' := by\n  have hη' := Measure.ae_of_ae_compProd hη\n  filter_upwards [hκ, hη'] with a haκ haη\n  ext s hs\n  rw [compProd_apply _ _ _ hs, compProd_apply _ _ _ hs, ← haκ]\n  refine lintegral_congr_ae ?_\n  filter_upwards [haη] with b hb\n  rw [hb]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnoncomputable\ndef entropy (κ : kernel T S) (μ : Measure T) := μ[fun y ↦ Hm[κ y]]\n\n/-- Entropy of a kernel with respect to a measure. -/\nnotation3:100 \"Hk[\" κ \" , \" μ \"]\" => ProbabilityTheory.kernel.entropy κ μ\n\n@[simp]\nlemma entropy_zero_measure (κ : kernel T S) : Hk[κ, (0 : Measure T)] = 0 := by simp [entropy]\n\n@[simp]\nlemma entropy_zero_kernel (μ : Measure T) : Hk[(0 : kernel T S), μ] = 0 := by simp [entropy]\n\nlemma entropy_congr {κ η : kernel T S} (h : κ =ᵐ[μ] η) : Hk[κ, μ] = Hk[η, μ] := by\n  simp_rw [entropy]\n  refine integral_congr_ae ?_\n  filter_upwards [h] with x hx\n  rw [hx]\n\nlemma entropy_nonneg (κ : kernel T S) (μ : Measure T) :\n    0 ≤ Hk[κ, μ] := integral_nonneg (fun _ ↦ measureEntropy_nonneg _)\n\n@[simp]\nlemma entropy_const (ν : Measure S) (μ : Measure T) :\n    Hk[kernel.const T ν, μ] = (μ Set.univ).toReal * Hm[ν] := by\n  rw [entropy]\n  simp only [const_apply, MeasureTheory.integral_const, smul_eq_mul, ne_eq]\n\n/-- The analogue of FiniteSupport for probability kernels. -/\nnoncomputable def FiniteKernelSupport (κ : kernel T S) : Prop :=\n  ∀ t, ∃ A : Finset S, κ t Aᶜ = 0\n\nnoncomputable def AEFiniteKernelSupport (κ : kernel T S) (μ : Measure T) : Prop :=\n  ∀ᵐ t ∂μ, ∃ A : Finset S, κ t Aᶜ = 0\n\nlemma FiniteKernelSupport.aefiniteKernelSupport {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    (μ : Measure T) :\n    AEFiniteKernelSupport κ μ :=\n  ae_of_all μ hκ\n\nnoncomputable\ndef AEFiniteKernelSupport.mk [hS : Nonempty S] {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    kernel T S := by\n  classical\n  exact kernel.piecewise (s := {t | ∃ A : Finset S, κ t Aᶜ = 0}) (by measurability)\n    κ (kernel.const _ (Measure.dirac hS.some))\n\nlemma AEFiniteKernelSupport.finiteKernelSupport_mk [hS : Nonempty S] {κ : kernel T S}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteKernelSupport hκ.mk := by\n  intro t\n  classical\n  rw [AEFiniteKernelSupport.mk, piecewise_apply]\n  split_ifs with ht\n  · exact ht\n  · refine ⟨{hS.some}, ?_⟩\n    simp\n\nlemma AEFiniteKernelSupport.ae_eq_mk {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ) :\n    κ =ᵐ[μ] hκ.mk := by\n  filter_upwards [hκ] with t ht\n  classical\n  rw [AEFiniteKernelSupport.mk, kernel.piecewise_apply, if_pos (by exact ht)]\n\ninstance AEFiniteKernelSupport.isMarkovKernel_mk [hS : Nonempty S]\n    {κ : kernel T S} [IsMarkovKernel κ] (hκ : AEFiniteKernelSupport κ μ) :\n    IsMarkovKernel hκ.mk := by\n  rw [AEFiniteKernelSupport.mk]\n  infer_instance\n\nlemma aefiniteKernelSupport_iff {κ : kernel T S} {μ : Measure T} :\n    AEFiniteKernelSupport κ μ ↔ ∃ κ' : kernel T S, FiniteKernelSupport κ' ∧ κ' =ᵐ[μ] κ := by\n  refine ⟨fun h ↦ ⟨h.mk, h.finiteKernelSupport_mk, h.ae_eq_mk.symm⟩, fun ⟨κ', hκ', h_eq⟩ ↦ ?_⟩\n  filter_upwards [h_eq] with x hx\n  rw [← hx]\n  exact hκ' x\n\n/-- Finite kernel support locally implies uniform finite kernel support. -/\nlemma local_support_of_finiteKernelSupport {κ : kernel T S} (h : FiniteKernelSupport κ) (A : Finset T) :\n    ∃ B : Finset S, ∀ t ∈ A, (κ t) Bᶜ = 0 := by\n  classical\n  use Finset.biUnion A (fun t ↦ (h t).choose)\n  intro t ht\n  set B := (h t).choose\n  refine measure_mono_null ?_ (h t).choose_spec\n  intro s; simp\n  contrapose!; intro h\n  use t\n\n/-- Finite range implies finite kernel support. -/\nlemma finiteKernelSupport_of_finite_range [Fintype S] (κ : kernel T S) : FiniteKernelSupport κ := by\n  intro t\n  use Finset.univ\n  simp\n\n/-- Deterministic kernels have finite kernel support.-/\nlemma finiteKernelSupport_of_deterministic (f : T × S → U) :\n    FiniteKernelSupport (deterministic f (measurable_of_countable f)) := by\n  intro (t,s)\n  use { f (t,s) }\n  rw [kernel.deterministic_apply' (by measurability) _ (by measurability)]\n  simp\n\n/-- maps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_map {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : S → U} (hf : Measurable f) :\n    FiniteKernelSupport (map κ f hf) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\nlemma AEFiniteKernelSupport.map {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) {f : S → U} (hf : Measurable f) :\n    AEFiniteKernelSupport (kernel.map κ f hf) μ := by\n  filter_upwards [hκ] with t ⟨A, hA⟩\n  classical\n  use Finset.image f A\n  rw [kernel.map_apply' _ _ _ (by measurability)]\n  refine measure_mono_null ?_ hA\n  intro s; simp; contrapose!; intro hs; use s\n\n/-- comaps preserve finite kernel support. -/\nlemma finiteKernelSupport_of_comap {κ : kernel T S} (hκ : FiniteKernelSupport κ)\n    {f : U → T} (hf : Measurable f) :\n    FiniteKernelSupport (comap κ f hf) := by\n  intro u\n  rcases hκ (f u) with ⟨A, hA⟩\n  use A\n  rwa [kernel.comap_apply]\n\nlemma AEFiniteKernelSupport.comap_equiv {κ : kernel T S} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (f : U ≃ᵐ T) :\n    AEFiniteKernelSupport (kernel.comap κ f f.measurable) (μ.comap f) := by\n  rw [← @MeasurableEquiv.map_symm]\n  rw [AEFiniteKernelSupport]\n  simp_rw [kernel.comap_apply]\n  rw [ae_map_iff f.symm.measurable.aemeasurable]\n  swap; · measurability\n  simp only [MeasurableEquiv.apply_symm_apply]\n  exact hκ\n\n/-- Projecting a kernel to first coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_fst {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (fst κ) :=\n  finiteKernelSupport_of_map hκ measurable_fst\n\nlemma AEFiniteKernelSupport.fst {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (fst κ) μ :=\n  hκ.map measurable_fst\n\n/-- Projecting a kernel to second coordinate preserves finite kernel support. -/\nlemma finiteKernelSupport_of_snd {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (snd κ) :=\n  finiteKernelSupport_of_map hκ measurable_snd\n\nlemma AEFiniteKernelSupport.snd {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (snd κ) μ :=\n  hκ.map measurable_snd\n\n/-- Conditioning a kernel preserves finite kernel support. -/\nlemma aefiniteKernelSupport_of_cond {κ : kernel T (S × U)} [hU: Nonempty U]\n    (μ : Measure T) [IsFiniteMeasure μ] (hκ : AEFiniteKernelSupport κ μ) [IsFiniteKernel κ] :\n    AEFiniteKernelSupport (condKernel κ) (μ ⊗ₘ (kernel.fst κ)) := by\n  rw [AEFiniteKernelSupport, ae_iff_of_countable] at hκ ⊢\n  intro (t, s) hts\n  simp only [Measure.compProd_apply_singleton, ne_eq, mul_eq_zero] at hts\n  push_neg at hts\n  rcases hκ t hts.2 with ⟨A, hA⟩\n  classical\n  use Finset.image Prod.snd A\n  rw [condKernel_apply']\n  rotate_left\n  · rw [kernel.fst_apply' _ _ (measurableSet_singleton _)] at hts\n    exact hts.1\n  · measurability\n  simp only [Finset.coe_image, Set.singleton_prod, mul_eq_zero, ENNReal.inv_eq_zero]\n  right\n  refine measure_mono_null ?_ hA\n  intro x\n  simp only [Set.mem_image, Set.mem_compl_iff, Finset.mem_coe, Prod.exists, exists_eq_right,\n    not_exists, forall_exists_index, and_imp]\n  intro y h hsyx\n  rw [← hsyx]\n  exact h s\n\n/-- Swapping a kernel right preserves finite kernel support. -/\nlemma finiteKernelSupport_of_swapRight {κ : kernel T (S × U)} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (swapRight κ) :=\n  finiteKernelSupport_of_map hκ measurable_swap\n\nlemma AEFiniteKernelSupport.swapRight {κ : kernel T (S × U)} {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) :\n    AEFiniteKernelSupport (swapRight κ) μ :=\n  hκ.map measurable_swap\n\n/-- Constant kernels with finite support, have finite kernel support. -/\nlemma finiteKernelSupport_of_const (ν : Measure S) [FiniteSupport ν] :\n    FiniteKernelSupport (kernel.const T ν) := by\n  intro t\n  use ν.support\n  simp [measure_compl_support ν]\n\n/-- Products preserve finite kernel support. -/\nlemma finiteKernelSupport_of_prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ×ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases hη t with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [kernel.prod_apply' _ _ _ (by measurability)]\n  apply lintegral_eq_zero_of_ae_zero hA _ (by measurability)\n  intro s hs\n  refine measure_mono_null ?_ hB\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.prod {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T}\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    AEFiniteKernelSupport (κ ×ₖ η) μ := by\n  filter_upwards [hκ, hη] with x ⟨A, hκA⟩ ⟨B, hηB⟩\n  use A ×ˢ B\n  rw [Finset.coe_product, Set.compl_prod_eq_union, prod_apply, measure_union_null_iff,\n    Measure.prod_prod, Measure.prod_prod, hκA, hηB, zero_mul, mul_zero, and_self]\n\n/-- Composition-product preserves finite kernel support -/\nlemma finiteKernelSupport_of_compProd {κ : kernel T S} [IsMarkovKernel κ] {η : kernel (T × S) U}\n    [IsMarkovKernel η] (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    FiniteKernelSupport (κ ⊗ₖ η) := by\n  intro t\n  rcases hκ t with ⟨A, hA⟩\n  rcases (local_support_of_finiteKernelSupport hη ({t} ×ˢ A)) with ⟨B, hB⟩\n  use (A ×ˢ B)\n  rw [kernel.compProd_apply _ _ _ (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro s hs\n  simp; left\n  refine measure_mono_null ?_ (hB (t, s) (by simp [hs]))\n  intro u; simp; tauto\n\nlemma AEFiniteKernelSupport.compProd {κ : kernel T S} {η : kernel (T × S) U}\n    [IsMarkovKernel κ] [IsMarkovKernel η] {μ : Measure T} [SFinite μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    AEFiniteKernelSupport (κ ⊗ₖ η) μ := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨hκ.mk ⊗ₖ hη.mk, ?_, ?_⟩\n  · exact finiteKernelSupport_of_compProd hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk\n  · have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n\n/-- prodMkRight preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkRight {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkRight U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkRight {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite ν] :\n    AEFiniteKernelSupport (prodMkRight U κ) (μ.prod ν) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkRight U hκ.mk, finiteKernelSupport_of_prodMkRight hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : T × U) ∂(μ.prod ν), x ∈ {y | (prodMkRight U (mk hκ)) y = (prodMkRight U κ) y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- prodMkLeft preserves finite kernel support. -/\nlemma finiteKernelSupport_of_prodMkLeft {κ : kernel T S} (hκ : FiniteKernelSupport κ) :\n    FiniteKernelSupport (prodMkLeft U κ) :=\n  finiteKernelSupport_of_comap hκ _\n\nprotected lemma AEFiniteKernelSupport.prodMkLeft {κ : kernel T S} (hκ : AEFiniteKernelSupport κ μ)\n    (ν : Measure U) [SFinite μ] :\n    AEFiniteKernelSupport (prodMkLeft U κ) (ν.prod μ) := by\n  rw [aefiniteKernelSupport_iff]\n  refine ⟨prodMkLeft U hκ.mk, finiteKernelSupport_of_prodMkLeft hκ.finiteKernelSupport_mk, ?_⟩\n  rw [Filter.EventuallyEq]\n  change ∀ᵐ (x : U × T) ∂(ν.prod μ), x ∈ {y | prodMkLeft U (mk hκ) y = prodMkLeft U κ y}\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  · refine ae_of_all _ (fun y ↦ ?_)\n    filter_upwards [hκ.ae_eq_mk] with x hx\n    simp [hx]\n  · simp only [prodMkRight_apply, measurableSet_setOf]\n    exact measurable_of_countable _\n\n/-- Composing a finitely supported measure with a finitely supported kernel gives a finitely supported kernel. -/\nlemma finiteSupport_of_compProd' {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : FiniteKernelSupport κ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  use A ×ˢ B\n  rw [Measure.compProd_apply (by measurability), lintegral_eq_sum' _ hA]\n  apply Finset.sum_eq_zero\n  intro t ht\n  simp; left\n  refine measure_mono_null ?_ (hB t ht)\n  intro s\n  simp; tauto\n\nlemma finiteSupport_of_compProd {μ : Measure T} [IsFiniteMeasure μ] {κ : kernel T S}\n    [IsMarkovKernel κ] [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    FiniteSupport (μ ⊗ₘ κ) := by\n  rw [Measure.compProd_congr hκ.ae_eq_mk]\n  exact finiteSupport_of_compProd' hκ.finiteKernelSupport_mk\n\nlemma aefiniteKernelSupport_condDistrib (X : Ω → S) (Y : Ω → T) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (hX: Measurable X) (hY: Measurable Y) [FiniteRange X] [FiniteRange Y] :\n    AEFiniteKernelSupport (condDistrib X Y μ) (μ.map Y) := by\n  filter_upwards [condDistrib_ae_eq hX hY μ] with a ha\n  rw [ha]\n  exact finiteSupport_of_finiteRange.finite\n\nlemma entropy_le_log_card (κ : kernel T S) (μ : Measure T) [Fintype S] [IsProbabilityMeasure μ] :\n    Hk[κ, μ] ≤ log (Fintype.card S) := by\n  refine (integral_mono_of_nonneg ?_ (integrable_const (log (Fintype.card S))) ?_).trans ?_\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_nonneg _)\n  · exact ae_of_all _ (fun _ ↦ measureEntropy_le_log_card _)\n  · simp\n\nlemma entropy_eq_integral_sum (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) :\n    Hk[κ, μ] = μ[fun y ↦ ∑' x, negMulLog (κ y {x}).toReal] := by\n  simp_rw [entropy, measureEntropy_of_isProbabilityMeasure]\n\n-- entropy_map_of_injective is a special case of this (see def of map)\nlemma entropy_snd_compProd_deterministic_of_injective (κ : kernel T S) [IsMarkovKernel κ]\n    (μ : Measure T) {f : T × S → U}\n    (hf : ∀ t, Function.Injective (fun x ↦ f (t, x))) (hmes : Measurable f) :\n    Hk[snd (κ ⊗ₖ deterministic f hmes), μ] = Hk[κ, μ] := by\n  have : ∀ t, snd (κ ⊗ₖ deterministic f hmes) t\n      = map κ (fun x ↦ f (t, x)) (hmes.comp measurable_prod_mk_left) t := by\n    intro t\n    ext s hs\n    rw [snd_apply' _ _ hs, compProd_deterministic_apply, map_apply' _ _ _ hs]\n    · congr\n    · exact measurable_snd hs\n  simp_rw [entropy]\n  congr with y\n  convert measureEntropy_map_of_injective (κ y) _ (hmes.comp measurable_prod_mk_left) (hf y)\n  rw [this y, map_apply]\n  congr\n\nlemma entropy_map_of_injective\n    (κ : kernel T S) (μ : Measure T) {f : S → U} (hf : Function.Injective f) (hmes : Measurable f) :\n    Hk[map κ f hmes, μ] = Hk[κ, μ] := by\n  simp_rw [entropy, map_apply, measureEntropy_map_of_injective _ _ hmes hf]\n\nlemma entropy_map_swap (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[map κ Prod.swap measurable_swap, μ] = Hk[κ, μ] := entropy_map_of_injective κ μ Prod.swap_injective _\n\nlemma entropy_swapRight (κ : kernel T (S × U)) (μ : Measure T) :\n    Hk[swapRight κ, μ] = Hk[κ, μ] := by\n  rw [swapRight, entropy_map_swap]\n\nlemma entropy_comap {T' : Type*}  [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) (μ : Measure T) (f : T' → T) (hf : MeasurableEmbedding f)\n    (hf_range : Set.range f =ᵐ[μ] Set.univ)\n    [IsFiniteMeasure μ] [IsFiniteMeasure (μ.comap f)] (hfμ : FiniteSupport (μ.comap f)) :\n    Hk[comap κ f hf.measurable, μ.comap f] = Hk[κ, μ] := by\n  classical\n  rcases hfμ with ⟨A, hA⟩\n  have : μ (Finset.image f A : Set T)ᶜ = 0 := by\n    rw [Finset.coe_image, Function.Injective.compl_image_eq hf.injective]\n    simp\n    constructor\n    . rwa [← Measure.comap_apply f hf.injective hf.measurableSet_image']\n      exact MeasurableSet.compl (Finset.measurableSet A)\n    exact ae_eq_univ.mp hf_range\n  simp_rw [entropy]\n  simp_rw [integral_eq_sum' _ hA, integral_eq_sum' _ this, Measure.comap_apply f hf.injective hf.measurableSet_image' _\n    (measurableSet_singleton _)]\n  simp only [Set.image_singleton, smul_eq_mul]\n  simp_rw [comap_apply]\n  rw [← Finset.sum_image (f := fun x ↦ (μ {x}).toReal * measureEntropy (κ x)) (g := f)]\n  intro x _ y _ hxy\n  exact hf.injective hxy\n\nlemma FiniteSupport.comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [FiniteSupport μ] :\n    FiniteSupport (μ.comap f) := by\n  classical\n  let A := μ.support\n  have hA := measure_compl_support μ\n  refine ⟨Finset.image f.symm A, ?_⟩\n  rwa [Finset.coe_image, ← Set.image_compl_eq (MeasurableEquiv.bijective f.symm),\n    Measure.comap_apply f (MeasurableEquiv.injective f),MeasurableEquiv.image_symm,\n    MeasurableEquiv.image_preimage]\n  . exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n  · exact f.symm.measurableSet_image.mpr A.measurableSet.compl\n\ninstance IsFiniteMeasure_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    {μ : Measure T} (f : T' ≃ᵐ T) [IsFiniteMeasure μ] :\n    IsFiniteMeasure (μ.comap f) := by\n  constructor\n  rw [Measure.comap_apply f (MeasurableEquiv.injective f) _ μ MeasurableSet.univ]\n  . exact measure_lt_top μ (⇑f '' Set.univ)\n  · exact fun _ ↦ (MeasurableEquiv.measurableSet_image f).mpr\n\nlemma entropy_comap_equiv {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T']\n    (κ : kernel T S) {μ : Measure T} (f : T' ≃ᵐ T)\n    [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ f f.measurable, μ.comap f] = Hk[κ, μ] := by\n  rw [entropy_comap]\n  · exact f.measurableEmbedding\n  · rw [← MeasurableEquiv.coe_toEquiv, Equiv.range_eq_univ]\n  · exact FiniteSupport.comap_equiv f\n\nlemma entropy_comap_swap\n    {T' : Type*} [MeasurableSpace T'] [MeasurableSingletonClass T'] [Nonempty T']\n    (κ : kernel (T' × T) S) {μ : Measure (T' × T)} [IsFiniteMeasure μ] [FiniteSupport μ] :\n    Hk[comap κ Prod.swap measurable_swap, μ.comap Prod.swap] = Hk[κ, μ] :=\n  entropy_comap_equiv κ MeasurableEquiv.prodComm\n\n/-- Measurable equivalence with the product with the one-point space `Unit`.-/\ndef prodMKLeft_unit_equiv (T : Type*) [MeasurableSpace T] : (Unit × T) ≃ᵐ T where\n  toFun := fun p ↦ p.2\n  invFun:= Prod.mk ()\n  left_inv := by intro p; simp\n  right_inv := by intro t; simp\n  measurable_toFun := by simp; exact measurable_snd\n  measurable_invFun := by simp; exact measurable_prod_mk_left\n\nlemma entropy_prodMkLeft_unit (κ : kernel T S) {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] :\n    Hk[prodMkLeft Unit κ, μ.map (Prod.mk ())] = Hk[κ, μ] := by\n  convert entropy_comap_equiv κ (prodMKLeft_unit_equiv T) (μ := μ)\n  funext μ\n  rw [← MeasurableEquiv.map_symm]\n  congr\n\nlemma entropy_compProd_aux [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ] (hκ : FiniteKernelSupport κ)\n    (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ]\n      + μ[fun t ↦ Hk[comap η (Prod.mk t) measurable_prod_mk_left, (κ t)]] := by\n  let A := μ.support\n  have hA := measure_compl_support μ\n  have hsum (F : T → ℝ) : ∫ (t : T), F t ∂μ = ∑ t in A, (μ.real {t}) * (F t) := by\n    rw [integral_eq_sum' _ hA]\n    congr with t ht\n  simp_rw [entropy, hsum, ← Finset.sum_add_distrib]\n  apply Finset.sum_congr rfl\n  intro t ht\n  rw [← mul_add]\n  congr\n  rcases (local_support_of_finiteKernelSupport hκ A) with ⟨B, hB⟩\n  rcases (local_support_of_finiteKernelSupport hη (A ×ˢ B)) with ⟨C, hC⟩\n  rw [integral_eq_sum' _ (hB t ht)]\n  have hκη : ((κ ⊗ₖ η) t) (B ×ˢ C: Finset (S × U))ᶜ = 0 := by\n    rw [ProbabilityTheory.kernel.compProd_apply, lintegral_eq_sum' _ (hB t ht)]\n    . apply Finset.sum_eq_zero\n      intro s hs\n      simp; left\n      have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n      refine measure_mono_null ?_ (hC (t, s) hts)\n      intro u hu\n      simp at hu ⊢\n      exact hu hs\n    exact MeasurableSet.compl (Finset.measurableSet _)\n  rw [measureEntropy_def_finite' hκη, measureEntropy_def_finite' (hB t ht), ← Finset.sum_add_distrib, Finset.sum_product]\n  apply Finset.sum_congr rfl\n  intro s hs\n  simp\n  have hts : (t, s) ∈ A ×ˢ B := by simp [ht, hs]\n  have hη': (comap η (Prod.mk t) measurable_prod_mk_left) s Cᶜ = 0 := by\n    rw [kernel.comap_apply]\n    exact hC (t, s) hts\n  rw [measureEntropy_def_finite' hη']\n  simp\n  have : negMulLog ((κ t).real {s}) = ∑ u in C, negMulLog ((κ t).real {s}) * ((comap η (Prod.mk t) measurable_prod_mk_left) s).real {u} := by\n    rw [← Finset.mul_sum]\n    simp\n    rw [kernel.comap_apply]\n    suffices : (η (t, s)).real ↑C = (η (t, s)).real Set.univ\n    . simp [this]\n    have := hC (t, s) hts\n    rw [← measureReal_eq_zero_iff] at this\n    rw [← measureReal_add_measureReal_compl (s := C) _, this, add_zero]\n    exact Finset.measurableSet C\n  rw [this, Finset.mul_sum, ← Finset.sum_add_distrib]\n  congr with u\n  have : ((κ ⊗ₖ η) t).real {(s, u)} = ((κ t).real {s}) * ((η (t, s)).real {u}) := by\n    rw [measureReal_def, compProd_apply κ η _ (measurableSet_singleton _), lintegral_eq_sum' _ (hB t ht), Finset.sum_eq_single_of_mem s hs]\n    . simp [measureReal_def]; ring\n    intro b _ hbs\n    simp [hbs]\n  rw [this, kernel.comap_apply, negMulLog_mul, negMulLog, negMulLog, ← measureReal_def]\n  ring\n\nlemma entropy_compProd' [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : FiniteKernelSupport κ) (hη : FiniteKernelSupport η) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  rw [entropy_compProd_aux hκ hη]\n  congr\n  rw [entropy, Measure.integral_compProd]\n  · simp_rw [entropy]\n    congr\n  · have := finiteSupport_of_compProd' hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_compProd [IsFiniteMeasure μ] {κ : kernel T S} [IsMarkovKernel κ]\n    {η : kernel (T × S) U} [IsMarkovKernel η] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η (μ ⊗ₘ κ)) :\n    Hk[κ ⊗ₖ η, μ] = Hk[κ, μ] + Hk[η, μ ⊗ₘ κ] := by\n  have h_meas_eq : μ ⊗ₘ hκ.mk = μ ⊗ₘ κ := Measure.compProd_congr hκ.ae_eq_mk.symm\n  have h_ent1 : Hk[hκ.mk ⊗ₖ hη.mk, μ] = Hk[κ ⊗ₖ η, μ] := by\n    refine entropy_congr ?_\n    refine compProd_congr hκ.ae_eq_mk.symm ?_\n    convert hη.ae_eq_mk.symm\n  have h_ent2 : Hk[hκ.mk, μ] = Hk[κ, μ] := entropy_congr hκ.ae_eq_mk.symm\n  have h_ent3 : Hk[hη.mk, μ ⊗ₘ hκ.mk] = Hk[η, μ ⊗ₘ κ] := by\n    rw [h_meas_eq, entropy_congr hη.ae_eq_mk]\n  rw [← h_ent1, ← h_ent2, ← h_ent3,\n    entropy_compProd' hκ.finiteKernelSupport_mk hη.finiteKernelSupport_mk]\n\n@[simp]\nlemma entropy_deterministic (f : T → S) (μ : Measure T) :\n    Hk[deterministic f (measurable_of_countable f), μ] = 0 := by\n  simp_rw [entropy]\n  convert integral_zero T ℝ\n  apply measureEntropy_dirac\n\n@[simp]\nlemma entropy_compProd_deterministic\n    (κ : kernel T S) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ] (f : T × S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ ⊗ₖ (deterministic f (measurable_of_countable f)), μ] = Hk[κ, μ] := by\n  simp [entropy_compProd hκ ((finiteKernelSupport_of_deterministic f).aefiniteKernelSupport _)]\n\nlemma chain_rule {κ : kernel T (S × U)} [IsMarkovKernel κ] [hU: Nonempty U]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[fst κ, μ] + Hk[condKernel κ, μ ⊗ₘ (fst κ)] := by\n  conv_lhs => rw [disintegration κ]\n  rw [entropy_compProd hκ.fst (aefiniteKernelSupport_of_cond _ hκ)]\n\nlemma chain_rule' {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[κ, μ] = Hk[snd κ, μ] + Hk[condKernel (swapRight κ), μ ⊗ₘ (snd κ)] := by\n  rw [← entropy_swapRight, chain_rule hκ.swapRight]\n  simp\n\n@[simp]\nlemma entropy_prodMkRight {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[prodMkRight S η, μ ⊗ₘ κ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkRight_apply]\n  rw [Measure.integral_compProd]\n  · simp only [MeasureTheory.integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul]\n  · have := finiteSupport_of_compProd hκ (μ := μ)\n    exact integrable_of_finiteSupport (μ ⊗ₘ κ)\n\nlemma entropy_prodMkRight' {η : kernel T U}\n    {μ : Measure T} [IsProbabilityMeasure μ] {ν : Measure S} [IsProbabilityMeasure ν]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkRight S η, μ.prod ν] = Hk[η, μ] := by\n  rw [← entropy_prodMkRight (μ := μ) ((finiteKernelSupport_of_const ν).aefiniteKernelSupport _)]\n  congr\n  ext s hs\n  simp_rw [Measure.prod_apply hs, Measure.compProd_apply hs, kernel.const_apply]\n\nlemma _root_.MeasureTheory.Measure.prod_apply_singleton {α β : Type*}\n    {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    (μ : Measure α) (ν : Measure β) [SigmaFinite ν] (x : α × β) :\n    (μ.prod ν) {x} = μ {x.1} * ν {x.2} := by\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Measure.prod_prod]\n\n@[simp]\nlemma entropy_prodMkLeft {η : kernel T U}\n    {ν : Measure S} [IsProbabilityMeasure ν] {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] [FiniteSupport ν] :\n    Hk[prodMkLeft S η, ν.prod μ] = Hk[η, μ] := by\n  simp_rw [entropy, prodMkLeft_apply]\n  rw [integral_prod]\n  swap; · exact integrable_of_finiteSupport (ν.prod μ)\n  simp\n\n@[simp]\nlemma entropy_prod {κ : kernel T S} {η : kernel T U} [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] [FiniteSupport μ]\n    (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ ×ₖ η, μ] = Hk[κ, μ] + Hk[η, μ] := by\n  rw [chain_rule (hκ.prod hη), fst_prod,\n    entropy_congr (condKernel_prod_ae_eq _ _), entropy_prodMkRight hκ]\n\n/-- Data-processing inequality for the kernel entropy. -/\nlemma entropy_map_le\n    {κ : kernel T S} [IsMarkovKernel κ] {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U)\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[map κ f (measurable_of_countable f), μ] ≤ Hk[κ, μ] := by\n  have : Hk[κ, μ] = Hk[map κ (fun x ↦ (x, f x)) (measurable_of_countable _), μ] := by\n    refine (entropy_map_of_injective κ μ (f := fun x ↦ (x, f x)) ?_ ?_).symm\n    intro x y hxy\n    simp only [Prod.mk.injEq] at hxy\n    exact hxy.1\n  rw [this, chain_rule' (hκ.map _), snd_map_prod _ measurable_id', le_add_iff_nonneg_right]\n  exact entropy_nonneg _ _\n\nlemma entropy_of_map_eq_of_map {κ : kernel T S} {η : kernel T U}\n    [IsMarkovKernel κ] [IsMarkovKernel η]\n    {μ : Measure T} [IsProbabilityMeasure μ] (f : S → U) (g : U → S)\n    (h1 : η = map κ f (measurable_of_countable _)) (h2 : κ = map η g (measurable_of_countable _))\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) (hη : AEFiniteKernelSupport η μ) :\n    Hk[κ, μ] = Hk[η, μ] := by\n  refine le_antisymm ?_ ?_\n  · rw [h2]; exact entropy_map_le g hη\n  · rw [h1]; exact entropy_map_le f hκ\n\nlemma entropy_snd_le {κ : kernel T (S × U)} [IsMarkovKernel κ]\n    {μ : Measure T} [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[snd κ, μ] ≤ Hk[κ, μ] :=\n  entropy_map_le _ hκ\n\n","proof":":=\n  entropy_map_le _ hκ","declId":"PFR.ForMathlib.Entropy.Kernel.Basic.726_0.ufBrwspFU8fxzAk","decl":"lemma entropy_fst_le (κ : kernel T (S × U)) [IsMarkovKernel κ]\n    (μ : Measure T) [IsProbabilityMeasure μ]\n    [FiniteSupport μ] (hκ : AEFiniteKernelSupport κ μ) :\n    Hk[fst κ, μ] ≤ Hk[κ, μ] "}
