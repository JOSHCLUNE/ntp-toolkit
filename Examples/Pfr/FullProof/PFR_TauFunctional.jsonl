{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n","proof":":=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1","declId":"PFR.TauFunctional.29_0.JHo9nKZSxI9j9eS","decl":"/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n","proof":":= d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]","declId":"PFR.TauFunctional.53_0.JHo9nKZSxI9j9eS","decl":"/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\n","proof":":= by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity","declId":"PFR.TauFunctional.72_0.JHo9nKZSxI9j9eS","decl":"lemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n","proof":":= by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]","declId":"PFR.TauFunctional.87_0.JHo9nKZSxI9j9eS","decl":"/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n","proof":":=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]","declId":"PFR.TauFunctional.99_0.JHo9nKZSxI9j9eS","decl":"/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n","proof":":= by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]","declId":"PFR.TauFunctional.106_0.JHo9nKZSxI9j9eS","decl":"/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n","proof":":= by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν","declId":"PFR.TauFunctional.114_0.JHo9nKZSxI9j9eS","decl":"/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] := by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν\n\n","proof":":= by\n  let μ := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure μ.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure μ.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (μ.1.prod μ.2) := by infer_instance\n  let M : MeasureSpace (G × G) := ⟨μ.1.prod μ.2⟩\n  refine ⟨G × G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_⟩\n  intro ν₁ ν₂ h₁ h₂\n  have A : τ[@Prod.fst G G # @Prod.snd G G | p] = τ[id ; μ.1 # id ; μ.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 ν₁ ν₂ h₁ h₂","declId":"PFR.TauFunctional.136_0.JHo9nKZSxI9j9eS","decl":"/-- A pair of random variables minimizing $τ$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    ∃ (Ω : Type uG) (mΩ : MeasureSpace Ω) (X₁ : Ω → G) (X₂ : Ω → G),\n    Measurable X₁ ∧ Measurable X₂ ∧ IsProbabilityMeasure (ℙ : Measure Ω) ∧\n    tau_minimizes p X₁ X₂ "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] := by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν\n\n/-- A pair of random variables minimizing $τ$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    ∃ (Ω : Type uG) (mΩ : MeasureSpace Ω) (X₁ : Ω → G) (X₂ : Ω → G),\n    Measurable X₁ ∧ Measurable X₂ ∧ IsProbabilityMeasure (ℙ : Measure Ω) ∧\n    tau_minimizes p X₁ X₂ := by\n  let μ := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure μ.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure μ.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (μ.1.prod μ.2) := by infer_instance\n  let M : MeasureSpace (G × G) := ⟨μ.1.prod μ.2⟩\n  refine ⟨G × G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_⟩\n  intro ν₁ ν₂ h₁ h₂\n  have A : τ[@Prod.fst G G # @Prod.snd G G | p] = τ[id ; μ.1 # id ; μ.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 ν₁ ν₂ h₁ h₂\n\n\nvariable [MeasureSpace Ω] [hΩ₁ : MeasureSpace Ω'₁] [hΩ₂ : MeasureSpace Ω'₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω)]\n  [IsProbabilityMeasure (ℙ : Measure Ω'₁)] [IsProbabilityMeasure (ℙ : Measure Ω'₂)]\n  {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n\n","proof":":= by\n  let ν₁ := (ℙ : Measure Ω'₁).map X'₁\n  let ν₂ := (ℙ : Measure Ω'₂).map X'₂\n  have B : τ[X'₁ # X'₂ | p] = τ[id ; ν₁ # id ; ν₂ | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h ν₁ ν₂ (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)","declId":"PFR.TauFunctional.158_0.JHo9nKZSxI9j9eS","decl":"lemma is_tau_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] := by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν\n\n/-- A pair of random variables minimizing $τ$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    ∃ (Ω : Type uG) (mΩ : MeasureSpace Ω) (X₁ : Ω → G) (X₂ : Ω → G),\n    Measurable X₁ ∧ Measurable X₂ ∧ IsProbabilityMeasure (ℙ : Measure Ω) ∧\n    tau_minimizes p X₁ X₂ := by\n  let μ := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure μ.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure μ.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (μ.1.prod μ.2) := by infer_instance\n  let M : MeasureSpace (G × G) := ⟨μ.1.prod μ.2⟩\n  refine ⟨G × G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_⟩\n  intro ν₁ ν₂ h₁ h₂\n  have A : τ[@Prod.fst G G # @Prod.snd G G | p] = τ[id ; μ.1 # id ; μ.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 ν₁ ν₂ h₁ h₂\n\n\nvariable [MeasureSpace Ω] [hΩ₁ : MeasureSpace Ω'₁] [hΩ₂ : MeasureSpace Ω'₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω)]\n  [IsProbabilityMeasure (ℙ : Measure Ω'₁)] [IsProbabilityMeasure (ℙ : Measure Ω'₂)]\n  {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n\nlemma is_tau_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p] := by\n  let ν₁ := (ℙ : Measure Ω'₁).map X'₁\n  let ν₂ := (ℙ : Measure Ω'₂).map X'₂\n  have B : τ[X'₁ # X'₂ | p] = τ[id ; ν₁ # id ; ν₂ | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h ν₁ ν₂ (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n","proof":":= by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith","declId":"PFR.TauFunctional.167_0.JHo9nKZSxI9j9eS","decl":"/-- Let `X₁` and `X₂` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\nlemma distance_ge_of_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂ # X'₂] - d[p.X₀₂ # X₂])\n      ≤ d[X'₁ # X'₂] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] := by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν\n\n/-- A pair of random variables minimizing $τ$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    ∃ (Ω : Type uG) (mΩ : MeasureSpace Ω) (X₁ : Ω → G) (X₂ : Ω → G),\n    Measurable X₁ ∧ Measurable X₂ ∧ IsProbabilityMeasure (ℙ : Measure Ω) ∧\n    tau_minimizes p X₁ X₂ := by\n  let μ := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure μ.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure μ.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (μ.1.prod μ.2) := by infer_instance\n  let M : MeasureSpace (G × G) := ⟨μ.1.prod μ.2⟩\n  refine ⟨G × G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_⟩\n  intro ν₁ ν₂ h₁ h₂\n  have A : τ[@Prod.fst G G # @Prod.snd G G | p] = τ[id ; μ.1 # id ; μ.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 ν₁ ν₂ h₁ h₂\n\n\nvariable [MeasureSpace Ω] [hΩ₁ : MeasureSpace Ω'₁] [hΩ₂ : MeasureSpace Ω'₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω)]\n  [IsProbabilityMeasure (ℙ : Measure Ω'₁)] [IsProbabilityMeasure (ℙ : Measure Ω'₂)]\n  {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n\nlemma is_tau_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p] := by\n  let ν₁ := (ℙ : Measure Ω'₁).map X'₁\n  let ν₂ := (ℙ : Measure Ω'₂).map X'₂\n  have B : τ[X'₁ # X'₂ | p] = τ[id ; ν₁ # id ; ν₂ | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h ν₁ ν₂ (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n/-- Let `X₁` and `X₂` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\nlemma distance_ge_of_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂ # X'₂] - d[p.X₀₂ # X₂])\n      ≤ d[X'₁ # X'₂] := by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith\n\n","proof":":= by\n  set M1 : MeasureSpace Ω'₁ := { volume := μ }\n  set M2 : MeasureSpace Ω'₂ := { volume := μ' }\n  exact distance_ge_of_min p h h1 h2","declId":"PFR.TauFunctional.179_0.JHo9nKZSxI9j9eS","decl":"/-- Version of `distance_ge_of_min` with the measures made explicit. -/\nlemma distance_ge_of_min' {Ω'₁ Ω'₂ : Type*} (h : tau_minimizes p X₁ X₂)\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂] {μ : Measure Ω'₁} {μ' : Measure Ω'₂}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] {X'₁: Ω'₁ → G} {X'₂: Ω'₂ → G}\n    (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁; ℙ # X'₁; μ] - d[p.X₀₁ # X₁])\n      - p.η * (d[p.X₀₂; ℙ # X'₂; μ'] - d[p.X₀₂ # X₂]) ≤ d[X'₁; μ # X'₂; μ'] "}
{"srcUpToDecl":"import PFR.ForMathlib.CompactProb\nimport PFR.ForMathlib.Entropy.RuzsaDist\n\n/-!\n# The tau functional\n\nDefinition of the tau functional and basic facts\n\n## Main definitions:\n\n* `η`: $1/9$\n* `τ`: The tau functional $\\tau[X_1; X_2] = d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$\n\n## Main results\n\n* `tau_minimizer_exists`: A pair of random variables minimizing $\\tau$ exists.\n* `condRuzsaDistance_ge_of_min`: If $X_1,X_2$ is a tau-minimizer with $k = d[X_1;X_2]$, then $d[X'_1|Z, X'_2|W]$ is at least\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] )$$\nfor any $X'_1, Z, X'_2, W$.\n-/\n\nopen MeasureTheory ProbabilityTheory\nuniverse uG\n\nvariable (Ω₀₁ Ω₀₂ : Type*) [MeasureSpace Ω₀₁] [MeasureSpace Ω₀₂]\n[IsProbabilityMeasure (ℙ : Measure Ω₀₁)] [IsProbabilityMeasure (ℙ : Measure Ω₀₂)]\nvariable (G : Type uG) [AddCommGroup G] [ElementaryAddCommGroup G 2] [Fintype G] [MeasurableSpace G]\n\n/-- A structure that packages all the fixed information in the main argument. In this way, when\ndefining the τ functional, we will only only need to refer to the package once in the notation\ninstead of stating the reference spaces, the reference measures and the reference random\nvariables.\n\nThe η parameter has now been incorporated into the package, in preparation for being able to\nmanipulate the package. -/\nstructure refPackage :=\n  /-- The first variable in a package. -/\n  X₀₁ : Ω₀₁ → G\n  /-- The second variable in a package. -/\n  X₀₂ : Ω₀₂ → G\n  hmeas1 : Measurable X₀₁\n  hmeas2 : Measurable X₀₂\n  η : ℝ\n  hη : 0 < η\n  hη' : 8 * η ≤ 1\n\nvariable (p : refPackage Ω₀₁ Ω₀₂ G)\nvariable {Ω₀₁ Ω₀₂ G}\n\nvariable {Ω₁ Ω₂ Ω'₁ Ω'₂ : Type*}\n\n\n/-- If $X_1,X_2$ are two $G$-valued random variables, then\n$$ \\tau[X_1; X_2] := d[X_1; X_2] + \\eta d[X^0_1; X_1] + \\eta d[X^0_2; X_2].$$\nHere, $X^0_1$ and $X^0_2$ are two random variables fixed once and for all in most of the argument.\nTo lighten notation, We package `X^0_1` and `X^0_2` in a single object named `p`.\n\nWe denote it as `τ[X₁ ; μ₁ # X₂ ; μ₂ | p]` where `p` is a fixed package containing the information\nof the reference random variables. When the measurable spaces have a canonical measure `ℙ`, we\ncan use `τ[X₁ # X₂ | p]`\n--/\n@[pp_dot] noncomputable def tau {Ω₁ Ω₂ : Type*} [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    (X₁ : Ω₁ → G) (X₂ : Ω₂ → G) (μ₁ : Measure Ω₁) (μ₂ : Measure Ω₂) : ℝ :=\n  d[X₁ ; μ₁ # X₂ ; μ₂] + p.η * d[p.X₀₁ ; ℙ # X₁ ; μ₁] + p.η * d[p.X₀₂ ; ℙ # X₂ ; μ₂]\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" ; \" μ₁ \" # \" X₂ \" ; \" μ₂ \" | \" p\"]\" => tau p X₁ X₂ μ₁ μ₂\n\n@[inherit_doc tau]\nnotation3:max \"τ[\" X₁ \" # \" X₂ \" | \" p\"]\" => tau p X₁ X₂ MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume\n\nlemma continuous_tau_restrict_probabilityMeasure\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ τ[id ; μ.1 # id ; μ.2 | p]) := by\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₂ ; ℙ # id ; μ.2]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas2) continuous_snd\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[id ; μ.1.toMeasure # id ; μ.2]) :=\n    continuous_rdist_restrict_probabilityMeasure\n  have obs₃ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ d[p.X₀₁ ; ℙ # id ; μ.1]) :=\n    Continuous.comp (continuous_rdist_restrict_probabilityMeasure₁' _ _ p.hmeas1) continuous_fst\n  continuity\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $\\tau[X'_1;X'_2] = \\tau[X_1;X_2]$. -/\nlemma ProbabilityTheory.IdentDistrib.tau_eq [MeasurableSpace Ω₁] [MeasurableSpace Ω₂]\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂]\n    {μ₁ : Measure Ω₁} {μ₂ : Measure Ω₂} {μ'₁ : Measure Ω'₁} {μ'₂ : Measure Ω'₂}\n    {X₁ : Ω₁ → G} {X₂ : Ω₂ → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n    (h₁ : IdentDistrib X₁ X'₁ μ₁ μ'₁) (h₂ : IdentDistrib X₂ X'₂ μ₂ μ'₂) :\n    τ[X₁ ; μ₁ # X₂ ; μ₂ | p] = τ[X'₁ ; μ'₁ # X'₂ ; μ'₂ | p] := by\n  simp only [tau]\n  rw [(IdentDistrib.refl p.hmeas1.aemeasurable).rdist_eq h₁,\n      (IdentDistrib.refl p.hmeas2.aemeasurable).rdist_eq h₂,\n      h₁.rdist_eq h₂]\n\n/-- Property recording the fact that two random variables minimize the tau functional. Expressed\nin terms of measures on the group to avoid quantifying over all spaces, but this implies comparison\nwith any pair of random variables, see Lemma `is_tau_min`. -/\ndef tau_minimizes {Ω : Type*} [MeasureSpace Ω] (X₁ : Ω → G) (X₂ : Ω → G) : Prop :=\n  ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[X₁ # X₂ | p] ≤ τ[id ; ν₁ # id ; ν₂ | p]\n\n/-- If $X'_1, X'_2$ are copies of $X_1,X_2$, then $X_1, X_2$ minimize $\\tau$ iff $X_1', X_2'$ do. -/\nlemma ProbabilityTheory.IdentDistrib.tau_minimizes [MeasureSpace Ω]\n    [MeasureSpace Ω']\n    {X₁ X₂ : Ω → G} {X₁' X₂' : Ω' → G}\n    (h₁ : IdentDistrib X₁ X₁') (h₂ : IdentDistrib X₂ X₂') :\n    tau_minimizes p X₁ X₂ ↔ tau_minimizes p X₁' X₂' := by\n  simp_rw [_root_.tau_minimizes, h₁.tau_eq p h₂]\n\n/-- A pair of measures minimizing $\\tau$ exists. -/\nlemma tau_min_exists_measure [MeasurableSingletonClass G] :\n    ∃ (μ : Measure G × Measure G),\n    IsProbabilityMeasure μ.1 ∧ IsProbabilityMeasure μ.2 ∧\n    ∀ (ν₁ : Measure G) (ν₂ : Measure G), IsProbabilityMeasure ν₁ → IsProbabilityMeasure ν₂ →\n      τ[id ; μ.1 # id ; μ.2 | p] ≤ τ[id ; ν₁ # id ; ν₂ | p] := by\n  let _i : TopologicalSpace G := (⊥ : TopologicalSpace G) -- Equip G with the discrete topology.\n  have : DiscreteTopology G := ⟨rfl⟩\n  have GG_cpt : CompactSpace (ProbabilityMeasure G × ProbabilityMeasure G) := inferInstance\n  let T : ProbabilityMeasure G × ProbabilityMeasure G → ℝ := -- restrict τ to the compact subspace\n    fun ⟨μ₁, μ₂⟩ ↦ τ[id ; μ₁ # id ; μ₂ | p]\n  have T_cont : Continuous T := by apply continuous_tau_restrict_probabilityMeasure\n  haveI : Inhabited G := ⟨0⟩ -- Need to record this for Lean to know that proba measures exist.\n  obtain ⟨μ, _, hμ⟩ := @IsCompact.exists_isMinOn ℝ (ProbabilityMeasure G × ProbabilityMeasure G)\n                          _ _ _ _ Set.univ isCompact_univ ⟨default, trivial⟩ T T_cont.continuousOn\n  use ⟨μ.1.toMeasure, μ.2.toMeasure⟩\n  refine ⟨μ.1.prop, μ.2.prop, ?_⟩\n  intro ν₁ ν₂ Pν₁ Pν₂\n  rw [isMinOn_univ_iff] at hμ\n  let ν : ProbabilityMeasure G × ProbabilityMeasure G := ⟨⟨ν₁, Pν₁⟩, ν₂, Pν₂⟩\n  exact hμ ν\n\n/-- A pair of random variables minimizing $τ$ exists. -/\nlemma tau_minimizer_exists [MeasurableSingletonClass G] :\n    ∃ (Ω : Type uG) (mΩ : MeasureSpace Ω) (X₁ : Ω → G) (X₂ : Ω → G),\n    Measurable X₁ ∧ Measurable X₂ ∧ IsProbabilityMeasure (ℙ : Measure Ω) ∧\n    tau_minimizes p X₁ X₂ := by\n  let μ := (tau_min_exists_measure p).choose\n  have : IsProbabilityMeasure μ.1 := (tau_min_exists_measure p).choose_spec.1\n  have : IsProbabilityMeasure μ.2 := (tau_min_exists_measure p).choose_spec.2.1\n  have P : IsProbabilityMeasure (μ.1.prod μ.2) := by infer_instance\n  let M : MeasureSpace (G × G) := ⟨μ.1.prod μ.2⟩\n  refine ⟨G × G, M, Prod.fst, Prod.snd, measurable_fst, measurable_snd, P, ?_⟩\n  intro ν₁ ν₂ h₁ h₂\n  have A : τ[@Prod.fst G G # @Prod.snd G G | p] = τ[id ; μ.1 # id ; μ.2 | p] :=\n    ProbabilityTheory.IdentDistrib.tau_eq p IdentDistrib.fst_id IdentDistrib.snd_id\n  convert (tau_min_exists_measure p).choose_spec.2.2 ν₁ ν₂ h₁ h₂\n\n\nvariable [MeasureSpace Ω] [hΩ₁ : MeasureSpace Ω'₁] [hΩ₂ : MeasureSpace Ω'₂]\n  [IsProbabilityMeasure (ℙ : Measure Ω)]\n  [IsProbabilityMeasure (ℙ : Measure Ω'₁)] [IsProbabilityMeasure (ℙ : Measure Ω'₂)]\n  {X₁ : Ω → G} {X₂ : Ω → G} {X'₁ : Ω'₁ → G} {X'₂ : Ω'₂ → G}\n\nlemma is_tau_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    τ[X₁ # X₂ | p] ≤ τ[X'₁ # X'₂ | p] := by\n  let ν₁ := (ℙ : Measure Ω'₁).map X'₁\n  let ν₂ := (ℙ : Measure Ω'₂).map X'₂\n  have B : τ[X'₁ # X'₂ | p] = τ[id ; ν₁ # id ; ν₂ | p] :=\n    (identDistrib_id_right h1.aemeasurable).tau_eq p (identDistrib_id_right h2.aemeasurable)\n  convert h ν₁ ν₂ (isProbabilityMeasure_map h1.aemeasurable)\n    (isProbabilityMeasure_map h2.aemeasurable)\n\n/-- Let `X₁` and `X₂` be tau-minimizers associated to `p`, with $d[X_1,X_2]=k$, then\n$$ d[X'_1;X'_2] \\geq\n    k - \\eta (d[X^0_1;X'_1] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2] - d[X^0_2;X_2] )$$\nfor any $G$-valued random variables $X'_1,X'_2$.\n-/\nlemma distance_ge_of_min (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂ # X'₂] - d[p.X₀₂ # X₂])\n      ≤ d[X'₁ # X'₂] := by\n  have Z := is_tau_min p h h1 h2\n  simp [tau] at Z\n  linarith\n\n/-- Version of `distance_ge_of_min` with the measures made explicit. -/\nlemma distance_ge_of_min' {Ω'₁ Ω'₂ : Type*} (h : tau_minimizes p X₁ X₂)\n    [MeasurableSpace Ω'₁] [MeasurableSpace Ω'₂] {μ : Measure Ω'₁} {μ' : Measure Ω'₂}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] {X'₁: Ω'₁ → G} {X'₂: Ω'₂ → G}\n    (h1 : Measurable X'₁) (h2 : Measurable X'₂) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁; ℙ # X'₁; μ] - d[p.X₀₁ # X₁])\n      - p.η * (d[p.X₀₂; ℙ # X'₂; μ'] - d[p.X₀₂ # X₂]) ≤ d[X'₁; μ # X'₂; μ'] := by\n  set M1 : MeasureSpace Ω'₁ := { volume := μ }\n  set M2 : MeasureSpace Ω'₂ := { volume := μ' }\n  exact distance_ge_of_min p h h1 h2\n\n\nopen BigOperators\n\n","proof":":= by\n  have hz (a : ℝ) : a = ∑ z in FiniteRange.toFinset Z, (ℙ (Z ⁻¹' {z})).toReal * a := by\n    simp_rw [← Finset.sum_mul,← Measure.map_apply hZ (MeasurableSet.singleton _), Finset.sum_toReal_measure_singleton]\n    rw [FiniteRange.full hZ]\n    simp\n  have hw (a : ℝ) : a = ∑ w in FiniteRange.toFinset W, (ℙ (W ⁻¹' {w})).toReal * a := by\n    simp_rw [← Finset.sum_mul,← Measure.map_apply hW (MeasurableSet.singleton _), Finset.sum_toReal_measure_singleton]\n    rw [FiniteRange.full hW]\n    simp\n  rw [condRuzsaDist_eq_sum h1 hZ h2 hW, condRuzsaDist'_eq_sum h1 hZ, hz d[X₁ # X₂],\n    hz d[p.X₀₁ # X₁], hz (p.η * (d[p.X₀₂ # X'₂ | W] - d[p.X₀₂ # X₂])),\n    ← Finset.sum_sub_distrib, Finset.mul_sum, ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib]\n  apply Finset.sum_le_sum\n  intro z _\n  rw [condRuzsaDist'_eq_sum h2 hW, hw d[p.X₀₂ # X₂],\n    hw ((ℙ (Z ⁻¹' {z})).toReal * d[X₁ # X₂] - p.η * ((ℙ (Z ⁻¹' {z})).toReal *\n      d[p.X₀₁ ; ℙ # X'₁ ; ℙ[|Z ← z]] - (ℙ (Z ⁻¹' {z})).toReal * d[p.X₀₁ # X₁])),\n    ← Finset.sum_sub_distrib, Finset.mul_sum, Finset.mul_sum, ← Finset.sum_sub_distrib]\n  apply Finset.sum_le_sum\n  intro w _\n  rcases eq_or_ne (ℙ (Z ⁻¹' {z})) 0 with hpz | hpz\n  . simp [hpz]\n  rcases eq_or_ne (ℙ (W ⁻¹' {w})) 0 with hpw | hpw\n  . simp [hpw]\n  set μ := (hΩ₁.volume)[|Z ← z]\n  have hμ : IsProbabilityMeasure μ := cond_isProbabilityMeasure ℙ hpz\n  set μ' := ℙ[|W ← w]\n  have hμ' : IsProbabilityMeasure μ' := cond_isProbabilityMeasure ℙ hpw\n  suffices : d[X₁ # X₂] - p.η * (d[p.X₀₁; volume # X'₁; μ] - d[p.X₀₁ # X₁]) - p.η * (d[p.X₀₂; volume # X'₂; μ'] - d[p.X₀₂ # X₂])\n  ≤ d[X'₁ ; μ # X'₂; μ']\n  . replace this := mul_le_mul_of_nonneg_left this (show 0 ≤ (ℙ (Z ⁻¹' {z})).toReal * (ℙ (W ⁻¹' {w})).toReal by positivity)\n    convert this using 1\n    ring\n  exact distance_ge_of_min' p h h1 h2","declId":"PFR.TauFunctional.193_0.JHo9nKZSxI9j9eS","decl":"/-- For any $G$-valued random variables $X'_1,X'_2$ and random variables $Z,W$, one can lower\nbound $d[X'_1|Z;X'_2|W]$ by\n$$k - \\eta (d[X^0_1;X'_1|Z] - d[X^0_1;X_1] ) - \\eta (d[X^0_2;X'_2|W] - d[X^0_2;X_2] ).$$\n-/\nlemma condRuzsaDistance_ge_of_min [MeasurableSingletonClass G]\n    [Fintype S] [MeasurableSpace S] [MeasurableSingletonClass S]\n    [Fintype T] [MeasurableSpace T] [MeasurableSingletonClass T]\n    (h : tau_minimizes p X₁ X₂) (h1 : Measurable X'₁) (h2 : Measurable X'₂)\n    (Z : Ω'₁ → S) (W : Ω'₂ → T) (hZ : Measurable Z) (hW : Measurable W) :\n    d[X₁ # X₂] - p.η * (d[p.X₀₁ # X'₁ | Z] - d[p.X₀₁ # X₁])\n      - p.η * (d[p.X₀₂ # X'₂ | W] - d[p.X₀₂ # X₂]) ≤ d[X'₁ | Z # X'₂ | W] "}
