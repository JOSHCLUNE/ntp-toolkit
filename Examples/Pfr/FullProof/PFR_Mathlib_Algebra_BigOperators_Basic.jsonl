{"srcUpToDecl":"import Mathlib.Algebra.BigOperators.Basic\n\nopen Function\nopen scoped BigOperators\n\nnamespace Finset\n\n","proof":":= by\n  classical\n  exact (prod_nbij e (fun a ↦ mem_image_of_mem e) he (by simp [Set.surjOn_image]) h).trans $\n    prod_subset (image_subset_iff.2 h'e) $ by simpa using h'","declId":"PFR.Mathlib.Algebra.BigOperators.Basic.8_0.7pnrhy40A0f4AUg","decl":"@[to_additive]\nlemma prod_eq_of_injOn {α β R : Type*} [CommMonoid R] {s : Finset α} {t : Finset β}\n    (e : α → β) {f : α → R} {g : β → R} (he : Set.InjOn e s) (h'e : Set.MapsTo e s t)\n    (h : ∀ i ∈ s, f i = g (e i)) (h' : ∀ i ∈ t, i ∉ e '' s → g i = 1) :\n    ∏ i in s, f i = ∏ j in t, g j "}
{"srcUpToDecl":"import Mathlib.Algebra.BigOperators.Basic\n\nopen Function\nopen scoped BigOperators\n\nnamespace Finset\n\n@[to_additive]\nlemma prod_eq_of_injOn {α β R : Type*} [CommMonoid R] {s : Finset α} {t : Finset β}\n    (e : α → β) {f : α → R} {g : β → R} (he : Set.InjOn e s) (h'e : Set.MapsTo e s t)\n    (h : ∀ i ∈ s, f i = g (e i)) (h' : ∀ i ∈ t, i ∉ e '' s → g i = 1) :\n    ∏ i in s, f i = ∏ j in t, g j := by\n  classical\n  exact (prod_nbij e (fun a ↦ mem_image_of_mem e) he (by simp [Set.surjOn_image]) h).trans $\n    prod_subset (image_subset_iff.2 h'e) $ by simpa using h'\n\n","proof":":=\n  prod_eq_of_injOn e (hf.injOn _) (by simp) (fun i _ ↦ h i) (by simpa using h')","declId":"PFR.Mathlib.Algebra.BigOperators.Basic.17_0.7pnrhy40A0f4AUg","decl":"@[to_additive]\nlemma prod_eq_of_injective {α β R : Type*} [CommMonoid R] [Fintype α] [Fintype β]\n    (e : α → β) (hf : Injective e) {f : α → R} {g : β → R} (h : ∀ i, f i = g (e i))\n    (h' : ∀ i ∉ Set.range e, g i = 1) : ∏ i, f i = ∏ j, g j "}
