{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n","proof":":= by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2","declId":"PFR.ForMathlib.Entropy.RuzsaDist.47_0.4TdCzOoAsczoWMh","decl":"/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.59_0.4TdCzOoAsczoWMh","decl":"/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n","proof":":= Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩","declId":"PFR.ForMathlib.Entropy.RuzsaDist.64_0.4TdCzOoAsczoWMh","decl":"/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\n","proof":":= by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure","declId":"PFR.ForMathlib.Entropy.RuzsaDist.77_0.4TdCzOoAsczoWMh","decl":"lemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n","proof":":= by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity","declId":"PFR.ForMathlib.Entropy.RuzsaDist.83_0.4TdCzOoAsczoWMh","decl":"/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\n","proof":":= by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont","declId":"PFR.ForMathlib.Entropy.RuzsaDist.107_0.4TdCzOoAsczoWMh","decl":"lemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n","proof":":= by\n  simp only [rdist_def, entropy_def, Measure.map_id]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.119_0.4TdCzOoAsczoWMh","decl":"/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n","proof":":= by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble","declId":"PFR.ForMathlib.Entropy.RuzsaDist.123_0.4TdCzOoAsczoWMh","decl":"/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n","proof":":= by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.132_0.4TdCzOoAsczoWMh","decl":"/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n","proof":":= H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.138_0.4TdCzOoAsczoWMh","decl":"/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n","proof":":= by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν","declId":"PFR.ForMathlib.Entropy.RuzsaDist.150_0.4TdCzOoAsczoWMh","decl":"/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n","proof":":= by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ","declId":"PFR.ForMathlib.Entropy.RuzsaDist.160_0.4TdCzOoAsczoWMh","decl":"/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n","proof":":= by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring","declId":"PFR.ForMathlib.Entropy.RuzsaDist.187_0.4TdCzOoAsczoWMh","decl":"/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n","proof":":= by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.206_0.4TdCzOoAsczoWMh","decl":"/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n","proof":":= by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.217_0.4TdCzOoAsczoWMh","decl":"/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n","proof":":= by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.228_0.4TdCzOoAsczoWMh","decl":"/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n","proof":":= by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.235_0.4TdCzOoAsczoWMh","decl":"/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n","proof":":= by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.242_0.4TdCzOoAsczoWMh","decl":"/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n","proof":":= by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.247_0.4TdCzOoAsczoWMh","decl":"/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n","proof":":= by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'","declId":"PFR.ForMathlib.Entropy.RuzsaDist.331_0.4TdCzOoAsczoWMh","decl":"/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n","proof":":= by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability","declId":"PFR.ForMathlib.Entropy.RuzsaDist.348_0.4TdCzOoAsczoWMh","decl":"/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n","proof":":= by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.355_0.4TdCzOoAsczoWMh","decl":"/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n","proof":":= by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']","declId":"PFR.ForMathlib.Entropy.RuzsaDist.391_0.4TdCzOoAsczoWMh","decl":"/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n","proof":":= by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.417_0.4TdCzOoAsczoWMh","decl":"/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.430_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n","proof":":= by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.435_0.4TdCzOoAsczoWMh","decl":"/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n","proof":":= by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.444_0.4TdCzOoAsczoWMh","decl":"@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n","proof":":= by\n  simp [condRuzsaDist]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.450_0.4TdCzOoAsczoWMh","decl":"@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\n","proof":":= by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW","declId":"PFR.ForMathlib.Entropy.RuzsaDist.455_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.468_0.4TdCzOoAsczoWMh","decl":"/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n","proof":":= by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.471_0.4TdCzOoAsczoWMh","decl":"/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n","proof":":= by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.507_0.4TdCzOoAsczoWMh","decl":"/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n","proof":":= by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.533_0.4TdCzOoAsczoWMh","decl":"/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n","proof":":=\n  rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.544_0.4TdCzOoAsczoWMh","decl":"/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n","proof":":= by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.551_0.4TdCzOoAsczoWMh","decl":"@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n","proof":":= by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr","declId":"PFR.ForMathlib.Entropy.RuzsaDist.555_0.4TdCzOoAsczoWMh","decl":"/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n","proof":":= by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.582_0.4TdCzOoAsczoWMh","decl":"/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\n","proof":":= by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.598_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n","proof":":= by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.636_0.4TdCzOoAsczoWMh","decl":"/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n","proof":":= by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.651_0.4TdCzOoAsczoWMh","decl":"/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n","proof":":= by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _","declId":"PFR.ForMathlib.Entropy.RuzsaDist.667_0.4TdCzOoAsczoWMh","decl":"/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n","proof":":= by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm","declId":"PFR.ForMathlib.Entropy.RuzsaDist.680_0.4TdCzOoAsczoWMh","decl":"/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n","proof":":= by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.713_0.4TdCzOoAsczoWMh","decl":"/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n","proof":":= by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this","declId":"PFR.ForMathlib.Entropy.RuzsaDist.776_0.4TdCzOoAsczoWMh","decl":"/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\n","proof":":= by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this","declId":"PFR.ForMathlib.Entropy.RuzsaDist.849_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\n","proof":":= by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm","declId":"PFR.ForMathlib.Entropy.RuzsaDist.900_0.4TdCzOoAsczoWMh","decl":"lemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\n","proof":":= by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.917_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\n","proof":":= by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.916_0.4TdCzOoAsczoWMh","decl":"variable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\n","proof":":= by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl","declId":"PFR.ForMathlib.Entropy.RuzsaDist.935_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\n","proof":":= by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp","declId":"PFR.ForMathlib.Entropy.RuzsaDist.958_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\n","proof":":= by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1007_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n","proof":":= by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1064_0.4TdCzOoAsczoWMh","decl":"/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n","proof":":= by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1096_0.4TdCzOoAsczoWMh","decl":"/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n","proof":":= A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1115_0.4TdCzOoAsczoWMh","decl":"/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n","proof":":= by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1240_0.4TdCzOoAsczoWMh","decl":"/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\n","proof":":= by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1239_0.4TdCzOoAsczoWMh","decl":"variable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\n","proof":":= by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1273_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\n","proof":":= by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1272_0.4TdCzOoAsczoWMh","decl":"variable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\n","proof":":= by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1283_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\n","proof":":= by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1282_0.4TdCzOoAsczoWMh","decl":"variable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\n","proof":":= by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1299_0.4TdCzOoAsczoWMh","decl":"lemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\n","proof":":= by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1298_0.4TdCzOoAsczoWMh","decl":"variable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n","proof":":=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1327_0.4TdCzOoAsczoWMh","decl":"/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\n","proof":":=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1326_0.4TdCzOoAsczoWMh","decl":"variable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\n","proof":":=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1343_0.4TdCzOoAsczoWMh","decl":"lemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\n","proof":":=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1342_0.4TdCzOoAsczoWMh","decl":"variable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\n","proof":":= by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1351_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\n","proof":":= by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1350_0.4TdCzOoAsczoWMh","decl":"variable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\n","proof":":= by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1360_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\n","proof":":= by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1359_0.4TdCzOoAsczoWMh","decl":"variable (μ) in\nlemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\nlemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 := by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\n","proof":":= by\n  linarith [condRuzsaDist_diff_le'' μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1369_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_diff_le''' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤\n    d[Y ; μ' # Z ; μ']/2 + H[Y ; μ']/4 - H[Z ; μ']/4 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\nlemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 := by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]\n\n","proof":":= by\n  linarith [condRuzsaDist_diff_le'' μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1368_0.4TdCzOoAsczoWMh","decl":"variable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le''' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤\n    d[Y ; μ' # Z ; μ']/2 + H[Y ; μ']/4 - H[Z ; μ']/4 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\nlemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 := by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le''' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤\n    d[Y ; μ' # Z ; μ']/2 + H[Y ; μ']/4 - H[Z ; μ']/4 := by\n  linarith [condRuzsaDist_diff_le'' μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\n","proof":":= by\n  have hadd : IndepFun (Y + Z) Z' μ' :=\n    (h.indepFun_add_left (Fin.cases hY <| Fin.cases hZ <| Fin.cases hZ' Fin.rec0) 0 1 2\n      (show 0 ≠ 2 by decide) (show 1 ≠ 2 by decide))\n  have h1 := condRuzsaDist_diff_le'' μ hX (show Measurable (Y + Z) by measurability) hZ' hadd\n  have h2 := condRuzsaDist_diff_le μ hX hY hZ (h.indepFun (show 0 ≠ 1 by decide))\n  linarith [h1, h2]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1378_0.4TdCzOoAsczoWMh","decl":"lemma condRuzsaDist_diff_ofsum_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y Z Z' : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (hZ' : Measurable Z')\n    (h : iIndepFun (fun _ ↦ hG) ![Y, Z, Z'] μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange Z'] :\n    d[X ; μ # Y + Z | Y + Z + Z'; μ'] - d[X ; μ # Y; μ'] ≤\n    (H[Y + Z + Z'; μ'] + H[Y + Z; μ'] - H[Y ; μ'] - H[Z' ; μ'])/2 "}
{"srcUpToDecl":"import Mathlib.MeasureTheory.Constructions.Prod.Integral\nimport PFR.ForMathlib.Elementary\nimport PFR.ForMathlib.Entropy.Group\nimport PFR.ForMathlib.Entropy.Kernel.RuzsaDist\nimport PFR.ForMathlib.ProbabilityMeasureProdCont\nimport PFR.Mathlib.Algebra.BigOperators.Basic\nimport PFR.Mathlib.Algebra.Group.Hom.Basic\nimport PFR.Mathlib.Data.Fin.VecNotation\nimport PFR.Mathlib.Probability.IdentDistrib\n\n/-!\n# Ruzsa distance\n\nHere we define Ruzsa distance and establish its basic properties.\n\n## Main definitions\n\n* `rdist`: The Ruzsa distance $d[X ; Y]$ between two random variables\n* `condRuzsaDist`: The conditional Ruzsa distance $d[X | Z ; Y | W]$ (or $d[X ; Y | W]$) between two\n  random variables, conditioned on additional random variables\n\n## Main results\n\n* `rdist_triangle`: The Ruzsa triangle inequality for three random variables.\n* `kaimanovich_vershik`. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$\n* `ent_bsg`: If $Z=A+B$, then\n  $$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]$$\n-/\n\nopen Filter MeasureTheory Measure ProbabilityTheory\nopen scoped BigOperators\n\nattribute [symm] ProbabilityTheory.IdentDistrib.symm\n\nvariable {Ω Ω' Ω'' Ω''' G T : Type*}\n  [mΩ : MeasurableSpace Ω] {μ : Measure Ω}\n  [mΩ' : MeasurableSpace Ω'] {μ' : Measure Ω'}\n  [mΩ'' : MeasurableSpace Ω''] {μ'' : Measure Ω''}\n  [mΩ''' : MeasurableSpace Ω'''] {μ''' : Measure Ω'''}\n  [hG : MeasurableSpace G] [MeasurableSingletonClass G] [AddCommGroup G]\n  [MeasurableSub₂ G] [MeasurableAdd₂ G] [Countable G]\n  [Countable S] [Nonempty S] [MeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T]\n\nvariable {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G} [FiniteRange X] [FiniteRange Y] [FiniteRange Z]\n\n/-- The Ruzsa distance `rdist X Y` or $d[X ;Y]$ between two random variables is defined as\n$H[X'- Y'] - H[X']/2 - H[Y']/2$, where $X', Y'$ are independent copies of $X, Y$. -/\nnoncomputable\ndef rdist (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω := by volume_tac)\n    (μ' : Measure Ω' := by volume_tac) : ℝ :=\n  H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2\n\n/- Needed a new separator here, chose `#` arbitrarily, but am open to other suggestions -/\n@[inherit_doc rdist] notation3:max \"d[\" X \" ; \" μ \" # \" Y \" ; \" μ' \"]\" => rdist X Y μ μ'\n\n@[inherit_doc rdist] notation3:max \"d[\" X \" # \" Y \"]\" => rdist X Y volume volume\n\n/-- Explicit formula for the Ruzsa distance. -/\nlemma rdist_def (X : Ω → G) (Y : Ω' → G) (μ : Measure Ω) (μ' : Measure Ω') :\n    d[X ; μ # Y ; μ']\n      = H[fun x ↦ x.1 - x.2 ; (μ.map X).prod (μ'.map Y)] - H[X ; μ]/2 - H[Y ; μ']/2 := rfl\n\n/-- Entropy depends continuously on the measure. -/\n-- TODO: Use notation `Hm[μ]` here? (figure out how)\nlemma continuous_measureEntropy_probabilityMeasure {Ω : Type*} [Fintype Ω]\n    [TopologicalSpace Ω] [DiscreteTopology Ω] [MeasurableSpace Ω] [OpensMeasurableSpace Ω] :\n    Continuous (fun (μ : ProbabilityMeasure Ω) ↦ measureEntropy (S := Ω) μ) := by\n  unfold measureEntropy\n  simp_rw [tsum_fintype]\n  apply continuous_finset_sum\n  intro ω _\n  apply Real.continuous_negMulLog.comp\n  simp only [measure_univ, inv_one, one_smul]\n  exact continuous_probabilityMeasure_apply_of_isClopen (s := {ω}) ⟨isOpen_discrete _, T1Space.t1 _⟩\n\nlemma continuous_entropy_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous (fun (μ : ProbabilityMeasure G) ↦ H[id ; μ.toMeasure]) := by\n  simp only [entropy_def, Measure.map_id]\n  exact continuous_measureEntropy_probabilityMeasure\n\n/-- Ruzsa distance depends continuously on the measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G] :\n    Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n        d[id ; μ.1.toMeasure # id ; μ.2.toMeasure]) := by\n  simp [rdist_def]\n  have obs₀ : Continuous (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦\n      H[fun x ↦ x.1 - x.2 ; μ.1.toMeasure.prod μ.2.toMeasure]) := by\n    simp_rw [entropy_def]\n    have diff_cts : Continuous (fun (x : G × G) ↦ x.1 - x.2) := by continuity\n    have key₁ := ProbabilityMeasure.continuous_prod_of_finite (α := G) (β := G)\n    have key₂ := ProbabilityMeasure.continuous_map diff_cts\n    convert continuous_measureEntropy_probabilityMeasure.comp (key₂.comp key₁)\n  have obs₁ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.1.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_fst\n    simp [entropy_def]\n  have obs₂ : Continuous\n      (fun (μ : ProbabilityMeasure G × ProbabilityMeasure G) ↦ H[id ; μ.2.toMeasure]) := by\n    convert (continuous_measureEntropy_probabilityMeasure (Ω := G)).comp continuous_snd\n    simp [entropy_def]\n  continuity\n\nlemma continuous_rdist_restrict_probabilityMeasure₁ [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[id ; P.map X # id ; μ.toMeasure]) := by\n  have obs : IsProbabilityMeasure (P.map X) := by\n    refine ⟨by simp [Measure.map_apply X_mble MeasurableSet.univ]⟩\n  let ι : ProbabilityMeasure G → ProbabilityMeasure G × ProbabilityMeasure G :=\n      fun ν ↦ ⟨⟨P.map X, obs⟩, ν⟩\n  have ι_cont : Continuous ι := Continuous.Prod.mk _\n  convert continuous_rdist_restrict_probabilityMeasure.comp ι_cont\n\n/-- Ruzsa distance between random variables equals Ruzsa distance between their distributions.-/\nlemma rdist_eq_rdist_id_map : d[X ; μ # Y ; μ'] = d[id ; μ.map X # id ; μ'.map Y] := by\n  simp only [rdist_def, entropy_def, Measure.map_id]\n\n/-- Ruzsa distance depends continuously on the second measure. -/\nlemma continuous_rdist_restrict_probabilityMeasure₁' [Fintype G]\n    [TopologicalSpace G] [DiscreteTopology G] [BorelSpace G]\n    (X : Ω → G) (P : Measure Ω := by volume_tac) [IsProbabilityMeasure P] (X_mble : Measurable X) :\n    Continuous\n      (fun (μ : ProbabilityMeasure G) ↦ d[X ; P # id ; μ.toMeasure]) := by\n  simp only [@rdist_eq_rdist_id_map Ω G G mΩ P hG, Measure.map_id]\n  exact continuous_rdist_restrict_probabilityMeasure₁ _ _ X_mble\n\n/-- If $X', Y'$ are copies of $X, Y$ respectively then $d[X' ; Y']=d[X ; Y]$. -/\nlemma ProbabilityTheory.IdentDistrib.rdist_eq {X' : Ω'' → G} {Y' : Ω''' →G}\n    (hX : IdentDistrib X X' μ μ'') (hY : IdentDistrib Y Y' μ' μ''') :\n    d[X ; μ # Y ; μ'] = d[X' ; μ'' # Y' ; μ'''] := by\n  simp [rdist, hX.map_eq, hY.map_eq, hX.entropy_eq, hY.entropy_eq]\n\n/-- If $X, Y$ are independent $G$-random variables then\n$$ d[X ; Y] := H[X - Y] - H[X]/2 - H[Y]/2$$-/\nlemma ProbabilityTheory.IndepFun.rdist_eq [IsFiniteMeasure μ]\n    {Y : Ω → G} (h : IndepFun X Y μ) (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y ; μ] = H[X - Y ; μ] - H[X ; μ]/2 - H[Y ; μ]/2 := by\n  rw [rdist_def]\n  congr 2\n  have h_prod : (μ.map X).prod (μ.map Y) = μ.map (⟨X, Y⟩) :=\n    ((indepFun_iff_map_prod_eq_prod_map_map hX.aemeasurable hY.aemeasurable).mp h).symm\n  rw [h_prod, entropy_def, Measure.map_map (measurable_fst.sub measurable_snd) (hX.prod_mk hY)]\n  rfl\n\n/-- $d[X;Y] ≤ H[X]/2 + H[Y]/2$. -/\nlemma rdist_le_avg_ent {X : Ω → G} {Y : Ω' → G} [FiniteRange X] [FiniteRange Y] (hX: Measurable X) (hY: Measurable Y) (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # Y ; μ'] ≤ (H[X ; μ] + H[Y ; μ'])/2 := by\n  rcases ProbabilityTheory.independent_copies_finiteRange hX hY μ μ' with ⟨ν, X', Y', hprob, hX', hY', hindep, hidentX, hidentY, hfinX, hfinY⟩\n  rw [← ProbabilityTheory.IdentDistrib.rdist_eq hidentX hidentY, ← IdentDistrib.entropy_eq hidentX, ← IdentDistrib.entropy_eq hidentY, ProbabilityTheory.IndepFun.rdist_eq hindep hX' hY']\n  suffices H[X' - Y'; ν] ≤ H[X'; ν] + H[Y'; ν] by linarith\n  change H[(fun x ↦ x.1 - x.2) ∘ ⟨X',Y' ⟩; ν] ≤ H[X'; ν] + H[Y'; ν]\n  apply (entropy_comp_le ν (by measurability) _).trans\n  exact entropy_pair_le_add hX' hY' ν\n\n/-- Applying an injective homomorphism does not affect Ruzsa distance. -/\nlemma rdist_of_inj  {H:Type*} [hH : MeasurableSpace H] [MeasurableSingletonClass H] [AddCommGroup H]\n  [MeasurableSub₂ H] [MeasurableAdd₂ H] [Countable H] (hX: Measurable X) (hY: Measurable Y) (φ: G →+ H) (hφ: Function.Injective φ) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']: d[φ ∘ X ; μ # φ ∘ Y ; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_def, rdist_def]\n    congr 2\n    . rw [← entropy_comp_of_injective _ (by measurability) _ hφ]\n      apply IdentDistrib.entropy_eq\n      constructor\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      . exact Measurable.aemeasurable (measurable_of_countable _)\n      set g := fun x : H × H ↦ x.1 - x.2\n      set f := fun x : G × G ↦ (φ x.1, φ x.2)\n      have : φ ∘ (fun x ↦ x.1 - x.2) = g ∘ f := by\n        ext x\n        simp\n      rw [this, ← MeasureTheory.Measure.map_map (g := g) (f := f) (measurable_of_countable _) (measurable_of_countable _), ← MeasureTheory.Measure.map_map (measurable_of_countable _) hX, ← MeasureTheory.Measure.map_map (measurable_of_countable _) hY]\n      congr\n      convert MeasureTheory.Measure.map_prod_map _ _ (measurable_of_countable _) (measurable_of_countable _)\n      . exact instSFiniteMap μ X\n      . exact instSFiniteMap μ' Y\n      all_goals infer_instance\n    . congr 1\n      exact entropy_comp_of_injective _ hX _ hφ\n    exact entropy_comp_of_injective _ hY _ hφ\n\n\n\n/-- $$ d[X ; 0] = H[X] / 2 $$ -/\nlemma rdist_zero_eq_half_ent [IsFiniteMeasure μ] [IsProbabilityMeasure μ'] :\n    d[X ; μ # fun _ ↦ 0 ; μ'] = H[X ; μ]/2 := by\n  have aux : H[fun x => x.1 - x.2 ; Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ')]\n            = H[X ; μ] := by\n    have h: Measure.map (fun x => x.1 - x.2)\n                        (Measure.prod (Measure.map X μ) (Measure.map (fun x => 0) μ'))\n            = Measure.map X μ := by\n              simp [MeasureTheory.Measure.map_const, MeasureTheory.Measure.prod_dirac]\n              rw [Measure.map_map]\n              have helper : ((fun (x : G × G) => x.1 - x.2) ∘ fun x => (x, (0 : G))) = id := by\n                funext; simp\n              rw [helper, Measure.map_id]\n              measurability\n              measurability\n    simp [entropy_def, h]\n  simp [rdist_def, entropy_const (0 : G), aux]\n  ring\n\n/-- $$ d[X ; Y] = d[Y ; X]$$ -/\nlemma rdist_symm [IsFiniteMeasure μ] [IsFiniteMeasure μ'] :\n    d[X ; μ # Y ; μ'] = d[Y ; μ' # X ; μ] := by\n  rw [rdist_def, rdist_def, sub_sub, sub_sub, add_comm]\n  congr 1\n  rw [← entropy_neg (measurable_fst.sub measurable_snd)]\n  have : (-fun x : G × G ↦ x.1 - x.2) = (fun x ↦ x.1 - x.2) ∘ Prod.swap := by ext ; simp\n  rw [this, entropy_def, ← Measure.map_map (measurable_fst.sub measurable_snd) measurable_swap,\n    Measure.prod_swap]\n  rfl\n\n/-- $$|H[X] - H[Y]| \\leq 2 d[X ; Y]$$ -/\nlemma diff_ent_le_rdist [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    |H[X ; μ] - H[Y ; μ']| ≤ 2 * d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  rw [← hIdX.rdist_eq hIdY, hind.rdist_eq hX' hY', ← hIdX.entropy_eq, ← hIdY.entropy_eq, abs_le]\n  have := max_entropy_le_entropy_sub hX' hY' hind\n  constructor\n  · linarith[le_max_right H[X'; ν] H[Y'; ν]]\n  · linarith[le_max_left H[X'; ν] H[Y'; ν]]\n\n/-- $$H[X - Y] - H[X] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[X ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_right H[X ; μ] H[Y; μ]]\n\n/-- $$H[X - Y] - H[Y] \\leq 2d[X ; Y]$$ -/\nlemma diff_ent_le_rdist'' [IsProbabilityMeasure μ] {Y : Ω → G}\n    (hX : Measurable X) (hY : Measurable Y) (h : IndepFun X Y μ) [FiniteRange Y]:\n    H[X - Y ; μ] - H[Y ; μ] ≤ 2 * d[X ; μ # Y ; μ] := by\n  rw [h.rdist_eq hX hY]\n  linarith[max_entropy_le_entropy_sub hX hY h, le_max_left H[X ; μ] H[Y; μ]]\n\n/-- $$ d[X ; Y] \\geq 0$$ -/\nlemma rdist_nonneg [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) : 0 ≤ d[X ; μ # Y ; μ'] := by\n  linarith [ge_trans (diff_ent_le_rdist hX hY) (abs_nonneg (H[X ; μ] - H[Y ; μ']))]\n\n/-- If $G$ is an additive group and $X$ is a $G$-valued random variable and\n$H\\leq G$ is a finite subgroup then, with $\\pi:G\\to G/H$ the natural homomorphism we have\n(where $U_H$ is uniform on $H$) $\\mathbb{H}(\\pi(X))\\leq 2d[X;U_H].$ -/\nlemma ent_of_proj_le {UH: Ω' → G} [FiniteRange X] [FiniteRange UH]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hU: Measurable UH) {H: AddSubgroup G} [Finite H] -- TODO: infer from [FiniteRange UH]?\n    (hunif: IsUniform H UH μ')\n    : H[(QuotientAddGroup.mk' H) ∘ X; μ] ≤ 2 * d[X; μ # UH ; μ'] := by\n  obtain ⟨ν, X', UH', hν, hX', hUH', h_ind, h_id_X', h_id_UH', _, _⟩ :=\n    independent_copies_finiteRange hX hU μ μ'\n  replace hunif : IsUniform H UH' ν :=\n    IsUniform.of_identDistrib hunif h_id_UH'.symm (measurableSet_discrete _)\n  rewrite [← (h_id_X'.comp (measurable_discrete _)).entropy_eq, ← h_id_X'.rdist_eq h_id_UH']\n  let π := ⇑(QuotientAddGroup.mk' H)\n  let νq := Measure.map (π ∘ X') ν\n  haveI : Countable (HasQuotient.Quotient G H) := Quotient.countable\n  haveI : MeasurableSingletonClass (HasQuotient.Quotient G H) :=\n    { measurableSet_singleton := fun _ ↦ measurableSet_quotient.mpr (measurableSet_discrete _) }\n  have : H[X' - UH' | π ∘ X' ; ν] = H[UH' ; ν] := by\n    have h_meas_le : ∀ y ∈ FiniteRange.toFinset (π ∘ X'),\n        (νq {y}).toReal * H[X' - UH' | (π ∘ X') ← y ; ν] ≤ (νq {y}).toReal * H[UH' ; ν] := by\n      intro x _\n      refine mul_le_mul_of_nonneg_left ?_ ENNReal.toReal_nonneg\n      let ν' := ν[|π ∘ X' ← x]\n      let π' := QuotientAddGroup.mk (s := H)\n      have h_card : Nat.card (π' ⁻¹' {x}) = Nat.card H := Nat.card_congr <|\n        (QuotientAddGroup.preimageMkEquivAddSubgroupProdSet H _).trans <| Equiv.prodUnique H _\n      haveI : Finite (π' ⁻¹' {x}) :=\n        Nat.finite_of_card_ne_zero <| h_card.trans_ne <| Nat.pos_iff_ne_zero.mp Nat.card_pos\n      let H_x := (π' ⁻¹' {x}).toFinite.toFinset\n      have h : ∀ᵐ ω ∂ν', (X' - UH') ω ∈ H_x := by\n        let T : Set (G × G) := ((π' ∘ X') ⁻¹' {x})ᶜ\n        let U : Set (G × G) := UH' ⁻¹' Hᶜ\n        have h_subset : (X' - UH') ⁻¹' H_xᶜ ⊆ T ∪ U :=\n          fun ω hω ↦ Classical.byContradiction fun _ ↦ by simp_all [not_or]\n        refine MeasureTheory.mem_ae_iff.mpr (le_zero_iff.mp ?_)\n        calc\n          _ ≤ (ν' T) + (ν' U) := (measure_mono h_subset).trans (measure_union_le T U)\n          _ = (ν' T) + 0 := congrArg _ <| by\n            show _ * _ = 0\n            rw [le_zero_iff.mp <| (restrict_apply_le _ U).trans_eq hunif.measure_preimage_compl,\n              mul_zero]\n          _ = 0 := (add_zero _).trans <| by\n            have : restrict ν (π ∘ X' ⁻¹' {x}) T = 0 := by\n              simp [restrict_apply (measurableSet_discrete T)]\n            show _ * _ = 0\n            rw [this, mul_zero]\n      convert entropy_le_log_card_of_mem (Measurable.sub hX' hUH') h\n      simp_rw [hunif.entropy_eq' hUH', Set.Finite.mem_toFinset, h_card, SetLike.coe_sort_coe]\n    have h_one : (∑ x in FiniteRange.toFinset (π ∘ X'), (νq {x}).toReal) = 1 := by\n      rewrite [Finset.sum_toReal_measure_singleton]\n      apply (ENNReal.toReal_eq_one_iff _).mpr\n      haveI := isProbabilityMeasure_map <| (measurable_discrete (π ∘ X')).aemeasurable (μ := ν)\n      rewrite [← measure_univ (μ := νq), ← FiniteRange.range]\n      let rng := Set.range (π ∘ X')\n      have h_compl : νq rngᶜ = 0 := ae_map_mem_range (π ∘ X') (measurableSet_discrete _) ν\n      rw [← MeasureTheory.measure_add_measure_compl (measurableSet_discrete rng), h_compl, add_zero]\n    haveI := FiniteRange.sub X' UH'\n    have h_ge : H[X' - UH' | π ∘ X' ; ν] ≥ H[UH' ; ν] := calc\n      _ ≥ H[X' - UH' | X' ; ν] := condEntropy_comp_ge ν hX' (hX'.sub hUH') π\n      _ = H[UH' | X' ; ν] := condEntropy_sub_left hUH' hX'\n      _ = H[UH' ; ν] := h_ind.symm.condEntropy_eq_entropy hUH' hX'\n    have h_le : H[X' - UH' | π ∘ X' ; ν] ≤ H[UH' ; ν] := by\n      rewrite [condEntropy_eq_sum _ _ _ (measurable_discrete _)]\n      apply (Finset.sum_le_sum h_meas_le).trans\n      rewrite [← Finset.sum_mul, h_one, one_mul]\n      rfl\n    exact h_le.ge_iff_eq.mp h_ge\n  have : H[X' - UH' ; ν] = H[π ∘ X' ; ν] + H[UH' ; ν] := by calc\n    _ = H[⟨X' - UH', π ∘ (X' - UH')⟩ ; ν] := (entropy_prod_comp (hX'.sub hUH') ν π).symm\n    _ = H[⟨X' - UH', π ∘ X'⟩ ; ν] := by\n      apply IdentDistrib.entropy_eq\n      apply IdentDistrib.of_ae_eq (Measurable.aemeasurable (measurable_discrete _))\n      apply MeasureTheory.mem_ae_iff.mpr\n      convert hunif.measure_preimage_compl\n      ext; simp\n    _ = H[π ∘ X' ; ν] + H[UH' ; ν] := by\n      rewrite [chain_rule ν (by exact hX'.sub hUH') (measurable_discrete _)]\n      congr\n  have : d[X' ; ν # UH' ; ν] = H[π ∘ X' ; ν] + (H[UH' ; ν] - H[X' ; ν]) / 2 := by\n    rewrite [h_ind.rdist_eq hX' hUH']\n    linarith only [this]\n  linarith only [this, (abs_le.mp (diff_ent_le_rdist hX' hUH' (μ := ν) (μ' := ν))).2]\n\n/-- Adding a constant to a random variable does not change the Rusza distance. -/\nlemma rdist_add_const [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X ; μ # Y + fun _ ↦ c; μ'] = d[X ; μ # Y ; μ'] := by\n  obtain ⟨ν, X', Y', _, hX', hY', hind, hIdX, hIdY, _, _⟩ := independent_copies_finiteRange hX hY μ μ'\n  have A : IdentDistrib (Y' + fun _ ↦ c) (Y + fun _ ↦ c) ν μ' := by\n    change IdentDistrib (fun ω ↦ Y' ω + c) (fun ω ↦ Y ω + c) ν μ'\n    apply hIdY.comp (measurable_add_const c)\n  have B : IndepFun X' (Y' + fun _ ↦ c) ν := by\n    change IndepFun X' (fun ω ↦ Y' ω + c) ν\n    apply hind.comp measurable_id (measurable_add_const c)\n  have C : X' - (Y' + fun _ ↦ c) = (X' - Y') + (fun _ ↦ -c) := by\n    ext ω; simp; abel\n  rw [← hIdX.rdist_eq hIdY, ← hIdX.rdist_eq A, hind.rdist_eq hX' hY',\n    B.rdist_eq hX' (hY'.add_const _), entropy_add_const hY' c, C, entropy_add_const]\n  exact hX'.sub hY'\n\n/-- A variant of `rdist_add_const` where one adds constants to both variables. -/\nlemma rdist_add_const' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] (c: G) (c': G)\n    (hX : Measurable X) (hY : Measurable Y) :\n    d[X + fun _ ↦ c; μ # Y + fun _ ↦ c'; μ'] = d[X ; μ # Y ; μ'] := by\n    rw [rdist_add_const _ hY, rdist_symm, rdist_add_const hY hX, rdist_symm]\n    measurability\n\n/-- The **improved entropic Ruzsa triangle inequality**. -/\nlemma ent_of_diff_le (X : Ω → G) (Y : Ω → G) (Z : Ω → G)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (h : IndepFun (⟨X, Y⟩) Z μ) [IsProbabilityMeasure μ] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    H[X - Y; μ] ≤ H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n  have h1 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] + H[X - Y; μ] ≤ H[⟨X - Z, X - Y⟩; μ] + H[⟨Y, X - Y⟩; μ] :=\n    entropy_triple_add_entropy_le μ (hX.sub hZ) hY (hX.sub hY)\n  have h2 : H[⟨X - Z, X - Y⟩ ; μ] ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n    calc H[⟨X - Z, X - Y⟩ ; μ] ≤ H[⟨X - Z, Y - Z⟩ ; μ] := by\n          have : ⟨X - Z, X - Y⟩ = (fun p ↦ (p.1, p.1 - p.2)) ∘ ⟨X - Z, Y - Z⟩ := by ext1; simp\n          rw [this]\n          apply entropy_comp_le μ (by measurability)\n    _ ≤ H[X - Z ; μ] + H[Y - Z ; μ] := by\n          have h : 0 ≤ H[X - Z ; μ] + H[Y - Z ; μ] - H[⟨X - Z, Y - Z⟩ ; μ] := by\n            apply mutualInfo_nonneg (by measurability) (by measurability) μ\n          linarith\n  have h3 : H[⟨Y, X - Y⟩ ; μ] ≤ H[⟨X, Y⟩ ; μ] := by\n    have : ⟨Y, X - Y⟩ = (fun p ↦ (p.2, p.1 - p.2)) ∘ ⟨X, Y⟩ := by ext1; simp\n    rw [this]\n    exact entropy_comp_le μ (hX.prod_mk hY) _\n  have h4 : H[⟨X - Z, ⟨Y, X - Y⟩⟩; μ] = H[⟨X, ⟨Y, Z⟩⟩ ; μ] := by\n    refine entropy_of_comp_eq_of_comp μ ((hX.sub hZ).prod_mk (hY.prod_mk (hX.sub hY)))\n      (hX.prod_mk (hY.prod_mk hZ))\n      (fun p : G × (G × G) ↦ (p.2.2 + p.2.1, p.2.1, -p.1 + p.2.2 + p.2.1))\n      (fun p : G × G × G ↦ (p.1 - p.2.2, p.2.1, p.1 - p.2.1)) ?_ ?_\n    · ext1; simp\n    · ext1; simp\n  have h5 : H[⟨X, ⟨Y, Z⟩⟩ ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n    rw [entropy_assoc hX hY hZ, entropy_pair_eq_add (hX.prod_mk hY) hZ]\n    exact h\n  rw [h4, h5] at h1\n  calc H[X - Y; μ] ≤ H[X - Z; μ] + H[Y - Z; μ] - H[Z; μ] := by linarith\n  _ = H[X - Z; μ] + H[Z - Y; μ] - H[Z; μ] := by\n    congr 2\n    rw [entropy_sub_comm hY hZ]\n\n/-- The **entropic Ruzsa triangle inequality** -/\nlemma rdist_triangle {X : Ω → G} {Y : Ω' → G} {Z : Ω'' → G}\n  (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n  [hμ : IsProbabilityMeasure μ] [hμ' : IsProbabilityMeasure μ'] [hμ'' : IsProbabilityMeasure μ''] [FiniteRange X] [FiniteRange Y] [FiniteRange Z]:\n    d[X ; μ # Z ; μ''] ≤ d[X ; μ # Y ; μ'] + d[Y ; μ' # Z ; μ''] := by\n  obtain ⟨A, mA, μA, X', Y', Z', hμA, hInd, hX', hY', hZ', HX, HY, HZ, _, _, _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ''\n  suffices : d[X' ; μA # Z' ; μA] ≤ d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA]\n  { rwa [HX.rdist_eq HY, HY.rdist_eq HZ, HX.rdist_eq HZ] at this }\n  have IndepLem : IndepFun (⟨X', Z'⟩) Y' μA\n  · exact iIndepFun.indepFun_prod_mk hInd (fun i => by fin_cases i ; all_goals { simpa }) 0 2 1\n      (by norm_cast) (by norm_cast)\n  calc d[X' ; μA # Z' ; μA] = H[X' - Z'; μA] - (H[X'; μA] / 2 + H[Z'; μA] / 2) := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using hInd.indepFun (show 0 ≠ 2 by norm_cast)) hX' hZ'] ; ring\n    _ ≤ (H[X' - Y' ; μA] + H[Y' - Z' ; μA] - H[Y' ; μA]) - (H[X'; μA] / 2 + H[Z'; μA] / 2) :=\n          sub_le_sub_right (ent_of_diff_le _ _ _ hX' hZ' hY' IndepLem) _\n    _ = (H[X' - Y' ; μA] - H[X'; μA] / 2 - H[Y' ; μA] / 2) +\n          (H[Y' - Z' ; μA] - H[Y' ; μA] / 2 - H[Z'; μA] / 2) := by ring\n    _ = d[X' ; μA # Y' ; μA] + d[Y' ; μA # Z' ; μA] := by\n        rw [ProbabilityTheory.IndepFun.rdist_eq (by simpa using (iIndepFun.indepFun hInd\n          (show 0 ≠ 1 by norm_cast))) hX' hY', ProbabilityTheory.IndepFun.rdist_eq\n          (by simpa using (iIndepFun.indepFun hInd (show 1 ≠ 2 by norm_cast))) hY' hZ']\n\nvariable [MeasurableSingletonClass S] [MeasurableSingletonClass T]\n\n/-- The conditional Ruzsa distance `d[X|Z ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) [IsFiniteMeasure μ]\n    (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" ; \" μ \" # \" Y \" | \" W \" ; \" μ'\"]\" => condRuzsaDist X Z Y W μ μ'\n\n@[inherit_doc condRuzsaDist]\nnotation3:max \"d[\" X \" | \" Z \" # \" Y \" | \" W \"]\" => condRuzsaDist X Z Y W volume volume\n\nlemma condRuzsaDist_def (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; μ # Y | W ; μ']\n      = dk[condDistrib X Z μ ; μ.map Z # condDistrib Y W μ' ; μ'.map W] := rfl\n\n/-- $$ d[X|Z; Y|W] = d[Y|W; X|Z]$$-/\nlemma condRuzsaDist_symm {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T} (hZ : Measurable Z)\n    (hW : Measurable W) [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange Z]\n    [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ'] = d[Y | W ; μ' # X | Z ; μ] := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist_symm]\n\n@[simp] lemma condRuszaDist_zero_right (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    d[X | Z ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,\n    kernel.rdist_zero_right]\n\n@[simp] lemma condRuszaDist_zero_left (X : Ω → G) (Z : Ω → S) (Y : Ω' → G) (W : Ω' → T)\n    (μ' : Measure Ω') [IsFiniteMeasure μ'] :\n    d[X | Z ; 0 # Y | W ; μ'] = 0 := by\n  simp [condRuzsaDist]\n\nlemma condRuzsaDist_nonneg {X : Ω → G} (hX : Measurable X) [FiniteRange X]\n    {Z : Ω → S} (hZ : Measurable Z) [FiniteRange Z]\n    {Y : Ω' → G} (hY : Measurable Y) [FiniteRange Y]\n    {W : Ω' → T} (hW : Measurable W) [FiniteRange W]\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] :\n    0 ≤ d[X | Z ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def]\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ'.map W) := isProbabilityMeasure_map hW.aemeasurable\n  refine kernel.rdist_nonneg ?_ ?_\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hX hZ\n  · exact kernel.aefiniteKernelSupport_condDistrib _ _ _ hY hW\n\n/-- Ruzsa distance of random variables equals Ruzsa distance of the kernels. -/\nlemma rdist_eq_rdistm : d[X ; μ # Y ; μ'] = kernel.rdistm (μ.map X) (μ'.map Y) := rfl\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$. -/\nlemma condRuzsaDist_eq_sum {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z in FiniteRange.toFinset Z, ∑ w in FiniteRange.toFinset W,\n        (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (μ.map Z) (μ'.map W) ((((FiniteRange.toFinset Z)\n      ×ˢ (FiniteRange.toFinset W)) : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Finset.sum_product,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X|Z; Y|W]$ in a fintype. -/\nlemma condRuzsaDist_eq_sum' {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (μ' : Measure Ω') [IsFiniteMeasure μ']\n    [Fintype S] [Fintype T] :\n    d[X | Z ; μ # Y | W ; μ']\n      = ∑ z, ∑ w, (μ (Z ⁻¹' {z})).toReal * (μ' (W ⁻¹' {w})).toReal\n          * d[X ; (μ[|Z ← z]) # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist_def, kernel.rdist, integral_eq_sum]\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, smul_eq_mul, Fintype.sum_prod_type,\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with z\n  congr with w\n  by_cases hz : μ (Z ⁻¹' {z}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ, hz]\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm]\n  rw [condDistrib_apply hX hZ _ _ hz, condDistrib_apply hY hW _ _ hw]\n\n/-- The conditional Ruzsa distance `d[X ; Y|W]`. -/\nnoncomputable\ndef condRuzsaDist' (X : Ω → G) (Y : Ω' → G) (W : Ω' → T)\n    (μ : Measure Ω := by volume_tac) (μ' : Measure Ω' := by volume_tac) [IsFiniteMeasure μ'] : ℝ :=\n  dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W]\n\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" ; \" μ \" # \" Y \" | \" W \" ; \" μ' \"]\" => condRuzsaDist' X Y W μ μ'\n@[inherit_doc condRuzsaDist']\nnotation3:max \"d[\" X \" # \" Y \" | \" W \"]\" => condRuzsaDist' X Y W volume volume\n\n/-- Conditional Ruzsa distance equals Ruzsa distance of associated kernels. -/\nlemma condRuzsaDist'_def (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) (μ' : Measure Ω')\n    [IsFiniteMeasure μ'] :\n    d[X ; μ # Y | W ; μ'] =\n      dk[kernel.const Unit (μ.map X) ; Measure.dirac () # condDistrib Y W μ' ; μ'.map W] :=\n  rfl\n\n@[simp] lemma condRuzsaDist'_zero_right (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (μ : Measure Ω) :\n    d[X ; μ # Y | W ; 0] = 0 := by\n  simp only [condRuzsaDist'_def, aemeasurable_zero_measure, not_true_eq_false, Measure.map_zero,  kernel.rdist_zero_right]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$. -/\nlemma condRuzsaDist'_eq_sum {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  have : Measure.prod (dirac ()) (μ'.map W) ((Finset.univ (α := Unit) ×ˢ FiniteRange.toFinset W : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, kernel.rdist, integral_eq_sum' _ this]\n  simp_rw [Measure.prod_apply_singleton, smul_eq_mul, Finset.sum_product]\n  simp only [Finset.univ_unique, PUnit.default_eq_unit, MeasurableSpace.measurableSet_top,\n    Measure.dirac_apply', Set.mem_singleton_iff, Set.indicator_of_mem, Pi.one_apply, one_mul,\n    Finset.sum_singleton]\n  simp_rw [Measure.map_apply hW (measurableSet_singleton _)]\n  congr with w\n  by_cases hw : μ' (W ⁻¹' {w}) = 0\n  · simp only [mul_eq_mul_left_iff]\n    refine Or.inr ?_\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top μ', hw]\n  congr 1\n  rw [rdist_eq_rdistm, condDistrib_apply hY hW _ _ hw]\n  congr\n\n/-- Alternate formula for conditional Ruzsa distance $d[X ; Y|W]$ when T is a Fintype. -/\nlemma condRuzsaDist'_eq_sum' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T} (hY : Measurable Y)\n    (hW : Measurable W) (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | W ; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_eq_sum hY hW μ μ']\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\nopen scoped ENNReal\n\nlemma condRuzsaDist'_prod_eq_sum {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [FiniteRange W] [FiniteRange W']:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w in FiniteRange.toFinset W, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  have : d[X ; μ # Y | ⟨W', W⟩; μ'] = ∑ w in ((FiniteRange.toFinset W') ×ˢ FiniteRange.toFinset W), (μ' ((fun a => (W' a, W a)) ⁻¹' {w})).toReal * d[X ; μ # Y ; μ'[|(fun a => (W' a, W a)) ⁻¹' {w}]] := by\n    rw [condRuzsaDist'_eq_sum hY (hW'.prod_mk hW)]\n    apply Finset.sum_subset\n    . intro (t, t')\n      simp\n      intro ω h1 h2\n      exact ⟨⟨ω, h1⟩, ⟨ω, h2⟩⟩\n    intro (t, t') _ ht\n    simp at ht\n    have : (fun a => (W' a, W a)) ⁻¹' {(t, t')} = ∅ := by\n      ext ω\n      simp\n      exact ht ω\n    simp [this]\n  rw [this, Finset.sum_product_right]\n  congr 1 with w\n  rw [condRuzsaDist'_eq_sum hY hW', Finset.mul_sum]\n  congr 1 with w'\n  rw [← mul_assoc]\n  have A : (fun a ↦ (W' a, W a)) ⁻¹' {(w', w)} = W' ⁻¹' {w'} ∩ W⁻¹' {w} := by ext; simp\n  congr 1\n  · simp only [ProbabilityTheory.cond, smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n      smul_eq_mul, ENNReal.toReal_mul, A, restrict_apply (hW' (MeasurableSet.singleton w'))]\n    rcases eq_bot_or_bot_lt (μ' (W ⁻¹' {w})) with hw|hw\n    · have : μ' (W' ⁻¹' {w'} ∩ W ⁻¹' {w}) = 0 :=\n        le_antisymm (le_trans (measure_mono (Set.inter_subset_right _ _)) hw.le) bot_le\n      simp [hw, this]\n    · rw [← mul_assoc, ← ENNReal.toReal_mul, ENNReal.mul_inv_cancel, ENNReal.one_toReal, one_mul]\n      exacts [hw.ne', by finiteness]\n  · congr 1\n    rw [A, cond_cond_eq_cond_inter'' (hW (MeasurableSet.singleton w))\n      (hW' (MeasurableSet.singleton w')), Set.inter_comm]\n\n/-- Version of `condRuzsaDist'_prod_eq_sum` when `W` has finite codomain. -/\nlemma condRuzsaDist'_prod_eq_sum' {X : Ω → G} {Y : Ω' → G} {W W' : Ω' → T}\n    (μ : Measure Ω) (μ' : Measure Ω') (hY : Measurable Y) (hW' : Measurable W') (hW : Measurable W)\n    [IsFiniteMeasure μ'] [Fintype T]:\n    d[X ; μ # Y | ⟨W', W⟩; μ']\n      = ∑ w, (μ' (W ⁻¹' {w})).toReal * d[X ; μ # Y | W' ; (μ'[|W ← w])] := by\n  rw [condRuzsaDist'_prod_eq_sum μ μ' hY hW' hW]\n  apply Finset.sum_subset\n  . simp\n  intro w _ hw\n  simp at hw\n  have : W⁻¹' {w} = ∅ := by\n    ext ω; simp [hw ω]\n  simp [this]\n\n/-- Explicit formula for conditional Ruzsa distance $d[X ; Y|W]$, in integral form. -/\nlemma condRuzsaDist'_eq_integral (X : Ω → G) {Y : Ω' → G} {W : Ω' → T}\n    (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) (μ' : Measure Ω') [IsFiniteMeasure μ'] [FiniteRange W] :\n    d[X ; μ # Y | W ; μ']\n      = (μ'.map W)[fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])]] := by\n  rw [condRuzsaDist'_eq_sum hY hW]\n  simp_rw [← smul_eq_mul]\n  have : (μ'.map W) (FiniteRange.toFinset W : Set T)ᶜ = 0 := by\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  convert symm $ integral_eq_sum' (μ'.map W) this (fun w ↦ d[X ; μ # Y ; (μ'[|W ← w])])\n  rw [Measure.map_apply hW (MeasurableSet.singleton _)]\n\n/-- Conditioning by a constant does not affect Ruzsa distance. -/\nlemma condRuzsaDist_of_const {X : Ω → G} (hX : Measurable X) (Y : Ω' → G) (W : Ω' → T) (c : S)\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [FiniteRange W] :\n    d[X|(fun _ ↦ c) ; μ # Y | W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist_def, condRuzsaDist'_def, Measure.map_const,measure_univ,one_smul, kernel.rdist,\n    kernel.rdist, integral_prod, integral_dirac, integral_prod,integral_dirac]\n  dsimp; congr; ext x; congr\n  rw [condDistrib_apply hX measurable_const]\n  · simp\n  · simp\n  · exact integrable_of_finiteSupport _\n  · exact integrable_of_finiteSupport _\n\n/-- If $(X,Z)$ and $(Y,W)$ are independent, then\n$$ d[X | Z ; Y | W] = H[X'- Y'|Z', W'] - H[X'|Z']/2 - H[Y'|W']/2$$\n-/\nlemma condRuzsaDist_of_indep\n    {X : Ω → G} {Z : Ω → S} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (⟨X, Z⟩) (⟨Y, W⟩) μ) [FiniteRange Z] [FiniteRange W] :\n    d[X | Z ; μ # Y | W ; μ] = H[X - Y | ⟨Z, W⟩ ; μ] - H[X | Z ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map Z) := isProbabilityMeasure_map hZ.aemeasurable\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ (hZ.prod_mk hW),\n    condEntropy_eq_kernel_entropy hX hZ, condEntropy_eq_kernel_entropy hY hW]\n  swap; · exact hX.sub hY\n  congr 2\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have hZW_map : μ.map (⟨Z, W⟩) = (μ.map Z).prod (μ.map W) :=\n    (indepFun_iff_map_prod_eq_prod_map_map hZ.aemeasurable hW.aemeasurable).mp hZW\n  rw [← hZW_map]\n  refine kernel.entropy_congr ?_\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (hZ.prod_mk hW) _ _).symm\n  refine (this.symm.trans ?_).symm\n  suffices kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft S (condDistrib Y W μ)\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ by\n    filter_upwards [this] with x hx\n    rw [kernel.map_apply, kernel.map_apply, hx]\n  . exact (condDistrib_eq_prod_of_indepFun hX hZ hY hW μ h).symm\n\n/-- Formula for conditional Ruzsa distance for independent sets of variables. -/\nlemma condRuzsaDist'_of_indep {X : Ω → G} {Y : Ω → G} {W : Ω → T}\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun X (⟨Y, W⟩) μ) [FiniteRange W] :\n    d[X ; μ # Y | W ; μ] = H[X - Y | W ; μ] - H[X ; μ]/2 - H[Y | W ; μ]/2 := by\n  have : IsProbabilityMeasure (μ.map W) := isProbabilityMeasure_map hW.aemeasurable\n  rw [condRuzsaDist'_def, kernel.rdist_eq', condEntropy_eq_kernel_entropy _ hW,\n    condEntropy_eq_kernel_entropy hY hW, entropy_eq_kernel_entropy]\n  rotate_left\n  · exact hX.sub hY\n  congr 2\n  let Z : Ω → Unit := fun _ ↦ ()\n  rw [← condDistrib_unit_right hX μ]\n  have h' : IndepFun (⟨X,Z⟩) (⟨Y, W⟩) μ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul]\n    intro s t hs ht\n    have : ⟨X, Z⟩ ⁻¹' s = X ⁻¹' ((fun c ↦ (c, ())) ⁻¹' s) := by ext1 y; simp\n    rw [this]\n    rw [indepFun_iff_measure_inter_preimage_eq_mul] at h\n    exact h _ _ (measurable_prod_mk_right hs) ht\n  have h_indep := condDistrib_eq_prod_of_indepFun hX measurable_const hY hW _ h'\n  have h_meas_eq : μ.map (⟨Z, W⟩) = (Measure.dirac ()).prod (μ.map W) := by\n    ext s hs\n    rw [Measure.map_apply (measurable_const.prod_mk hW) hs, Measure.prod_apply hs, lintegral_dirac,\n      Measure.map_apply hW (measurable_prod_mk_left hs)]\n    congr\n  rw [← h_meas_eq]\n  have : kernel.map (kernel.prodMkRight T (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft Unit (condDistrib Y W μ)) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ)\n        (fun x ↦ x.1 - x.2) measurable_sub := by\n    filter_upwards [h_indep] with y hy\n    conv_rhs => rw [kernel.map_apply, hy]\n  rw [kernel.entropy_congr this]\n  have : kernel.map (condDistrib (⟨X, Y⟩) (⟨Z, W⟩) μ) (fun x ↦ x.1 - x.2) measurable_sub\n      =ᵐ[μ.map (⟨Z, W⟩)] condDistrib (X - Y) (⟨Z, W⟩) μ :=\n    (condDistrib_comp (hX.prod_mk hY) (measurable_const.prod_mk hW) _ _).symm\n  rw [kernel.entropy_congr this]\n  have h_meas : μ.map (⟨Z, W⟩) = (μ.map W).map (Prod.mk ()) := by\n    ext s hs\n    rw [Measure.map_apply measurable_prod_mk_left hs, h_meas_eq, Measure.prod_apply hs,\n      lintegral_dirac]\n  have h_ker : condDistrib (X - Y) (⟨Z, W⟩) μ\n      =ᵐ[μ.map (⟨Z, W⟩)] kernel.prodMkLeft Unit (condDistrib (X - Y) W μ) := by\n    rw [Filter.EventuallyEq, ae_iff_of_countable]\n    intro x hx\n    rw [Measure.map_apply (measurable_const.prod_mk hW) (measurableSet_singleton _)] at hx\n    ext s hs\n    have h_preimage_eq : (fun a ↦ (PUnit.unit, W a)) ⁻¹' {x} = W ⁻¹' {x.2} := by\n      conv_lhs => rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod]\n      ext1 y\n      simp\n    rw [kernel.prodMkLeft_apply, condDistrib_apply' _ (measurable_const.prod_mk hW) _ _ hx hs,\n      condDistrib_apply' _ hW _ _ _ hs]\n    rotate_left\n    · exact hX.sub hY\n    · convert hx\n      exact h_preimage_eq.symm\n    · exact hX.sub hY\n    congr\n  rw [kernel.entropy_congr h_ker, h_meas, kernel.entropy_prodMkLeft_unit]\n\n/-- The conditional Ruzsa distance is unchanged if the sets of random variables are replaced with\ncopies. -/\nlemma condRuzsaDist_of_copy {X : Ω → G} (hX : Measurable X) {Z : Ω → S} (hZ : Measurable Z)\n    {Y : Ω' → G} (hY : Measurable Y) {W : Ω' → T} (hW : Measurable W)\n    {X' : Ω'' → G} (hX' : Measurable X') {Z' : Ω'' → S} (hZ' : Measurable Z')\n    {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ] [IsFiniteMeasure μ'] [IsFiniteMeasure μ''] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib (⟨X, Z⟩) (⟨X', Z'⟩) μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange Z] [FiniteRange W] [FiniteRange Z'] [FiniteRange W'] :\n    d[X | Z ; μ # Y | W ; μ'] = d[X' | Z' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset Z) ∪ (FiniteRange.toFinset Z')\n  set B := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (μ.map Z) (μ'.map W) ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  have hfull' : Measure.prod (μ''.map Z') (μ'''.map W') ((A ×ˢ B : Finset (S × T)): Set (S × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    all_goals {\n      rw [Measure.map_apply ‹_›]\n      convert measure_empty\n      simp [← FiniteRange.range]\n      measurability\n    }\n  rw [condRuzsaDist_def, condRuzsaDist_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hZZ' : μ.map Z = μ''.map Z' := (h1.comp measurable_snd).map_eq\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hZZ', ← hWW',\n    Measure.map_apply hZ (measurableSet_singleton _),\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hz : μ (Z ⁻¹' {x.1}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inl ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hz]\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · have hZZ'x : μ (Z ⁻¹' {x.1}) = μ'' (Z' ⁻¹' {x.1}) := by\n      have : μ.map Z {x.1} = μ''.map Z' {x.1} := by rw [hZZ']\n      rwa [Measure.map_apply hZ (measurableSet_singleton _),\n        Measure.map_apply hZ' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hX hZ _ _ hz hs, condDistrib_apply' hX' hZ' _ _ _ hs]\n    swap; · rwa [hZZ'x] at hz\n    congr\n    have : μ.map (⟨X, Z⟩) (s ×ˢ {x.1}) = μ''.map (⟨X', Z'⟩) (s ×ˢ {x.1}) := by rw [h1.map_eq]\n    rwa [Measure.map_apply (hX.prod_mk hZ) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hX'.prod_mk hZ') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ X' a) ⁻¹' s)] at this\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuzsaDist'_of_copy (X : Ω → G) {Y : Ω' → G} (hY : Measurable Y)\n    {W : Ω' → T} (hW : Measurable W)\n    (X' : Ω'' → G) {Y' : Ω''' → G} (hY' : Measurable Y') {W' : Ω''' → T} (hW' : Measurable W')\n    [IsFiniteMeasure μ'] [IsFiniteMeasure μ''']\n    (h1 : IdentDistrib X X' μ μ'') (h2 : IdentDistrib (⟨Y, W⟩) (⟨Y', W'⟩) μ' μ''')\n    [FiniteRange W] [FiniteRange W'] :\n    d[X ; μ # Y | W ; μ'] = d[X' ; μ'' # Y' | W' ; μ'''] := by\n  classical\n  set A := (FiniteRange.toFinset W) ∪ (FiniteRange.toFinset W')\n  have hfull : Measure.prod (dirac ()) (μ'.map W)\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  have hfull' : Measure.prod (dirac ()) (μ'''.map W')\n      ((Finset.univ (α := Unit) ×ˢ A : Finset (Unit × T)) : Set (Unit × T))ᶜ = 0 := by\n    apply prod_of_full_measure_finSet\n    . simp\n    rw [Measure.map_apply ‹_›]\n    convert measure_empty\n    simp [← FiniteRange.range]\n    measurability\n  rw [condRuzsaDist'_def, condRuzsaDist'_def, kernel.rdist, kernel.rdist,\n    integral_eq_sum' _ hfull, integral_eq_sum' _ hfull']\n  have hWW' : μ'.map W = μ'''.map W' := (h2.comp measurable_snd).map_eq\n  simp_rw [Measure.prod_apply_singleton, ENNReal.toReal_mul, ← hWW',\n    Measure.map_apply hW (measurableSet_singleton _)]\n  congr with x\n  by_cases hw : μ' (W ⁻¹' {x.2}) = 0\n  · simp only [smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero]\n    refine Or.inr (Or.inr ?_)\n    simp [ENNReal.toReal_eq_zero_iff, measure_ne_top, hw]\n  congr 2\n  · rw [kernel.const_apply, kernel.const_apply, h1.map_eq]\n  · have hWW'x : μ' (W ⁻¹' {x.2}) = μ''' (W' ⁻¹' {x.2}) := by\n      have : μ'.map W {x.2} = μ'''.map W' {x.2} := by rw [hWW']\n      rwa [Measure.map_apply hW (measurableSet_singleton _),\n        Measure.map_apply hW' (measurableSet_singleton _)] at this\n    ext s hs\n    rw [condDistrib_apply' hY hW _ _ hw hs, condDistrib_apply' hY' hW' _ _ _ hs]\n    swap; · rwa [hWW'x] at hw\n    congr\n    have : μ'.map (⟨Y, W⟩) (s ×ˢ {x.2}) = μ'''.map (⟨Y', W'⟩) (s ×ˢ {x.2}) := by rw [h2.map_eq]\n    rwa [Measure.map_apply (hY.prod_mk hW) (hs.prod (measurableSet_singleton _)),\n      Measure.map_apply (hY'.prod_mk hW') (hs.prod (measurableSet_singleton _)),\n      Set.mk_preimage_prod, Set.mk_preimage_prod, Set.inter_comm,\n      Set.inter_comm ((fun a ↦ Y' a) ⁻¹' s)] at this\n\nlemma condRuszaDist_prod_eq_of_indepFun {μ : Measure Ω} {μ' : Measure Ω'} {X : Ω → G} {Y : Ω' → G}\n    {W W' : Ω' → T} (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    (hW' : Measurable W') (h : IndepFun (⟨Y, W⟩) W' μ')\n    [IsProbabilityMeasure μ'] [Fintype T] :\n    d[X ; μ # Y | ⟨W, W'⟩ ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_prod_eq_sum' _ _ hY hW hW']\n  have : d[X ; μ # Y | W ; μ'] = ∑ z, (μ' (W' ⁻¹' {z})).toReal * d[X ; μ # Y | W ; μ'] := by\n    rw [← Finset.sum_mul, sum_measure_preimage_singleton' μ' hW', one_mul]\n  rw [this]\n  congr with w\n  rcases eq_or_ne (μ' (W' ⁻¹' {w})) 0 with hw|hw\n  · simp [hw]\n  congr 1\n  apply condRuzsaDist'_of_copy _ hY hW _ hY hW (IdentDistrib.refl hX.aemeasurable)\n  exact (h.identDistrib_cond (MeasurableSet.singleton w) (hY.prod_mk hW) hW' hw).symm\n\nvariable (μ μ') in\nlemma condRuzsaDist_comp_right {T' : Type*} [Fintype T] [Fintype T'] [MeasurableSpace T']\n    [MeasurableSingletonClass T'] [IsFiniteMeasure μ']\n    (X : Ω → G) (Y : Ω' → G) (W : Ω' → T) (e : T → T')\n    (hY : Measurable Y) (hW : Measurable W) (he : Measurable e)\n    (h'e : Function.Injective e) :\n    d[X ; μ # Y | e ∘ W ; μ'] = d[X ; μ # Y | W ; μ'] := by\n  rw [condRuzsaDist'_eq_sum' hY (he.comp hW), condRuzsaDist'_eq_sum' hY hW]\n  simp [Set.preimage_comp]\n  have A i : e ⁻¹' {e i} = {i} := by ext x; simp [Function.Injective.eq_iff h'e]\n  symm\n  apply Finset.sum_eq_of_injective e h'e (fun i ↦ ?_) (fun i hi ↦ ?_)\n  · simp [A]\n  · have : e ⁻¹' {i} = ∅ := by\n      contrapose! hi\n      rcases hi with ⟨x, rfl⟩\n      exact Set.mem_range_self x\n    simp [this]\n\nlemma condRuzsaDist_of_inj_map {G' : Type*} [Countable G'] [AddCommGroup G']\n  [MeasurableSpace G'] [MeasurableSingletonClass G'] [IsProbabilityMeasure μ]\n  (Y : Fin 4 → Ω → G) (h_indep : IndepFun (⟨Y 0, Y 2⟩) (⟨Y 1, Y 3⟩) μ)\n  (h_meas : ∀ i, Measurable (Y i)) (π : G × G →+ G')\n  (hπ : ∀ (h : G), Function.Injective (fun g ↦ π (g, h)))\n  [FiniteRange (Y 2)] [FiniteRange (Y 3)] :\n    d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] = d[Y 0 | Y 2 ; μ # Y 1 | Y 3 ; μ] := by\n  let f (h : G) (g : G) : G' := π (g, h)\n  let f' : G × G → G → G' := fun (h1, h2) ↦ fun g ↦ π (g, h1 - h2)\n  have hf' (t : G × G) : Function.Injective (f' t) := fun _ _ h ↦ hπ _ h\n  let f'' : G × G → G' × G := fun (g, h) ↦ (π (g, h), h)\n  have hf'' : Measurable f'' := measurable_of_countable _\n  have hm1 : Measurable (Y 0 - Y 1) := (h_meas 0).sub (h_meas 1)\n  have hm2 : Measurable (⟨Y 2, Y 3⟩) := (h_meas 2).prod_mk (h_meas 3)\n  rw [condRuzsaDist_of_indep (h_meas 0) (h_meas 2) (h_meas 1) (h_meas 3) μ h_indep,\n    condRuzsaDist_of_indep ((measurable_of_countable _).comp ((h_meas 0).prod_mk (h_meas 2)))\n    (h_meas 2) ((measurable_of_countable _).comp ((h_meas 1).prod_mk (h_meas 3))) (h_meas 3) μ\n    (h_indep.comp hf'' hf''),\n    ← condEntropy_of_injective μ hm1 hm2 f' hf', ← π.comp_sub,\n    ← condEntropy_of_injective μ (h_meas 0) (h_meas 2) f hπ,\n    ← condEntropy_of_injective μ (h_meas 1) (h_meas 3) f hπ]\n  rfl\n\nlemma condRuzsaDist'_of_inj_map [IsProbabilityMeasure μ] [elem: ElementaryAddCommGroup G 2]\n  {X B C : Ω → G}\n    (hX : Measurable X) (hB : Measurable B) (hC : Measurable C)\n    (h_indep : IndepFun X (⟨B, C⟩) μ) [FiniteRange X] [FiniteRange B] [FiniteRange C] :\n    d[X ; μ # B | B + C ; μ] = d[X ; μ # C | B + C ; μ] := by\n  let π : G × G →+ G :=\n  { toFun := fun x ↦ x.2 - x.1\n    map_zero' := by simp\n    map_add' := fun a b ↦ by simp only [Prod.snd_add, Prod.fst_add,\n      ElementaryAddCommGroup.sub_eq_add]; abel }\n  let Y : Fin 4 → Ω → G := ![-X, C, fun _ ↦ 0, B + C]\n  have _ : FiniteRange (Y 0) := by simp; infer_instance\n  have _ : FiniteRange (Y 1) := by simp; infer_instance\n  have _ : FiniteRange (Y 2) := by simp; infer_instance\n  have _ : FiniteRange (Y 3) := by simp; infer_instance\n\n  have hY_meas : ∀ i, Measurable (Y i) := by\n    intro i\n    fin_cases i\n    exacts [hX.neg, hC, measurable_const, hB.add hC]\n  calc d[X ; μ # B | B + C ; μ]\n    = d[X | fun _ : Ω ↦ (0 : G) ; μ # B | B + C ; μ] := by\n        rw [condRuzsaDist_of_const hX _ _]\n  _ = d[π ∘ ⟨-X, fun _ : Ω ↦ (0 : G)⟩ | fun _ : Ω ↦ (0 : G) ; μ # π ∘ ⟨C, B + C⟩ | B + C ; μ] := by\n        congr\n        · ext1 ω; simp\n        · ext1 ω\n          simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Function.comp_apply, Pi.add_apply]\n          abel\n  _ = d[π ∘ ⟨Y 0, Y 2⟩ | Y 2 ; μ # π ∘ ⟨Y 1, Y 3⟩ | Y 3 ; μ] := by congr\n  _ = d[-X | fun _ : Ω ↦ (0 : G) ; μ # C | B + C ; μ] := by\n        rw [condRuzsaDist_of_inj_map _ _ hY_meas π (fun _ ↦ sub_right_injective)]\n        · congr\n        · have h1 : (⟨Y 0, Y 2⟩) = (fun x ↦ (-x, 0)) ∘ X := by ext1 ω; simp\n          have h2 : (⟨Y 1, Y 3⟩) = (fun p ↦ (p.2, p.1 + p.2)) ∘ (⟨B, C⟩) := by\n            ext1 ω;\n            simp only [ElementaryAddCommGroup.neg_eq_self, Matrix.cons_val_one, Matrix.head_cons,\n              Function.comp_apply, Prod.mk.injEq, Matrix.cons_val', Pi.add_apply, Matrix.empty_val',\n              Matrix.cons_val_fin_one, true_and]\n            congr\n          rw [h1, h2]\n          refine h_indep.comp ?_ ?_\n          · exact measurable_neg.prod_mk measurable_const\n          · exact measurable_snd.prod_mk (measurable_fst.add measurable_snd)\n  _ = d[-X ; μ # C | B + C ; μ] := by rw [condRuzsaDist_of_const]; exact hX.neg\n  _ = d[X ; μ # C | B + C ; μ] := by -- because ElementaryAddCommGroup G 2\n        congr\n        simp\n\nlemma condRuzsaDist'_of_inj_map' [elem: ElementaryAddCommGroup G 2] [IsProbabilityMeasure μ]\n  [IsProbabilityMeasure μ''] {A : Ω'' → G} {B C : Ω → G} (hA : Measurable A) (hB : Measurable B)\n  (hC : Measurable C) [FiniteRange A] [FiniteRange B] [FiniteRange C]  :\n  d[A ; μ'' # B | B + C ; μ] = d[A ; μ'' # C | B + C ; μ] := by\n  -- we want to apply `condRuzsaDist'_of_inj_map'`, but for that all variables need to be in the same\n  -- probability space\n  let Ω' := Ω'' × Ω\n  set X₂' : Ω' → G := A ∘ Prod.fst with hX₂'_def\n  have hX₂' : Measurable X₂' := hA.comp measurable_fst\n  let B' : Ω' → G := B ∘ Prod.snd\n  have hB' : Measurable B' := hB.comp measurable_snd\n  let C' : Ω' → G := C ∘ Prod.snd\n  have hC' : Measurable C' := hC.comp measurable_snd\n  let μ' : Measure Ω' := Measure.prod μ'' μ\n  haveI : IsProbabilityMeasure μ' := by infer_instance\n  -- h1 and h2 should be applications of a new lemma?\n  have h1 : d[A ; μ'' # B | B + C ; μ] = d[X₂' ; μ' # B' | B' + C' ; μ'] := by\n    refine condRuzsaDist'_of_copy A hB (by measurability) X₂' hB' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hB.prod_mk (hB.add hC)).aemeasurable\n      · exact (hB'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨B', B' + C'⟩ = (⟨B, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hB.prod_mk (hB.add hC)\n  have h2 : d[A ; μ'' # C | B + C ; μ] = d[X₂' ; μ' # C' | B' + C' ; μ'] := by\n    apply condRuzsaDist'_of_copy _ hC (by measurability) X₂' hC' (by measurability) ?_ ?_\n    · constructor\n      · exact hA.aemeasurable\n      · exact hX₂'.aemeasurable\n      · rw [← Measure.map_map hA measurable_fst]\n        simp\n    · constructor\n      · exact (hC.prod_mk (hB.add hC)).aemeasurable\n      · exact (hC'.prod_mk (hB'.add hC')).aemeasurable\n      · have : ⟨C', B' + C'⟩ = (⟨C, B + C⟩) ∘ Prod.snd := by ext1 _; simp\n        rw [this, ← Measure.map_map _ measurable_snd]\n        · simp only [Measure.map_snd_prod, measure_univ, one_smul]\n        · exact hC.prod_mk (hB.add hC)\n  rw [h1, h2, condRuzsaDist'_of_inj_map hX₂' hB' hC']\n  rw [indepFun_iff_map_prod_eq_prod_map_map hX₂'.aemeasurable (hB'.prod_mk hC').aemeasurable]\n  have h_prod : (fun ω ↦ (X₂' ω, prod B' C' ω)) = Prod.map A (⟨B, C⟩) := by ext1; simp\n  have h_comp_snd : (fun a ↦ (B' a, C' a)) = (⟨B, C⟩) ∘ Prod.snd := by ext1; simp\n  rw [h_prod, h_comp_snd, hX₂'_def, ← Measure.map_map _ measurable_snd,\n    ← Measure.map_map _ measurable_fst, Measure.map_prod_map]\n  rotate_left\n  · exact hA\n  · exact hB.prod_mk hC\n  · exact hA\n  · exact hB.prod_mk hC\n  simp\n\n/-- The **Kaimanovich-Vershik inequality**. $$H[X + Y + Z] - H[X + Y] \\leq H[Y+ Z] - H[Y]$$ -/\nlemma kaimanovich_vershik {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X + Y + Z ; μ] - H[X + Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  suffices : (H[X ; μ] + H[Y ; μ] + H[Z ; μ]) + H[X + Y + Z ; μ]\n    ≤ (H[X ; μ] + H[Y + Z ; μ]) + (H[Z ; μ] + H[X + Y ; μ])\n  . linarith\n  have : ∀ (i : Fin 3), Measurable (![X, Y, Z] i) := fun i ↦ by fin_cases i <;> assumption\n  convert entropy_triple_add_entropy_le _ hX hZ (show Measurable (X + (Y + Z)) by measurability)\n    using 2\n  . calc\n      H[X ; μ] + H[Y ; μ] + H[Z ; μ] = H[⟨X, Y⟩ ; μ] + H[Z ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add hX hY]\n        convert h.indepFun (show 0 ≠ 1 by decide)\n      _ = H[⟨⟨X, Y⟩, Z⟩ ; μ] := by\n        rw [IndepFun.entropy_pair_eq_add (hX.prod_mk hY) hZ]\n        exact h.indepFun_prod_mk this 0 1 2 (by decide) (by decide)\n      _ = H[⟨X, ⟨Z , X + (Y + Z)⟩⟩ ; μ] := by\n        apply entropy_of_comp_eq_of_comp μ (by measurability) (by measurability)\n          (fun ((x, y), z) ↦ (x, z, x + y + z)) (fun (a, b, c) ↦ ((a, c - a - b), b))\n        all_goals { funext ω; dsimp [prod]; ext <;> dsimp; abel }\n  . rw [add_assoc]\n  . symm\n    refine (entropy_add_right hX (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hX (by measurability) ?_\n    exact h.indepFun_add_right this 0 1 2 (by decide) (by decide)\n  · rw [eq_comm, ← add_assoc]\n    refine (entropy_add_right' hZ (by measurability) _).trans $\n      IndepFun.entropy_pair_eq_add hZ (by measurability) ?_\n    exact h.indepFun_add_right this 2 0 1 (by decide) (by decide)\n\n/-- A version of the **Kaimanovich-Vershik inequality** with some variables negated. -/\nlemma kaimanovich_vershik' {X Y Z : Ω → G} (h : iIndepFun (fun _ ↦ hG) ![X, Y, Z] μ)\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) [IsProbabilityMeasure μ]\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[X - (Y + Z) ; μ] - H[X - Y ; μ] ≤ H[Y + Z ; μ] - H[Y ; μ] := by\n  rw [← entropy_neg (hY.add' hZ), ← entropy_neg hY]\n  simp_rw [sub_eq_add_neg, neg_add, ← add_assoc]\n  apply kaimanovich_vershik _ hX _ _\n  . convert (h.neg 1).neg 2\n    ext i; fin_cases i\n    · simp (discharger := decide)\n    · simp (discharger := decide)\n    · rw [← show ∀ h : 2 < 3, (2 : Fin 3) = ⟨2, h⟩ by intro; rfl]\n      simp (discharger := decide)\n  . exact hY.neg\n  exact hZ.neg\n\nsection BalogSzemerediGowers\n\n/-- The **entropic Balog-Szemerédi-Gowers inequality**. Let $A, B$ be $G$-valued random variables on\n$\\Omega$, and set $Z := A+B$. Then\n$$\\sum_{z} P[Z=z] d[(A | Z = z) ; (B | Z = z)] \\leq 3 I[A :B] + 2 H[Z] - H[A] - H[B]. $$\nTODO: remove the hypothesis of `Fintype G` from here and from `condIndep_copies'` -/\nlemma ent_bsg [IsProbabilityMeasure μ] {A B : Ω → G} (hA : Measurable A) (hB : Measurable B)\n    [Fintype G] :\n    (μ.map (A + B))[fun z ↦ d[A ; μ[|(A + B) ⁻¹' {z}] # B ; μ[|(A + B) ⁻¹' {z}]]]\n      ≤ 3 * I[A : B; μ] + 2 * H[A + B ; μ] - H[A ; μ] - H[B ; μ] := by\n  let Z := A + B\n  have hZ : Measurable Z := hA.add hB\n  obtain ⟨Ω', _, AB₁, AB₂, Z', ν, _, hAB₁, hAB₂, hZ', hABZ, hABZ₁, hABZ₂, hZ₁, hZ₂⟩ :=\n    condIndep_copies' (⟨A, B⟩) Z (hA.prod_mk hB) hZ μ (fun (a, b) c ↦ c = a + b)\n    (measurable_discrete _) (eventually_of_forall fun _ ↦ rfl)\n  let A₁ := fun ω ↦ (AB₁ ω).1\n  let B₁ := fun ω ↦ (AB₁ ω).2\n  let A₂ := fun ω ↦ (AB₂ ω).1\n  let B₂ := fun ω ↦ (AB₂ ω).2\n  replace hZ₁ : Z' = A₁ + B₁ := funext hZ₁\n  replace hZ₂ : Z' = A₂ + B₂ := funext hZ₂\n  have hA₁ : Measurable A₁ := hAB₁.fst\n  have hB₁ : Measurable B₁ := hAB₁.snd\n  have hA₂ : Measurable A₂ := hAB₂.fst\n  have hB₂ : Measurable B₂ := hAB₂.snd\n  have hZZ' : IdentDistrib Z' Z ν μ := hABZ₁.comp measurable_snd\n  have :=\n    calc\n      H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν]\n        = H[⟨⟨A₁, B₁⟩, ⟨⟨A₂, B₂⟩, Z'⟩⟩ ; ν] := entropy_of_comp_eq_of_comp _\n          (hA₁.prod_mk $ hB₁.prod_mk $ hA₁.sub hB₂) (hAB₁.prod_mk $ hAB₂.prod_mk hZ')\n            (fun (a, b, c) ↦ ((a, b), (b + c, a - c), a + b))\n            (fun ((a, b), (_c, d), _e) ↦ (a, b, a - d))\n          (by funext; simpa [sub_add_eq_add_sub, Prod.ext_iff, ← hZ₁, hZ₂, two_nsmul, ← add_sub_assoc,\n            add_comm, eq_sub_iff_add_eq] using congr_fun (hZ₂.symm.trans hZ₁) _) rfl\n      _ = H[⟨⟨A₁, B₁⟩, Z'⟩ ; ν] + H[⟨⟨A₂, B₂⟩, Z'⟩ ; ν] - H[Z' ; ν] :=\n        ent_of_cond_indep hAB₁ hAB₂ hZ' hABZ\n      _ = 2 * H[⟨⟨A, B⟩, Z⟩ ; μ] - H[Z ; μ] := by\n        rw [two_mul]\n        congr 1\n        congr 1 <;> exact IdentDistrib.entropy_eq ‹_›\n        exact hZZ'.entropy_eq\n      _ = 2 * H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 2\n        exact entropy_prod_comp (hA.prod_mk hB) _ fun x ↦ x.1 + x.2\n  have :=\n    calc\n      H[⟨A₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₁, B₂⟩ ; ν] := entropy_sub_right hA₁ hB₂ _\n      _ ≤ H[A₁ ; ν] + H[B₂ ; ν] := entropy_pair_le_add hA₁ hB₂ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₂.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n      H[⟨B₁, A₁ - B₂⟩ ; ν]\n        = H[⟨A₂, B₁⟩ ; ν] := by\n          rw [entropy_comm hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂),\n            ← entropy_sub_left' hA₂ hB₁, sub_eq_sub_iff_add_eq_add.2 $ hZ₁.symm.trans hZ₂]\n      _ ≤ H[A₂ ; ν] + H[B₁ ; ν] := entropy_pair_le_add hA₂ hB₁ _\n      _ = H[A ; μ] + H[B ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst.fst).entropy_eq\n        exact (hABZ₁.comp measurable_fst.snd).entropy_eq\n  have :=\n    calc\n     _ ≤ _ := entropy_triple_add_entropy_le ν hA₁ hB₁ (show Measurable (A₁ - B₂) from hA₁.sub hB₂)\n     _ ≤ _ := add_le_add ‹_› ‹_›\n  have :=\n    calc\n      H[A₁ - B₂ | Z' ; ν]\n        ≤ H[A₁ - B₂ ; ν] := condEntropy_le_entropy _ (hA₁.sub hB₂) hZ'\n      _ ≤ _ := le_sub_iff_add_le'.2 ‹_›\n      _ = 2 * I[A : B ; μ] + H[Z ; μ] := by\n        rw [‹H[⟨A₁, ⟨B₁, A₁ - B₂⟩⟩ ; ν] = _›, mutualInfo_def]; ring\n  have hA₁Z :=\n    calc\n      H[A₁ | Z' ; ν]\n      _ = H[⟨A₁, B₁⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₁, entropy_add_right, entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₁.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  have hB₂Z :=\n    calc\n      H[B₂ | Z' ; ν]\n      _ = H[⟨A₂, B₂⟩ ; ν] - H[Z' ; ν] := by\n        rw [chain_rule'', hZ₂, entropy_add_right', entropy_comm] <;> assumption\n      _ = H[⟨A, B⟩ ; μ] - H[Z ; μ] := by\n        congr 1\n        exact (hABZ₂.comp measurable_fst).entropy_eq\n        exact hZZ'.entropy_eq\n      _ = H[A ; μ] + H[B ; μ] - I[A : B ; μ] - H[Z ; μ] := by\n        rw [← entropy_add_entropy_sub_mutualInfo]\n  save\n  calc\n    (μ.map Z)[fun z ↦ d[A ; μ[|Z ← z] # B ; μ[|Z ← z]]]\n      = (ν.map Z')[fun z ↦ d[A₁ ; ν[|Z' ← z] # B₂ ; ν[|Z' ← z]]] := by\n        rw [hZZ'.map_eq]\n        refine' integral_congr_ae $ eventually_of_forall fun z ↦ _\n        have hAA₁ : IdentDistrib A₁ A (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₁.comp $ measurable_fst.fst.prod_mk measurable_snd).cond\n            (measurableSet_singleton z) hZ' hZ\n        have hBB₂ : IdentDistrib B₂ B (ν[|Z' ← z]) (μ[|Z ← z]) :=\n          (hABZ₂.comp $ measurable_fst.snd.prod_mk measurable_snd).cond\n            (measurableSet_discrete _) hZ' hZ\n        dsimp (config := {zeta := false}) [rdist]\n        rw [← hAA₁.entropy_eq, ← hBB₂.entropy_eq, hAA₁.map_eq, hBB₂.map_eq]\n    _ = (ν.map Z')[fun z ↦\n          H[A₁ - B₂ ; ν[|Z' ← z]] - H[A₁ ; ν[|Z' ← z]]/2 - H[B₂ ; ν[|Z' ← z]]/2] :=\n        integral_congr_ae $ hABZ.mono fun z hz ↦\n          (hz.comp measurable_fst measurable_snd).rdist_eq hA₁ hB₂\n    _ = H[A₁ - B₂ | Z' ; ν] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 := by\n        rw [integral_sub, integral_sub, integral_div, integral_div]\n        rfl\n        all_goals exact integrable_of_fintype _ _\n    _ ≤ 2 * I[A : B ; μ] + H[Z ; μ] - H[A₁ | Z' ; ν] / 2 - H[B₂ | Z' ; ν] / 2 :=\n        sub_le_sub_right (sub_le_sub_right ‹_› _) _\n    _ = _ := by rw [hA₁Z, hB₂Z]; ring\n\nend BalogSzemerediGowers\n\nvariable (μ μ') in\n/-- Suppose that $(X, Z)$ and $(Y, W)$ are random variables, where $X, Y$ take values in an abelian\ngroup. Then $$d[X | Z ; Y | W] \\leq d[X ; Y] + \\tfrac{1}{2} I[X : Z] + \\tfrac{1}{2} I[Y : W]$$ -/\nlemma condRuzsaDist_le {X : Ω → G} {Z : Ω → S} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ'] [Nonempty S]\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange W] :\n      d[X | Z ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[X : Z ; μ]/2 + I[Y : W ; μ']/2 := by\n  have hXZ : Measurable (⟨X, Z⟩ : Ω → G × S):= Measurable.prod_mk hX hZ\n  have hYW : Measurable (⟨Y, W⟩ : Ω' → G × T):= Measurable.prod_mk hY hW\n  obtain ⟨ν, XZ', YW', _, hXZ', hYW', hind, hIdXZ, hIdYW, _, _⟩ :=\n    independent_copies_finiteRange hXZ hYW μ μ'\n  let X' := Prod.fst ∘ XZ'\n  let Z' := Prod.snd ∘ XZ'\n  let Y' := Prod.fst ∘ YW'\n  let W' := Prod.snd ∘ YW'\n  have hX' : Measurable X' := hXZ'.fst\n  have hZ' : Measurable Z' := hXZ'.snd\n  have hY' : Measurable Y' := hYW'.fst\n  have hW' : Measurable W' := hYW'.snd\n  have hind' : IndepFun X' Y' ν := hind.comp measurable_fst measurable_fst\n  rw [show XZ' = ⟨X', Z'⟩ by rfl] at hIdXZ hind\n  rw [show YW' = ⟨Y', W'⟩ by rfl] at hIdYW hind\n  rw [← condRuzsaDist_of_copy hX' hZ' hY' hW' hX hZ hY hW hIdXZ hIdYW,\n    condRuzsaDist_of_indep hX' hZ' hY' hW' _ hind]\n  have hIdX : IdentDistrib X X' μ ν := hIdXZ.symm.comp measurable_fst\n  have hIdY : IdentDistrib Y Y' μ' ν := hIdYW.symm.comp measurable_fst\n  rw [hIdX.rdist_eq hIdY, hIdXZ.symm.mutualInfo_eq, hIdYW.symm.mutualInfo_eq,\n    hind'.rdist_eq hX' hY', mutualInfo_eq_entropy_sub_condEntropy hX' hZ',\n    mutualInfo_eq_entropy_sub_condEntropy hY' hW']\n  have h := condEntropy_le_entropy ν (X := X' - Y') (hX'.sub hY') (hZ'.prod_mk hW')\n  linarith [h, entropy_nonneg Z' ν, entropy_nonneg W' ν]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le' {X : Ω → G} {Y : Ω' → G} {W : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] :\n    d[X ; μ # Y|W ; μ'] ≤ d[X ; μ # Y ; μ'] + I[Y : W ; μ']/2 := by\n  rw [← condRuzsaDist_of_const hX _ _ (0 : Fin 1)]\n  refine' (condRuzsaDist_le μ μ' hX measurable_const hY hW).trans _\n  simp [mutualInfo_const hX (0 : Fin 1)]\n\nvariable (μ μ') in\nlemma condRuzsaDist_le'_prod {X : Ω → G} {Y : Ω' → G} {W Z : Ω' → T}\n    [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    (hX : Measurable X) (hY : Measurable Y) (hW : Measurable W) (hZ : Measurable Z)\n    [FiniteRange X] [FiniteRange Y] [FiniteRange W] [FiniteRange Z]:\n    d[X ; μ # Y|⟨W, Z⟩ ; μ'] ≤ d[X ; μ # Y|Z ; μ'] + I[Y : W | Z ; μ']/2 := by\n  rw [condRuzsaDist'_prod_eq_sum _ _ hY hW hZ, condRuzsaDist'_eq_sum hY hZ,\n    condMutualInfo_eq_sum hZ, Finset.sum_div, ← Finset.sum_add_distrib]\n  gcongr with z\n  rw [mul_div_assoc, ← mul_add]\n  rcases eq_or_ne (μ' (Z ⁻¹' {z})) 0 with hz | hz\n  · simp [hz]\n  · have : IsProbabilityMeasure (μ'[|Z ⁻¹' {z}]) := cond_isProbabilityMeasure μ' hz\n    gcongr\n    exact condRuzsaDist_le' _ _ hX hY hW\n\nvariable (μ) in\nlemma comparison_of_ruzsa_distances [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 ∧\n    (ElementaryAddCommGroup G 2 →\n      H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2) := by\n  obtain ⟨Ω'', mΩ'', μ'', X', Y', Z', hμ, hi, hX', hY', hZ', h2X', h2Y', h2Z', _, _,  _⟩ :=\n    independent_copies3_nondep_finiteRange hX hY hZ μ μ' μ'\n  have hY'Z' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have h2 : IdentDistrib (Y' + Z') (Y + Z) μ'' μ' := h2Y'.add h2Z' hY'Z' h\n  have hm : ∀ (i : Fin 3), Measurable (![X', Y', Z'] i) :=\n    fun i ↦ by fin_cases i <;> (dsimp; assumption)\n  have hXY' : IndepFun X' Y' μ'' := hi.indepFun (show (0 : Fin 3) ≠ 1 by decide)\n  have hYZ' : IndepFun Y' Z' μ'' := hi.indepFun (show (1 : Fin 3) ≠ 2 by decide)\n  have hXYZ' : IndepFun X' (Y' + Z') μ'' := by\n    symm\n    exact hi.indepFun_add_left hm 1 2 0 (by decide) (by decide)\n  rw [← h2X'.rdist_eq h2Y', ← h2X'.rdist_eq h2, ← h2Y'.rdist_eq h2Z',\n    ← h2.entropy_eq, ← h2Y'.entropy_eq, ← h2Z'.entropy_eq]\n  rw [hXY'.rdist_eq hX' hY', hYZ'.rdist_eq hY' hZ', hXYZ'.rdist_eq hX' (hY'.add hZ')]\n  constructor\n  · linarith [kaimanovich_vershik' hi hX' hY' hZ']\n  · intro hG\n    rw [ElementaryAddCommGroup.sub_eq_add Y' Z']\n    ring\n\nvariable (μ) in\n/-- Let $X, Y, Z$ be random variables taking values in some abelian group, and with $Y, Z$\nindependent. Then we have\n$$d[X ; Y + Z] -d[X ; Y] \\leq \\tfrac{1}{2} (H[Y+ Z] - H[Y])$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Z] - \\tfrac{1}{4} H[Y]$$\nand\n$$d[X ; Y|Y+ Z] - d[X ; Y] \\leq \\tfrac{1}{2} \\bigl(H[Y+ Z] - H[Z]\\bigr)$$\n$$= \\tfrac{1}{2} d[Y ; Z] + \\tfrac{1}{4} H[Y] - \\tfrac{1}{4} H[Z]$$\n-/\nlemma condRuzsaDist_diff_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y + Z; μ'] - H[Y; μ']) / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).1\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma entropy_sub_entropy_eq_condRuzsaDist_add [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    H[Y + Z; μ'] - H[Y; μ'] = d[Y; μ' # Z; μ'] + H[Z; μ'] / 2 - H[Y; μ'] / 2 :=\n  (comparison_of_ruzsa_distances μ hX hY hZ h).2 ‹_›\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y + Z; μ'] - d[X ; μ # Y; μ'] ≤\n    d[Y; μ' # Z; μ'] / 2 + H[Z; μ'] / 4 - H[Y; μ'] / 4 := by\n  linarith [condRuzsaDist_diff_le μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\nvariable (μ) in\nlemma condRuzsaDist_diff_le'' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤ (H[Y+ Z ; μ'] - H[Z ; μ'])/2 := by\n  rw [← mutualInfo_add_right hY hZ h]\n  linarith [condRuzsaDist_le' μ μ' hX hY (hY.add' hZ)]\n\nvariable (μ) [ElementaryAddCommGroup G 2] in\nlemma condRuzsaDist_diff_le''' [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y : Ω' → G} {Z : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (h : IndepFun Y Z μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] :\n    d[X ; μ # Y|Y+ Z ; μ'] - d[X ; μ # Y ; μ'] ≤\n    d[Y ; μ' # Z ; μ']/2 + H[Y ; μ']/4 - H[Z ; μ']/4 := by\n  linarith [condRuzsaDist_diff_le'' μ hX hY hZ h, entropy_sub_entropy_eq_condRuzsaDist_add μ hX hY hZ h]\n\n","proof":":= by\n  have hadd : IndepFun (Y + Z) Z' μ' :=\n    (h.indepFun_add_left (Fin.cases hY <| Fin.cases hZ <| Fin.cases hZ' Fin.rec0) 0 1 2\n      (show 0 ≠ 2 by decide) (show 1 ≠ 2 by decide))\n  have h1 := condRuzsaDist_diff_le'' μ hX (show Measurable (Y + Z) by measurability) hZ' hadd\n  have h2 := condRuzsaDist_diff_le μ hX hY hZ (h.indepFun (show 0 ≠ 1 by decide))\n  linarith [h1, h2]","declId":"PFR.ForMathlib.Entropy.RuzsaDist.1377_0.4TdCzOoAsczoWMh","decl":"variable (μ) in\nlemma condRuzsaDist_diff_ofsum_le [IsProbabilityMeasure μ] [IsProbabilityMeasure μ']\n    {X : Ω → G} {Y Z Z' : Ω' → G}\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (hZ' : Measurable Z')\n    (h : iIndepFun (fun _ ↦ hG) ![Y, Z, Z'] μ')\n    [FiniteRange X] [FiniteRange Z] [FiniteRange Y] [FiniteRange Z'] :\n    d[X ; μ # Y + Z | Y + Z + Z'; μ'] - d[X ; μ # Y; μ'] ≤\n    (H[Y + Z + Z'; μ'] + H[Y + Z; μ'] - H[Y ; μ'] - H[Z' ; μ'])/2 "}
