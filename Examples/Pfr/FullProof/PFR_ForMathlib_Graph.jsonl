{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\n","proof":":= {(x, f x) | x : G}","declId":"PFR.ForMathlib.Graph.11_0.4Bx2cQMgw9uP8UA","decl":"def graph (f : G → G') : Set (G×G') "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\n","proof":":= rfl","declId":"PFR.ForMathlib.Graph.13_0.4Bx2cQMgw9uP8UA","decl":"lemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\n","proof":":= by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩","declId":"PFR.ForMathlib.Graph.15_0.4Bx2cQMgw9uP8UA","decl":"lemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n","proof":":= by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]","declId":"PFR.ForMathlib.Graph.20_0.4Bx2cQMgw9uP8UA","decl":"@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 := by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]\n\n","proof":":= fun x hx y hy h ↦\n  Prod.ext h <| ((mem_graph x).mp hx).symm.trans <| (congr_arg f h).trans <| (mem_graph y).mp hy","declId":"PFR.ForMathlib.Graph.27_0.4Bx2cQMgw9uP8UA","decl":"lemma fst_injOn_graph (f : G → G') : (graph f).InjOn Prod.fst "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 := by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]\n\nlemma fst_injOn_graph (f : G → G') : (graph f).InjOn Prod.fst := fun x hx y hy h ↦\n  Prod.ext h <| ((mem_graph x).mp hx).symm.trans <| (congr_arg f h).trans <| (mem_graph y).mp hy\n\n","proof":":= by\n  ext x; simp","declId":"PFR.ForMathlib.Graph.30_0.4Bx2cQMgw9uP8UA","decl":"@[simp]\nlemma image_fst_graph {f : G → G'} : Prod.fst '' (graph f) = Set.univ "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 := by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]\n\nlemma fst_injOn_graph (f : G → G') : (graph f).InjOn Prod.fst := fun x hx y hy h ↦\n  Prod.ext h <| ((mem_graph x).mp hx).symm.trans <| (congr_arg f h).trans <| (mem_graph y).mp hy\n\n@[simp]\nlemma image_fst_graph {f : G → G'} : Prod.fst '' (graph f) = Set.univ := by\n  ext x; simp\n\n","proof":":= by\n  ext x; simp","declId":"PFR.ForMathlib.Graph.34_0.4Bx2cQMgw9uP8UA","decl":"@[simp]\nlemma image_snd_graph {f : G → G'} : Prod.snd '' (graph f) = f '' Set.univ "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 := by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]\n\nlemma fst_injOn_graph (f : G → G') : (graph f).InjOn Prod.fst := fun x hx y hy h ↦\n  Prod.ext h <| ((mem_graph x).mp hx).symm.trans <| (congr_arg f h).trans <| (mem_graph y).mp hy\n\n@[simp]\nlemma image_fst_graph {f : G → G'} : Prod.fst '' (graph f) = Set.univ := by\n  ext x; simp\n\n@[simp]\nlemma image_snd_graph {f : G → G'} : Prod.snd '' (graph f) = f '' Set.univ := by\n  ext x; simp\n\n","proof":":= by\n  ext x;\n  simp only [mem_graph, Function.comp_apply, Set.mem_image, Prod.exists, exists_eq_left']\n  constructor\n  · intro h\n    use x.1\n    rw [h]\n  · rintro ⟨x, rfl⟩; rfl","declId":"PFR.ForMathlib.Graph.38_0.4Bx2cQMgw9uP8UA","decl":"lemma graph_comp {A B C : Type*} {f : A → B} (g : B → C) :\n    graph (g ∘ f) = (fun p ↦ (p.1, g p.2)) '' graph f "}
{"srcUpToDecl":"import Mathlib.Data.Set.Pointwise.Basic\nimport Mathlib.SetTheory.Cardinal.Finite\n\n\nsection Graph\nnamespace Set\n\nvariable {G G' : Type*}\n\n-- TODO: maybe `Function.graph` for dot notation?\ndef graph (f : G → G') : Set (G×G') := {(x, f x) | x : G}\n\nlemma graph_def (f : G → G') : graph f = {(x, f x) | x : G} := rfl\n\nlemma card_graph (f : G → G') : Nat.card (graph f) = Nat.card G := by\n  apply Nat.card_congr ⟨fun p => p.1.1, fun x => ⟨⟨x, f x⟩, x, rfl⟩,\n      by rintro ⟨p, h, hh⟩; simp [← hh],\n      by intro x; simp⟩\n\n@[simp]\nlemma mem_graph {f : G → G'} (x : G × G') : x ∈ graph f ↔ f x.1 = x.2 := by\n  constructor\n  · rintro ⟨_, rfl⟩; rfl\n  · refine fun h ↦ ⟨x.1, ?_⟩\n    rw [h]\n\nlemma fst_injOn_graph (f : G → G') : (graph f).InjOn Prod.fst := fun x hx y hy h ↦\n  Prod.ext h <| ((mem_graph x).mp hx).symm.trans <| (congr_arg f h).trans <| (mem_graph y).mp hy\n\n@[simp]\nlemma image_fst_graph {f : G → G'} : Prod.fst '' (graph f) = Set.univ := by\n  ext x; simp\n\n@[simp]\nlemma image_snd_graph {f : G → G'} : Prod.snd '' (graph f) = f '' Set.univ := by\n  ext x; simp\n\nlemma graph_comp {A B C : Type*} {f : A → B} (g : B → C) :\n    graph (g ∘ f) = (fun p ↦ (p.1, g p.2)) '' graph f := by\n  ext x;\n  simp only [mem_graph, Function.comp_apply, Set.mem_image, Prod.exists, exists_eq_left']\n  constructor\n  · intro h\n    use x.1\n    rw [h]\n  · rintro ⟨x, rfl⟩; rfl\n\n","proof":":= by\n  ext x\n  simp only [Set.image_add_left, Set.mem_preimage, mem_graph,\n    Prod.fst_add, Prod.snd_add, Set.mem_setOf_eq, Prod.fst_neg, Prod.snd_neg, AddMonoidHom.map_add,\n    AddMonoidHom.map_neg]\n  constructor\n  · intro h\n    use x.1\n    rw [add_comm, sub_eq_add_neg, add_assoc, h]\n    convert show (x.1, x.2) = x from rfl\n    abel\n  · rintro ⟨g, rfl⟩;\n    abel_nf","declId":"PFR.ForMathlib.Graph.48_0.4Bx2cQMgw9uP8UA","decl":"lemma graph_add [AddGroup G] [AddCommGroup G'] {f : G →+ G'} {c : G × G'} :\n    (c+·) '' graph f = {(g, f g + (c.2 - f c.1)) | g : G} "}
