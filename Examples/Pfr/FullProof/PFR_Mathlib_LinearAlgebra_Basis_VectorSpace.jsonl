{"srcUpToDecl":"import Mathlib.LinearAlgebra.Basis.VectorSpace\n\nnamespace Submodule\nvariable {B F R : Type*} [DivisionRing R] [AddCommGroup B] [AddCommGroup F]\n  [Module R B] [Module R F]\n\nopen LinearMap\n\n","proof":":= by\n  let π₁ := LinearMap.fst R B F\n  let f₁ := π₁.submoduleMap E\n  have f₁_surj := range_eq_top.mpr (π₁.submoduleMap_surjective E)\n\n  obtain ⟨φ', hφ'⟩ := f₁.exists_rightInverse_of_surjective f₁_surj\n  obtain ⟨φ, rfl⟩ := φ'.exists_extend\n  let φ' := φ ∘ₗ Submodule.subtype (map π₁ E)\n\n  let p₂ := (LinearMap.snd R B F).domRestrict E\n  let f₂'' := LinearMap.id - φ'.comp f₁\n  let f₂' := p₂.comp f₂''\n  let f₂ := f₂'.rangeRestrict\n\n  have h_compl : IsCompl (ker f₁) (ker f₂) := by\n    refine IsCompl.of_eq ?_ ?_\n    · by_contra hc\n      obtain ⟨x, h_ker, h_nezero⟩ := exists_mem_ne_zero_of_ne_bot hc\n      rw [mem_inf, mem_ker, mem_ker] at h_ker\n      have h_zero₁ : x.val.1 = 0 := Subtype.ext_iff.mp h_ker.left\n      have h_zero₂ : x.val.2 = 0 := calc\n        x.val.2 = (f₂'' x).val.2 := by\n          show _ = (x - φ' (f₁ x)).val.2\n          rw [mem_ker.mp h_ker.left, φ'.map_zero, sub_zero]\n        _ = 0 := (mk_eq_zero _ _).mp h_ker.right\n      exact h_nezero (Subtype.ext (Prod.ext h_zero₁ h_zero₂))\n    · apply eq_top_iff'.mpr\n      intro x\n      apply mem_sup'.mpr\n      have : φ x.val.1 = φ' (f₁ x) := rfl\n      refine ⟨⟨f₂'' x, ?_⟩, ⟨φ x.val.1, ?_⟩, sub_add_cancel x (φ x.val.1)⟩\n      · show f₁ x - (f₁.comp φ') (f₁ x) = 0\n        rw [hφ']; exact sub_self (f₁ x)\n      · rewrite [ker_rangeRestrict]\n        show p₂ (φ x.val.1 - φ' (f₁ (φ x.val.1))) = 0\n        rw [this, ← f₁.comp_apply φ', hφ', LinearMap.id_apply, sub_self, p₂.map_zero]\n\n  let f := equivProdOfSurjectiveOfIsCompl f₁ f₂ f₁_surj f₂'.range_rangeRestrict h_compl\n  refine ⟨E.map π₁, range f₂', f, p₂.comp φ, fun _ ↦ ⟨rfl, rfl⟩, fun x₁ x₂ ↦ ?_⟩\n  let x : E := f.symm (x₁, x₂)\n  have hf : f₁ x = x₁ ∧ f₂ x = x₂ := (Prod.mk.injEq _ _ _ _).mp (f.apply_symm_apply (x₁, x₂))\n  have : (f₂ x).val = x.val.2 - p₂ (φ x.val.1) := rfl\n  have : x₂.val + p₂ (φ x.val.1) = x.val.2 :=\n    eq_sub_iff_add_eq.mp (Eq.trans (Subtype.ext_iff.mp hf.right).symm this)\n  show x.val = _\n  rw [← hf.left]\n  exact (Prod.mk.injEq _ _ _ _).mpr ⟨rfl (a := x.val.1), this.symm⟩","declId":"PFR.Mathlib.LinearAlgebra.Basis.VectorSpace.9_0.tC6wVsiof3Pb4qU","decl":"/-- Given a submodule $E$ of $B \\times F$, there is an equivalence $f : E \\to B' \\times F'$\n  given by the projections $E \\to B$ and $E \\to F$ \"modulo\" $φ : B \\to F$. -/\ntheorem exists_equiv_fst_sndModFst (E : Submodule R (B × F)) :\n    ∃ (B' : Submodule R B) (F' : Submodule R F) (f : E ≃ₗ[R] B' × F') (φ : B →ₗ[R] F),\n    (∀ x : E, (f x).1.val = x.val.1 ∧ (f x).2.val = x.val.2 - φ x.val.1) ∧\n    (∀ (x₁ : B') (x₂ : F'), (f.symm (x₁, x₂)).val = (x₁.val, x₂.val + φ x₁.val)) "}
