{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\n","proof":":= by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.18_0.nLcAs7vqkgHUZBd","decl":"lemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\n","proof":":= by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.28_0.nLcAs7vqkgHUZBd","decl":"lemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\n","proof":":= by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.56_0.nLcAs7vqkgHUZBd","decl":"instance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n","proof":":= fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.74_0.nLcAs7vqkgHUZBd","decl":"/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\n","proof":":= rfl","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.81_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\n","proof":":= by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.84_0.nLcAs7vqkgHUZBd","decl":"instance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\n","proof":":= by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.90_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\n","proof":":= by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.98_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\n","proof":":= by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.116_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.123_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\n","proof":":= condKernel_compProd_ae_eq _ _ _","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.142_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\n","proof":":= by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.146_0.nLcAs7vqkgHUZBd","decl":"lemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\n","proof":":= by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.177_0.nLcAs7vqkgHUZBd","decl":"lemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.184_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\n","proof":":= by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.247_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\n","proof":":= by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.256_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.264_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\n","proof":":= by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.272_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\n","proof":":= by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.284_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.295_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\n","proof":":= by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.304_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.314_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.323_0.nLcAs7vqkgHUZBd","decl":"lemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  ext A hA\n  rw [kernel.comap_apply']\n  have h_swap : (fun a ↦ (X a, Z a)) ⁻¹' {Prod.swap x} = (fun a ↦ (Z a, X a)) ⁻¹' {x} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.swap_prod_mk, Prod.mk.inj_iff, Prod.mk.inj_iff, and_comm]\n  rw [condDistrib_apply' hY (hX.prod_mk hZ) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _), ← h_swap] at hx\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  rw [h_swap]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.378_0.nLcAs7vqkgHUZBd","decl":"lemma swap_condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.comap (condDistrib Y (fun a ↦ (X a, Z a)) μ) Prod.swap measurable_swap\n      =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))] condDistrib Y (fun ω ↦ (Z ω, X ω)) μ "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]\n\nlemma swap_condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.comap (condDistrib Y (fun a ↦ (X a, Z a)) μ) Prod.swap measurable_swap\n      =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))] condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  ext A hA\n  rw [kernel.comap_apply']\n  have h_swap : (fun a ↦ (X a, Z a)) ⁻¹' {Prod.swap x} = (fun a ↦ (Z a, X a)) ⁻¹' {x} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.swap_prod_mk, Prod.mk.inj_iff, Prod.mk.inj_iff, and_comm]\n  rw [condDistrib_apply' hY (hX.prod_mk hZ) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _), ← h_swap] at hx\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  rw [h_swap]\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  have : (fun a ↦ ((), X a)) ⁻¹' {x} = X ⁻¹' {x.2} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.mk.inj_iff]\n    simp\n  rw [Measure.map_apply (measurable_const.prod_mk hX) (measurableSet_singleton _), this] at hx\n  ext s hs\n  rw [kernel.condKernel_apply' _ _ _ hs]\n  swap\n  · rw [kernel.const_apply,\n      Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _))]\n    exact hx\n  simp_rw [kernel.const_apply,\n    Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _)),\n    Measure.map_apply (hX.prod_mk hY) ((measurableSet_singleton _).prod hs)]\n  rw [kernel.prodMkLeft_apply', condDistrib_apply' hY hX _ _ hx hs]\n  rfl","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.396_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_const_unit (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.condKernel (kernel.const Unit (μ.map (fun ω ↦ (X ω, Y ω))))\n      =ᵐ[μ.map (fun ω ↦ ((), X ω))] kernel.prodMkLeft Unit (condDistrib Y X μ) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]\n\nlemma swap_condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.comap (condDistrib Y (fun a ↦ (X a, Z a)) μ) Prod.swap measurable_swap\n      =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))] condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  ext A hA\n  rw [kernel.comap_apply']\n  have h_swap : (fun a ↦ (X a, Z a)) ⁻¹' {Prod.swap x} = (fun a ↦ (Z a, X a)) ⁻¹' {x} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.swap_prod_mk, Prod.mk.inj_iff, Prod.mk.inj_iff, and_comm]\n  rw [condDistrib_apply' hY (hX.prod_mk hZ) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _), ← h_swap] at hx\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  rw [h_swap]\n\nlemma condDistrib_const_unit (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.condKernel (kernel.const Unit (μ.map (fun ω ↦ (X ω, Y ω))))\n      =ᵐ[μ.map (fun ω ↦ ((), X ω))] kernel.prodMkLeft Unit (condDistrib Y X μ) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  have : (fun a ↦ ((), X a)) ⁻¹' {x} = X ⁻¹' {x.2} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.mk.inj_iff]\n    simp\n  rw [Measure.map_apply (measurable_const.prod_mk hX) (measurableSet_singleton _), this] at hx\n  ext s hs\n  rw [kernel.condKernel_apply' _ _ _ hs]\n  swap\n  · rw [kernel.const_apply,\n      Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _))]\n    exact hx\n  simp_rw [kernel.const_apply,\n    Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _)),\n    Measure.map_apply (hX.prod_mk hY) ((measurableSet_singleton _).prod hs)]\n  rw [kernel.prodMkLeft_apply', condDistrib_apply' hY hX _ _ hx hs]\n  rfl\n\n","proof":":= by\n  ext x s hs\n  rw [condDistrib_apply' hX measurable_const _ _ _ hs]\n  · simp only [Set.mem_singleton_iff, Set.preimage_const_of_mem, measure_univ, inv_one,\n      Set.univ_inter, one_mul]\n    rw [kernel.const_apply, Measure.map_apply hX hs]\n  · simp","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.420_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_unit_right (hX : Measurable X) (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    condDistrib X (fun _ ↦ ()) μ = kernel.const Unit (μ.map X) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]\n\nlemma swap_condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.comap (condDistrib Y (fun a ↦ (X a, Z a)) μ) Prod.swap measurable_swap\n      =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))] condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  ext A hA\n  rw [kernel.comap_apply']\n  have h_swap : (fun a ↦ (X a, Z a)) ⁻¹' {Prod.swap x} = (fun a ↦ (Z a, X a)) ⁻¹' {x} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.swap_prod_mk, Prod.mk.inj_iff, Prod.mk.inj_iff, and_comm]\n  rw [condDistrib_apply' hY (hX.prod_mk hZ) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _), ← h_swap] at hx\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  rw [h_swap]\n\nlemma condDistrib_const_unit (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.condKernel (kernel.const Unit (μ.map (fun ω ↦ (X ω, Y ω))))\n      =ᵐ[μ.map (fun ω ↦ ((), X ω))] kernel.prodMkLeft Unit (condDistrib Y X μ) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  have : (fun a ↦ ((), X a)) ⁻¹' {x} = X ⁻¹' {x.2} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.mk.inj_iff]\n    simp\n  rw [Measure.map_apply (measurable_const.prod_mk hX) (measurableSet_singleton _), this] at hx\n  ext s hs\n  rw [kernel.condKernel_apply' _ _ _ hs]\n  swap\n  · rw [kernel.const_apply,\n      Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _))]\n    exact hx\n  simp_rw [kernel.const_apply,\n    Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _)),\n    Measure.map_apply (hX.prod_mk hY) ((measurableSet_singleton _).prod hs)]\n  rw [kernel.prodMkLeft_apply', condDistrib_apply' hY hX _ _ hx hs]\n  rfl\n\nlemma condDistrib_unit_right (hX : Measurable X) (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    condDistrib X (fun _ ↦ ()) μ = kernel.const Unit (μ.map X) := by\n  ext x s hs\n  rw [condDistrib_apply' hX measurable_const _ _ _ hs]\n  · simp only [Set.mem_singleton_iff, Set.preimage_const_of_mem, measure_univ, inv_one,\n      Set.univ_inter, one_mul]\n    rw [kernel.const_apply, Measure.map_apply hX hs]\n  · simp\n\n","proof":":= by\n  ext A hA\n  rw [Measure.map_apply (hZ.prod_mk hX) hA, Measure.compProd_apply hA, lintegral_eq_sum_countable]\n  have : ∑' x : U, μ.map Z {x} * condDistrib X Z μ x (Prod.mk x ⁻¹' A)\n      = ∑' x : U, μ (Z ⁻¹' {x} ∩ (fun ω ↦ (x, X ω)) ⁻¹' A) := by\n    congr 1 with x\n    rw [Measure.map_apply hZ (measurableSet_singleton _)]\n    by_cases hx : μ (Z ⁻¹' {x}) = 0\n    · simp only [hx, zero_mul, Set.mem_setOf_eq, Set.preimage_setOf_eq]\n      exact (measure_mono_null (Set.inter_subset_left _ _) hx).symm\n    rw [condDistrib_apply' hX hZ _ _ hx]\n    swap; · exact (measurable_prod_mk_left hA)\n    rw [← mul_assoc, ENNReal.mul_inv_cancel hx (measure_ne_top _ _), one_mul]\n    congr\n  rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' A = ⋃ x, Z ⁻¹' {x} ∩ ((fun a ↦ (x, X a)) ⁻¹' A) := by\n    ext ω\n    simp\n  rw [this, measure_iUnion]\n  · intro i j hij\n    rw [Function.onFun]\n    refine Disjoint.mono (Set.inter_subset_left _ _) (Set.inter_subset_left _ _) ?_\n    rw [Set.disjoint_iff]\n    intro z\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_empty_iff_false,\n      and_imp]\n    exact fun hi hj ↦ hij (hi.symm.trans hj)\n  intro u\n  exact (hZ (measurableSet_singleton _)).inter (measurable_const.prod_mk hX hA)","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.429_0.nLcAs7vqkgHUZBd","decl":"lemma map_compProd_condDistrib (hX : Measurable X) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    μ.map Z ⊗ₘ condDistrib X Z μ = μ.map (fun ω ↦ (Z ω, X ω)) "}
{"srcUpToDecl":"import Mathlib.Probability.Kernel.CondDistrib\nimport PFR.Mathlib.MeasureTheory.Integral.Lebesgue\nimport PFR.Mathlib.MeasureTheory.Measure.NullMeasurable\nimport PFR.Mathlib.Probability.ConditionalProbability\nimport PFR.Mathlib.Probability.Kernel.MeasureCompProd\n\n/-!\n# Disintegration of kernels in finite spaces\n\nWe can write `κ : kernel S (T × U)` as a composition-product `(fst κ) ⊗ₖ (condKernel κ)` where\n`fst κ : kernel S T` and `condKernel : kernel (S × T) U` is defined in this file.\n\n-/\n\nopen Real MeasureTheory Measure ProbabilityTheory\nopen scoped ENNReal NNReal Topology ProbabilityTheory BigOperators\n\nlemma _root_.MeasureTheory.lintegral_piecewise {α : Type*} {mα : MeasurableSpace α} {μ : Measure α}\n    {s : Set α} (hs : MeasurableSet s) (f g : α → ℝ≥0∞) [∀ j, Decidable (j ∈ s)] :\n    ∫⁻ a, s.piecewise f g a ∂μ = ∫⁻ a in s, f a ∂μ + ∫⁻ a in sᶜ, g a ∂μ := by\n  rw [← lintegral_add_compl _ hs]\n  congr 1\n  · refine set_lintegral_congr_fun hs ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_mem _ _ _ ha)\n  · refine set_lintegral_congr_fun hs.compl ?_\n    exact ae_of_all μ (fun a ha ↦ Set.piecewise_eq_of_not_mem _ _ _ ha)\n\nlemma MeasureTheory.Measure.condKernel_apply {α β : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} [MeasurableSingletonClass α] [StandardBorelSpace β] [Nonempty β]\n    (μ : Measure (α × β)) [IsFiniteMeasure μ] {x : α} (hx : μ.fst {x} ≠ 0)\n    {s : Set β} (hs : MeasurableSet s) :\n    μ.condKernel x s = (μ.fst {x})⁻¹ * μ ({x} ×ˢ s) := by\n  nth_rewrite 3 [measure_eq_compProd μ]\n  rw [Measure.compProd_apply]\n  swap; · refine measurableSet_prod.mpr (Or.inl ⟨measurableSet_singleton x, hs⟩)\n  classical\n  have : ∀ a, μ.condKernel a (Prod.mk a ⁻¹' {x} ×ˢ s)\n      = ({x} : Set α).indicator (fun a ↦ μ.condKernel a s) a := by\n    intro a\n    by_cases hax : a = x\n    · simp only [hax, Set.singleton_prod, Set.mem_singleton_iff, Set.indicator_of_mem]\n      congr\n      ext y : 1\n      simp\n    · simp only [Set.singleton_prod, Set.mem_singleton_iff, hax, not_false_eq_true,\n        Set.indicator_of_not_mem]\n      have : Prod.mk a ⁻¹' (Prod.mk x '' s) = ∅ := by\n        ext y\n        simp [Ne.symm hax]\n      simp only [this, OuterMeasure.empty']\n  simp_rw [this]\n  rw [MeasureTheory.lintegral_indicator _ (measurableSet_singleton x)]\n  simp only [restrict_singleton, lintegral_smul_measure, lintegral_dirac]\n  rw [← mul_assoc, ENNReal.inv_mul_cancel hx (measure_ne_top μ.fst _), one_mul]\n\ninstance instStandardBorelSpace_discreteMeasurableSpace {α : Type*} [MeasurableSpace α]\n    [DiscreteMeasurableSpace α] [Countable α] :\n    StandardBorelSpace α := by\n  let bot : TopologicalSpace α := ⊥\n  have : DiscreteTopology α := ⟨rfl⟩\n  infer_instance\n\nnamespace ProbabilityTheory\n\nvariable {Ω S T U : Type*} [mΩ : MeasurableSpace Ω]\n  [Countable S] [Nonempty S] [MeasurableSpace S] [DiscreteMeasurableSpace S]\n  [Countable T] [Nonempty T] [MeasurableSpace T] [DiscreteMeasurableSpace T]\n  [Countable U] [Nonempty U] [MeasurableSpace U] [DiscreteMeasurableSpace U]\n\nnamespace kernel\n\nsection condKernel\n\n/-- Kernel such that `κ : kernel T (S × U)` is equal to `(fst κ) ⊗ₖ (condKernel κ)`. -/\nnoncomputable\ndef condKernel (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    kernel (T × S) U where\n  val := fun ts ↦ (κ ts.1).condKernel ts.2\n  property := measurable_of_countable _\n\nlemma condKernel_apply (κ : kernel T (S × U)) [IsFiniteKernel κ] (x : T × S) :\n    condKernel κ x = (κ x.1).condKernel x.2 := rfl\n\ninstance (κ : kernel T (S × U)) [IsFiniteKernel κ] : IsMarkovKernel (condKernel κ) := by\n  constructor\n  intro a\n  rw [condKernel_apply]\n  infer_instance\n\nlemma condKernel_apply' (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (x : T × S) (hx : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel κ x s\n      = (κ x.1 (Prod.fst ⁻¹' {x.2}))⁻¹ * (κ x.1) ({x.2} ×ˢ s) := by\n  rw [condKernel_apply, Measure.condKernel_apply _ _ hs,\n    Measure.fst_apply (measurableSet_singleton _)]\n  rwa [Measure.fst_apply (measurableSet_singleton _)]\n\nlemma condKernel_compProd_apply' (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) {s : Set U} (hs : MeasurableSet s) :\n    condKernel (κ ⊗ₖ η) x s = η x s := by\n  have hx' : (κ ⊗ₖ η) x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    rwa [compProd_preimage_fst _ _ (measurableSet_singleton _)]\n  rw [condKernel_apply' _ _ hx' hs, compProd_apply _ _ _ ((measurableSet_singleton _).prod hs),\n    kernel.compProd_apply, lintegral_eq_single _ x.2, lintegral_eq_single _ x.2]\n  . simp\n    rw [mul_comm, mul_assoc]\n    set a := (κ x.1) {x.2}\n    suffices a * a⁻¹ = 1 by simp [this]\n    refine ENNReal.mul_inv_cancel hx ?_\n    exact measure_ne_top (κ x.1) {x.2}\n  . intro b hb; simp [hb.symm]\n  . intro b hb; simp [hb]\n  · measurability\n\nlemma condKernel_compProd_apply (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η]\n    (x : T × S) (hx : κ x.1 {x.2} ≠ 0) :\n    condKernel (κ ⊗ₖ η) x = η x := by\n  ext s hs\n  convert condKernel_compProd_apply' κ η x hx hs\n\nlemma condKernel_compProd_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] (μ : Measure T) [IsFiniteMeasure μ]:\n    condKernel (κ ⊗ₖ η) =ᵐ[μ ⊗ₘ κ] η := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condKernel_compProd_apply]\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [Set.mem_singleton_iff, ne_eq, Finset.sum_eq_zero_iff, tsum_eq_zero_iff ENNReal.summable, mul_eq_zero,\n    forall_true_left, not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  classical\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod_right_eq_if] at hy\n  simp only [ne_eq, Set.mem_singleton_iff] at hy\n  by_cases hyx1 : y = x.1\n  · simp only [hyx1, ite_true] at hy\n    exact hy.2\n  · simp [hyx1] at hy\n\nlemma condKernel_prod_ae_eq (κ : kernel T S) [IsFiniteKernel κ]\n    (η : kernel T U) [IsMarkovKernel η] [IsFiniteMeasure μ] :\n    condKernel (κ ×ₖ η) =ᵐ[μ ⊗ₘ κ] prodMkRight S η := condKernel_compProd_ae_eq _ _ _\n\nlemma disintegration (κ : kernel T (S × U)) [IsFiniteKernel κ] :\n    κ = (kernel.fst κ) ⊗ₖ (condKernel κ) := by\n  ext x s hs\n  rw [compProd_apply _ _ _ hs, lintegral_fst]\n  swap; · exact measurable_kernel_prod_mk_left' hs x\n  rw [lintegral_eq_sum_countable, ENNReal.tsum_prod']\n  change κ x s = ∑' a : S, ∑' b : U, κ x {(a, b)} * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n  simp_rw [ENNReal.tsum_mul_right, ← measure_preimage_fst_singleton_eq_sum_countable (κ x)]\n  have : ∑' a : S, (κ x (Prod.fst ⁻¹' {a})) * condKernel κ (x, a) (Prod.mk a ⁻¹' s)\n      = ∑' a : S, κ x (Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s}) := by\n    congr with a\n    by_cases ha : κ x (Prod.fst ⁻¹' {a}) = 0\n    · simp only [ha, zero_mul]\n      exact (measure_mono_null (Set.inter_subset_left _ _) ha).symm\n    · rw [condKernel_apply' κ _ (by exact ha) (measurable_prod_mk_left hs), ← mul_assoc,\n      ENNReal.mul_inv_cancel ha (measure_ne_top _ _), one_mul]\n      congr\n  simp_rw [this]\n  have : ⋃ a, Prod.fst ⁻¹' {a} ∩ {su | (a, su.2) ∈ s} = s := by ext a; simp\n  conv_lhs => rw [← this]\n  rw [measure_iUnion]\n  · intro a a' haa'\n    rw [Function.onFun, Set.disjoint_iff]\n    intro su\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq,\n      Set.mem_empty_iff_false, and_imp]\n    intro h1 _ h1' _\n    exact haa' (h1.symm.trans h1')\n  · refine fun _ ↦ (measurable_fst (measurableSet_singleton _)).inter ?_\n    exact measurable_prod_mk_left.comp measurable_snd hs\n\nlemma ae_eq_condKernel_of_compProd_eq (κ : kernel T (S × U)) [IsFiniteKernel κ]\n    (η : kernel (T × S) U) [IsMarkovKernel η] [IsFiniteMeasure μ] (h : (fst κ) ⊗ₖ η = κ) :\n    η =ᵐ[μ ⊗ₘ fst κ] condKernel κ := by\n  have : condKernel κ = condKernel ((fst κ) ⊗ₖ η) := by congr; exact h.symm\n  rw [this]\n  exact (condKernel_compProd_ae_eq _ _ _).symm\n\nlemma condKernel_map_prod_mk_left {V : Type*} [Nonempty V] [MeasurableSpace V]\n    [DiscreteMeasurableSpace V] [Countable V]\n    (κ : kernel T (S × U)) [IsMarkovKernel κ] (μ : Measure T) [IsFiniteMeasure μ]\n    (f : (S × U) → V) :\n    condKernel (map κ (fun p ↦ (p.1, f p)) (measurable_of_countable _))\n      =ᵐ[μ ⊗ₘ fst κ] snd ((condKernel κ) ⊗ₖ (deterministic (fun x : (T × S) × U ↦ f (x.1.2, x.2))\n          (measurable_of_countable _))) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.compProd_apply (measurableSet_singleton _), lintegral_eq_sum_countable] at hx\n  simp only [ne_eq, tsum_eq_zero_iff ENNReal.summable, Finset.mem_univ, mul_eq_zero, forall_true_left,\n    not_forall] at hx\n  obtain ⟨y, hy⟩ := hx\n  push_neg at hy\n  rw [fst_apply' _ _ (measurable_prod_mk_left (measurableSet_singleton _))] at hy\n  simp only [ne_eq, Set.mem_preimage, Set.mem_singleton_iff] at hy\n  have hyx1 : y = x.1 := by\n    by_contra hy_ne\n    refine hy.2 ?_\n    rw [← Prod.eta x]\n    simp_rw [Prod.mk.inj_iff]\n    simp [hy_ne]\n  rw [hyx1] at hy\n  ext s hs\n  rw [snd_apply' _ _ hs, compProd_deterministic_apply]\n  swap; · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq]\n  have h_ne_zero : κ x.1 (Prod.fst ⁻¹' {x.2}) ≠ 0 := by\n    refine fun h_zero ↦ hy.2 ?_\n    refine measure_mono_null ?_ h_zero\n    intro p\n    simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n    exact fun h ↦ h.2\n  have h_preimage : (fun p ↦ (p.1, f p)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = Prod.fst ⁻¹' {x.2} := by\n    ext p; simp\n  rw [condKernel_apply' _ _ _ hs, condKernel_apply' _ _ h_ne_zero]\n  rotate_left\n  · exact (measurable_of_countable f).comp measurable_prod_mk_left hs\n  · rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n    exact h_ne_zero\n  rw [map_apply' _ _ _ (measurable_fst (measurableSet_singleton _)), h_preimage]\n  congr\n  rw [map_apply' _ _ _ ((measurableSet_singleton _).prod hs)]\n  congr\n  ext p\n  simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n    exists_eq_right_right, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ⟨p.2, ?_, ?_⟩, fun ⟨p2, h_mem, h_eq⟩ ↦ ?_⟩\n  · rw [h.2, Prod.mk.eta]\n    exact h.1\n  · rw [h.2, Prod.mk.eta]\n  · rw [← h_eq]\n    simp [h_mem]\n\nend condKernel\n\nend kernel\n\nsection condDistrib\n\nvariable {X : Ω → S} {Y : Ω → T} {Z : Ω → U}\n\nlemma condDistrib_apply' (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) {s : Set S} (hs : MeasurableSet s) :\n    condDistrib X Y μ x s = (μ (Y ⁻¹' {x}))⁻¹ * μ (Y ⁻¹' {x} ∩ X ⁻¹' s) := by\n  rw [condDistrib, Measure.condKernel_apply _ _ hs]\n  · rw [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _),\n      Measure.map_apply (hY.prod_mk hX) ((measurableSet_singleton _).prod hs)]\n    congr\n  · rwa [fst_map_prod_mk hX, Measure.map_apply hY (measurableSet_singleton _)]\n\nlemma condDistrib_apply (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ]\n    (x : T) (hYx : μ (Y ⁻¹' {x}) ≠ 0) :\n    condDistrib X Y μ x = (μ[|Y ⁻¹' {x}]).map X := by\n  ext s hs\n  rw [condDistrib_apply' hX hY μ x hYx hs, Measure.map_apply hX hs,\n    cond_apply _ (hY (measurableSet_singleton _))]\n\nlemma condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n    condDistrib X Y μ =ᵐ[μ.map Y] fun x ↦ (μ[|Y ⁻¹' {x}]).map X := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  exact condDistrib_apply hX hY μ x hx\n\nlemma condDistrib_comp (hX : Measurable X) (hY : Measurable Y) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (f : S → U) :\n    condDistrib (f ∘ X) Y μ\n      =ᵐ[μ.map Y] kernel.map (condDistrib X Y μ) f (measurable_of_countable _) := by\n  have hf : Measurable f := measurable_of_countable _\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply hY (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply' (hf.comp hX) hY _ _ hx hs, kernel.map_apply' _ _ _ hs,\n    condDistrib_apply' hX hY _ _ hx (hf hs), Set.preimage_comp]\n\nlemma condDistrib_fst_of_ne_zero\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω) [IsFiniteMeasure μ]\n    (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib X Z μ u := by\n  ext A hA\n  rw [kernel.fst_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_fst hA\n  rw [condDistrib_apply' hX hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_fst_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.fst (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib X Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_fst_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condDistrib_snd_of_ne_zero (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] (u : U) (hu : μ (Z ⁻¹' {u}) ≠ 0) :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ) u\n      = condDistrib Y Z μ u := by\n  ext A hA\n  rw [kernel.snd_apply' _ _ hA, condDistrib_apply' (hX.prod_mk hY) hZ _ _ hu]\n  swap; · exact measurable_snd hA\n  rw [condDistrib_apply' hY hZ _ _ hu hA]\n  rfl\n\nlemma condDistrib_snd_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.snd (condDistrib (fun a ↦ (X a, Y a)) Z μ)\n      =ᵐ[μ.map Z] condDistrib Y Z μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [condDistrib_snd_of_ne_zero hX hY hZ]\n  rwa [Measure.map_apply hZ (measurableSet_singleton _)] at hx\n\nlemma condKernel_condDistrib_ae_eq\n    (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z) (μ : Measure Ω)\n    [IsFiniteMeasure μ] :\n  kernel.condKernel (condDistrib (fun a ↦ (X a, Y a)) Z μ) =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))]\n    condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  ext A hA\n  have hx1 : μ (Z ⁻¹' {x.1}) ≠ 0 := by\n    refine fun h_null ↦ hx (measure_mono_null ?_ h_null)\n    intro ω hω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff] at hω ⊢\n    rw [← Prod.eta x, Prod.mk.inj_iff] at hω\n    exact hω.1\n  rw [kernel.condKernel_apply' _ _ _ hA]\n  swap\n  · rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n    swap\n    · exact measurable_fst (measurableSet_singleton _)\n    simp only [ne_eq, mul_eq_zero, ENNReal.inv_eq_zero, measure_ne_top μ, false_or]\n    convert hx\n    ext ω\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff]\n    conv_rhs => rw [← Prod.eta x]\n    exact Prod.mk.inj_iff.symm\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact measurable_fst (measurableSet_singleton _)\n  rw [condDistrib_apply' (hX.prod_mk hY) hZ _ _ hx1]\n  swap\n  · exact (measurable_fst (measurableSet_singleton _)).inter (measurable_snd hA)\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ hx hA]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' (Prod.fst ⁻¹' {x.2}) = X ⁻¹' {x.2} := by rfl\n  simp_rw [this]\n  have : (fun a ↦ (X a, Y a)) ⁻¹' ({x.2} ×ˢ A) = X ⁻¹' {x.2} ∩ Y ⁻¹' A := by\n    ext y;\n    simp only [Set.singleton_prod, Set.mem_preimage, Set.mem_image, Prod.mk.injEq,\n      exists_eq_right_right, Set.mem_inter_iff, Set.mem_singleton_iff]\n    tauto\n  simp_rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' {x} = Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} := by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, Set.mem_inter_iff]\n    conv_lhs => rw [← Prod.eta x, Prod.mk.inj_iff]\n  rw [this, ENNReal.mul_inv (Or.inr (measure_ne_top _ _)), inv_inv]\n  swap; · left; simp [hx1]\n  calc (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      ((μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)))\n    = (μ (Z ⁻¹' {x.1})) * (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ *\n      μ (Z ⁻¹' {x.1} ∩ (X ⁻¹' {x.2} ∩ Y ⁻¹' A)) := by\n        ring\n  _ = (μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x.2} ∩ Y ⁻¹' A) := by\n        rw [ENNReal.mul_inv_cancel hx1 (measure_ne_top _ _), one_mul, Set.inter_assoc]\n\nlemma swap_condDistrib_ae_eq (hX : Measurable X) (hY : Measurable Y) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.comap (condDistrib Y (fun a ↦ (X a, Z a)) μ) Prod.swap measurable_swap\n      =ᵐ[μ.map (fun ω ↦ (Z ω, X ω))] condDistrib Y (fun ω ↦ (Z ω, X ω)) μ := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  ext A hA\n  rw [kernel.comap_apply']\n  have h_swap : (fun a ↦ (X a, Z a)) ⁻¹' {Prod.swap x} = (fun a ↦ (Z a, X a)) ⁻¹' {x} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.swap_prod_mk, Prod.mk.inj_iff, Prod.mk.inj_iff, and_comm]\n  rw [condDistrib_apply' hY (hX.prod_mk hZ) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _), ← h_swap] at hx\n  rw [condDistrib_apply' hY (hZ.prod_mk hX) _ _ _ hA]\n  swap; · rwa [Measure.map_apply (hZ.prod_mk hX) (measurableSet_singleton _)] at hx\n  rw [h_swap]\n\nlemma condDistrib_const_unit (hX : Measurable X) (hY : Measurable Y)\n    (μ : Measure Ω) [IsFiniteMeasure μ] :\n    kernel.condKernel (kernel.const Unit (μ.map (fun ω ↦ (X ω, Y ω))))\n      =ᵐ[μ.map (fun ω ↦ ((), X ω))] kernel.prodMkLeft Unit (condDistrib Y X μ) := by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  have : (fun a ↦ ((), X a)) ⁻¹' {x} = X ⁻¹' {x.2} := by\n    ext ω\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    rw [← Prod.eta x, Prod.mk.inj_iff]\n    simp\n  rw [Measure.map_apply (measurable_const.prod_mk hX) (measurableSet_singleton _), this] at hx\n  ext s hs\n  rw [kernel.condKernel_apply' _ _ _ hs]\n  swap\n  · rw [kernel.const_apply,\n      Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _))]\n    exact hx\n  simp_rw [kernel.const_apply,\n    Measure.map_apply (hX.prod_mk hY) (measurable_fst (measurableSet_singleton _)),\n    Measure.map_apply (hX.prod_mk hY) ((measurableSet_singleton _).prod hs)]\n  rw [kernel.prodMkLeft_apply', condDistrib_apply' hY hX _ _ hx hs]\n  rfl\n\nlemma condDistrib_unit_right (hX : Measurable X) (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    condDistrib X (fun _ ↦ ()) μ = kernel.const Unit (μ.map X) := by\n  ext x s hs\n  rw [condDistrib_apply' hX measurable_const _ _ _ hs]\n  · simp only [Set.mem_singleton_iff, Set.preimage_const_of_mem, measure_univ, inv_one,\n      Set.univ_inter, one_mul]\n    rw [kernel.const_apply, Measure.map_apply hX hs]\n  · simp\n\nlemma map_compProd_condDistrib (hX : Measurable X) (hZ : Measurable Z)\n    (μ : Measure Ω) [IsProbabilityMeasure μ] :\n    μ.map Z ⊗ₘ condDistrib X Z μ = μ.map (fun ω ↦ (Z ω, X ω)) := by\n  ext A hA\n  rw [Measure.map_apply (hZ.prod_mk hX) hA, Measure.compProd_apply hA, lintegral_eq_sum_countable]\n  have : ∑' x : U, μ.map Z {x} * condDistrib X Z μ x (Prod.mk x ⁻¹' A)\n      = ∑' x : U, μ (Z ⁻¹' {x} ∩ (fun ω ↦ (x, X ω)) ⁻¹' A) := by\n    congr 1 with x\n    rw [Measure.map_apply hZ (measurableSet_singleton _)]\n    by_cases hx : μ (Z ⁻¹' {x}) = 0\n    · simp only [hx, zero_mul, Set.mem_setOf_eq, Set.preimage_setOf_eq]\n      exact (measure_mono_null (Set.inter_subset_left _ _) hx).symm\n    rw [condDistrib_apply' hX hZ _ _ hx]\n    swap; · exact (measurable_prod_mk_left hA)\n    rw [← mul_assoc, ENNReal.mul_inv_cancel hx (measure_ne_top _ _), one_mul]\n    congr\n  rw [this]\n  have : (fun a ↦ (Z a, X a)) ⁻¹' A = ⋃ x, Z ⁻¹' {x} ∩ ((fun a ↦ (x, X a)) ⁻¹' A) := by\n    ext ω\n    simp\n  rw [this, measure_iUnion]\n  · intro i j hij\n    rw [Function.onFun]\n    refine Disjoint.mono (Set.inter_subset_left _ _) (Set.inter_subset_left _ _) ?_\n    rw [Set.disjoint_iff]\n    intro z\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_empty_iff_false,\n      and_imp]\n    exact fun hi hj ↦ hij (hi.symm.trans hj)\n  intro u\n  exact (hZ (measurableSet_singleton _)).inter (measurable_const.prod_mk hX hA)\n\nsection Independence\n\nvariable {V : Type*} [Countable V] [Nonempty V] [MeasurableSpace V] [MeasurableSingletonClass V]\n  {W : Ω → V}\n\n","proof":":= by\n  rw [Filter.EventuallyEq, ae_iff_of_countable]\n  intro x hx\n  rw [Measure.map_apply (hZ.prod_mk hW) (measurableSet_singleton _)] at hx\n  ext s hs\n  rw [condDistrib_apply (hX.prod_mk hY) (hZ.prod_mk hW) _ _ hx, kernel.prod_apply' _ _ _ hs]\n  simp_rw [kernel.prodMkLeft_apply, kernel.prodMkRight_apply]\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod] at hx\n  have hxZ : μ (Z ⁻¹' {x.1}) ≠ 0 := fun h0 ↦ hx (measure_mono_null (Set.inter_subset_left _ _) h0)\n  have hxW : μ (W ⁻¹' {x.2}) ≠ 0 := fun h0 ↦ hx (measure_mono_null (Set.inter_subset_right _ _) h0)\n  simp_rw [lintegral_eq_sum_countable, condDistrib_apply hX hZ μ _ hxZ,\n    condDistrib_apply hY hW μ _ hxW, Measure.map_apply (hX.prod_mk hY) hs]\n  rw [← Prod.eta x, ← Set.singleton_prod_singleton, Set.mk_preimage_prod,\n    cond_apply _ ((hZ (measurableSet_singleton _)).inter (hW (measurableSet_singleton _)))]\n  simp_rw [Measure.map_apply hX (measurableSet_singleton _),\n    cond_apply _ (hZ (measurableSet_singleton _))]\n  change (μ (Z ⁻¹' {x.1} ∩ W ⁻¹' {x.2}))⁻¹\n      * μ (Z ⁻¹' {x.1} ∩ W ⁻¹' {x.2} ∩ (fun a ↦ (X a, Y a)) ⁻¹' s)\n    = ∑' x_1, (μ (Z ⁻¹' {x.1}))⁻¹ * μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {x_1})\n      * ((μ[|W ⁻¹' {x.2}]).map Y) (Prod.mk x_1 ⁻¹' s)\n  simp_rw [Measure.map_apply hY (measurable_prod_mk_left hs),\n    cond_apply _ (hW (measurableSet_singleton _))]\n  have hZW : IndepFun Z W μ := by\n    have h' := IndepFun.comp h measurable_snd measurable_snd\n    exact h'\n  have h_indep1 : (μ (Z ⁻¹' {x.1} ∩ W ⁻¹' {x.2}))⁻¹\n      = (μ (Z ⁻¹' {x.1}))⁻¹ * (μ (W ⁻¹' {x.2}))⁻¹ := by\n    rw [indepFun_iff_measure_inter_preimage_eq_mul.mp hZW _ _ (measurableSet_singleton _)\n      (measurableSet_singleton _), ENNReal.mul_inv (Or.inl hxZ) (Or.inl (measure_ne_top _ _))]\n  rw [h_indep1]\n  simp_rw [mul_assoc, ENNReal.tsum_mul_left]\n  congr 1\n  simp_rw [← mul_assoc, mul_comm _ (μ (W ⁻¹' {x.2}))⁻¹, mul_assoc, ENNReal.tsum_mul_left]\n  congr 1\n  have h_Union : (fun ω ↦ (X ω, Y ω)) ⁻¹' s = ⋃ a, ((X ⁻¹' {a}) ∩ (Y ⁻¹' (Prod.mk a ⁻¹' s))) := by\n    ext1; simp\n  rw [h_Union, Set.inter_iUnion, measure_iUnion]\n  rotate_left\n  · intro i j hij\n    rw [Function.onFun, Set.disjoint_iff]\n    intro y\n    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_empty_iff_false,\n      and_imp]\n    exact fun _ _ h3 _ _ _ h7 _ ↦ hij (h3.symm.trans h7)\n  · intro b\n    refine ((hZ (measurableSet_singleton _)).inter (hW (measurableSet_singleton _))).inter ?_\n    exact (hX (measurableSet_singleton _)).inter (hY (measurable_prod_mk_left hs))\n  congr with b\n  calc μ (Z ⁻¹' {x.1} ∩ W ⁻¹' {x.2} ∩ (X ⁻¹' {b} ∩ Y ⁻¹' (Prod.mk b ⁻¹' s)))\n    = μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {b} ∩ (W ⁻¹' {x.2} ∩ Y ⁻¹' (Prod.mk b ⁻¹' s))) := by\n        rw [Set.inter_assoc, ← Set.inter_assoc (W ⁻¹' {x.2}), Set.inter_comm (W ⁻¹' {x.2}),\n          ← Set.inter_assoc, ← Set.inter_assoc, ← Set.inter_assoc]\n  _ = μ ((fun ω ↦ (X ω, Z ω)) ⁻¹' {(b, x.1)}\n      ∩ ((fun ω ↦ (Y ω, W ω)) ⁻¹' ((Prod.mk b ⁻¹' s) ×ˢ {x.2}))) := by\n        rw [← Set.singleton_prod_singleton, Set.mk_preimage_prod, Set.inter_comm (Z ⁻¹' {x.1}),\n          Set.mk_preimage_prod, Set.inter_comm (W ⁻¹' {x.2})]\n  _ = μ ((fun ω ↦ (X ω, Z ω)) ⁻¹' {(b, x.1)})\n      * μ ((fun ω ↦ (Y ω, W ω)) ⁻¹' ((Prod.mk b ⁻¹' s) ×ˢ {x.2})) := by\n        refine indepFun_iff_measure_inter_preimage_eq_mul.mp h _ _ (measurableSet_singleton _) ?_\n        exact (measurable_prod_mk_left hs).prod (measurableSet_singleton _)\n  _ = μ (Z ⁻¹' {x.1} ∩ X ⁻¹' {b}) * μ (W ⁻¹' {x.2} ∩ Y ⁻¹' (Prod.mk b ⁻¹' s)) := by\n        rw [← Set.singleton_prod_singleton, Set.mk_preimage_prod, Set.inter_comm (Z ⁻¹' {x.1}),\n          Set.mk_preimage_prod, Set.inter_comm (W ⁻¹' {x.2})]","declId":"PFR.Mathlib.Probability.Kernel.Disintegration.466_0.nLcAs7vqkgHUZBd","decl":"lemma condDistrib_eq_prod_of_indepFun\n    (hX : Measurable X) (hZ : Measurable Z) (hY : Measurable Y) (hW : Measurable W)\n    (μ : Measure Ω) [IsProbabilityMeasure μ]\n    (h : IndepFun (fun ω ↦ (X ω, Z ω)) (fun ω ↦ (Y ω, W ω)) μ) :\n    condDistrib (fun ω ↦ (X ω, Y ω)) (fun ω ↦ (Z ω, W ω)) μ\n      =ᵐ[μ.map (fun ω ↦ (Z ω, W ω))] kernel.prodMkRight V (condDistrib X Z μ)\n        ×ₖ kernel.prodMkLeft U (condDistrib Y W μ) "}
